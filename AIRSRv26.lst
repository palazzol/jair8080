ASxxxx Assembler V05.31  (Intel 8085)                                   Page 1
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                              1 ;Replacement 8080A cpu board for ALTAIR/IMSAI
                              2 ;Monitor program for 8080A based computer.
                              3 ;Written by Josh Bensadon
                              4 ;Free for public use, following all the shareware policies & disclaimers.
                              5 ;
                              6 ;CONSOLE BIOS is near end of file, can be modified to talk to any UART
                              7 ;FLOPPY DISK BIOS is also near end of file
                              8 ;
                              9 ;The boot loader in the EPROM will load this file automatically if this file
                             10 ;is renamed to BIOS.HEX.  The batch file to assemble this file will do this.
                             11 ;
                             12 ;
                             13 ;Version 1.0 - Josh Bensadon.  Reused all code from previous Monitor program ver 1.7
                             14 ;1.1	-JB. Corrected problem with BIOS DISK read/write by changing to my own temp stack
                             15 ;	-Corrected hidden problem with Drive Parameter Table
                             16 ;1.2	-Set Stack to high RAM
                             17 ;	-Corrected problem with Sectors starting at 0
                             18 ;2.0	-Created a more elaborate Boot Loader to be installed in EPROM.
                             19 ;	-This System ROM can now be loaded via the BIOS.HEX file on the SD Card
                             20 ;2.1	-Fixed an issue with output to both Propeller and UART Com-port
                             21 ;2.2	-Dropped UART Com-Port to observe a 33% console speed increase
                             22 ;2.3	-Resuming from v2.1 (dual support).  Corrected firmware for configuration
                             23 ;	-when Propeller I/O board is NOT present.
                             24 ;2.4	-Added Config File to select the default disk files and DPB settins for various sized disk images
                             25 ;2.5
                             26 ;2.6	-Made Track handle 16 bit
                             27 ;
                             28 ;
                             29 
                             30 
                             31 ;Monitor for the IMSAI 8080
                             32 ;Functions:
                             33 ; -Dump, Edit & Execute Memory.
                             34 ; -Input Port and Output Port.
                             35 ; -RAM Test
                             36 ; -ASCII Upload text file
                             37 ; -XMODEM up/down load to Memory
                             38 ; -XMODEM up/down load to Disk
                             39 ;
                             40 ; AA8080.ASM works with the Standard Console port of the Altair (Port 0=Status, Port 1=RX/TX)
                             41 ; Tested on the Solid State Music Computer Systems IO4 Serial/Parallel interface board installed on an IMSAI 8080
                             42 ; Floppy functions work with the Tarbell 1101 (using the Western Digital FD1771 Floppy Disk Controller chip).
                             43 ;
                             44 ; D XXXX YYYY	Dump memory from XXXX to YYYY
                             45 ; E XXXX	Edit memory starting at XXXX (type an X and press enter to exit entry)
                             46 ; G XXXX	GO starting at address XXXX (Monitor program address left on stack)
                             47 ; I XX		Input from I/O port XX and display as hex
                             48 ; O XX YY	Output to I/O port XX byte YY
                             49 ; X U XXXX	XMODEM Upload to memory at XXXX (CRC or CHECKSUM)
                             50 ; X D XXXX CCCC	XMODEM Download from memory at XXXX for CCCC number of 128 byte blocks
                             51 ; :ssHHLLttDDDDDD...CS   -ASCII UPLOAD Intel HEX file to Memory.  Monitor auto downloads with the reception of a colon.
                             52 ; F 		Floppy commands
                             53 ; R XX YY	RAM TEST from pages XX to YY
                             54 
                             55 ;
ASxxxx Assembler V05.31  (Intel 8085)                                   Page 2
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                             56 ; Search for BIOS sections to adapt to other systems
                             57 
                             58 
                             59 
                             60         .area   CODE1   (ABS)   ; ASXXXX directive, absolute addressing
                             61 
                             62 ;----------------------------; IMSAI CONSOLE PORTS
                     00FF    63 FPLED		.EQU 255	;Front Panel LED
                     00FF    64 FPSW		.EQU 255	;Front Panel Switches
                             65 ;----------------------------;
                             66 
                     0000    67 PROPELLERS	.EQU 0		;Propeller Console Status Port
                     0001    68 PROPELLERD	.EQU 1		;Propeller Console Data Port
                             69 
                     0020    70 CPU_IO		.EQU 0x20	;Base address for onboard CPU I/O
                     0020    71 UART0		.EQU CPU_IO
                     0028    72 UART1		.EQU CPU_IO+0x8
                     0030    73 SPI		.EQU CPU_IO+0x10
                     0031    74 SPI_SS		.EQU SPI+1
                     0038    75 PORT2		.EQU CPU_IO+0x18
                             76 
                     0000    77 DEBUG		.EQU 0b00000000
                             78 		;1 = CP/M BIOS
                             79 		;2 = LOW level SD Card
                             80 		;0x80 = UART1
                             81 
                             82 
                     0080    83 CPM_DSK_BUFF	.EQU 0x80	;Default CPM Buffer of 128 Bytes
                             84 
   DB00                      85 		.ORG 0xDB00
   DB00 31 00 FD      [10]   86 CODE_START:	LXI	SP,HIGHSTACK ;128 Bytes of stack available.
   DB03 3E 80         [ 7]   87 		MVI	A,0x80	;Set baud rate
   DB05 D3 23         [10]   88 		OUT	UART0+3
   DB07 D3 2B         [10]   89 		OUT	UART1+3
   DB09 3E 0C         [ 7]   90 		MVI	A,12	;12=9600 baud
   DB0B D3 20         [10]   91 		OUT	UART0
   DB0D D3 28         [10]   92 		OUT	UART1
   DB0F 3E 00         [ 7]   93 		MVI	A,0
   DB11 D3 21         [10]   94 		OUT	UART0+1
   DB13 D3 29         [10]   95 		OUT	UART1+1
   DB15 3E 03         [ 7]   96 		MVI	A,3	;Set 8 data bits, no parity, 1 stop
   DB17 D3 23         [10]   97 		OUT	UART0+3
   DB19 D3 2B         [10]   98 		OUT	UART1+3
                             99 
   DB1B 3E FF         [ 7]  100 		MVI	A,0xFF
   DB1D 32 82 FD      [13]  101 		STA	PROP_CHECK
                            102 
   DB20 CD 98 F0      [18]  103 		CALL	PRINTI		;System Start, Display Welcome Message
   DB23 0D 0A 41 4C 54 41   104 		.ascii "\r\nALTAIR/IMSAI 8080 CPU BOARD - Josh Bensadon v2.6 (Oct 2016)\r\n\000"
        49 52 2F 49 4D 53
        41 49 20 38 30 38
        30 20 43 50 55 20
        42 4F 41 52 44 20
        2D 20 4A 6F 73 68
        20 42 65 6E 73 61
ASxxxx Assembler V05.31  (Intel 8085)                                   Page 3
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



        64 6F 6E 20 76 32
        2E 36 20 28 4F 63
        74 20 32 30 31 36
        29 0D 0A 00
                            105 
   DB63 CD A3 F3      [18]  106 		CALL	INIT_FAT
   DB66 CD 98 F0      [18]  107 		CALL	PRINTI
   DB69 0D 0A 00            108 		.ascii "\r\n\000"
                            109 
                            110 
   DB6C 21 00 00      [10]  111 		LXI	H,0
   DB6F 22 99 FD      [16]  112 		SHLD	LOGICAL_SEC
                            113 
   DB72 21 40 DD      [10]  114 		LXI	H,FCB_CONFIG
   DB75 22 83 FD      [16]  115 		SHLD	FCB_PTR
   DB78 CD 51 F3      [18]  116 		CALL	SD_OPEN
   DB7B C2 95 DB      [10]  117 		JNZ	FILEOK
   DB7E CD 98 F0      [18]  118 GO_HALT:		CALL	PRINTI
   DB81 20 2D 20 48 41 4C   119 		.ascii " - HALT\000"
        54 00
   DB89 76            [ 4]  120 1$:		HLT
   DB8A C3 89 DB      [10]  121 		JMP	1$
                            122 
   DB8D 06 0C         [ 7]  123 INPUT_NAME:	MVI	B,12
   DB8F CD E2 F8      [18]  124 		CALL	COPY_RAM
   DB92 23            [ 6]  125 		INX	H
   DB93 23            [ 6]  126 		INX	H
   DB94 C9            [10]  127 		RET
                            128 
   DB95 2A DC FD      [16]  129 FILEOK:		LHLD	FILESIZE	;Save file size of Config File
   DB98 22 5C DD      [16]  130 		SHLD	CONFIGSIZE
   DB9B CD C7 F1      [18]  131 		CALL	DISK_READ	;HL=Buffer
                            132 
   DB9E 11 00 FD      [10]  133 		LXI	D,SDISKA	;Preload all SD_FCB's with file names for 4 disks
   DBA1 CD 8D DB      [18]  134 		CALL	INPUT_NAME
   DBA4 11 20 FD      [10]  135 		LXI	D,SDISKB
   DBA7 CD 8D DB      [18]  136 		CALL	INPUT_NAME
   DBAA 11 40 FD      [10]  137 		LXI	D,SDISKC
   DBAD CD 8D DB      [18]  138 		CALL	INPUT_NAME
   DBB0 11 60 FD      [10]  139 		LXI	D,SDISKD
   DBB3 CD 8D DB      [18]  140 		CALL	INPUT_NAME
                            141 
                            142 
   DBB6 CD 98 F0      [18]  143 BOOT_MENU:	CALL	PRINTI		;BOOT Menu
   DBB9 0D 0A 0D 0A 4D 20   144 		.ascii "\r\n\r\nM - Monitor"
        2D 20 4D 6F 6E 69
        74 6F 72
   DBC8 0D 0A 43 20 2D 20   145 		.ascii "\r\nC - Boot CP/M\000"
        42 6F 6F 74 20 43
        50 2F 4D 00
                            146 
   DBD8 AF            [ 4]  147 		XRA	A		;Loop through the 4 SD_FCB's and try to open/init the FCB's
   DBD9 F5            [12]  148 BMD_LP:		PUSH	PSW
   DBDA 57            [ 7]  149 		MOV	D,A		;D=A=File (0 to 3) (D for printing)
   DBDB CD 38 F1      [18]  150 		CALL	SET_FCB_PTR
ASxxxx Assembler V05.31  (Intel 8085)                                   Page 4
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   DBDE 01 0A 00      [10]  151 		LXI	B,10
   DBE1 09            [10]  152 		DAD	B
   DBE2 CD EB F8      [18]  153 		CALL	LD_HL_HL
   DBE5 22 62 DD      [16]  154 		SHLD	DPBPTR		;Save the DPB location
   DBE8 CD 98 F0      [18]  155 		CALL	PRINTI
   DBEB 0D 0A 20 20 00      156 		.ascii "\r\n  \000"
   DBF0 7A            [ 4]  157 		MOV	A,D
   DBF1 3C            [ 4]  158 		INR	A
   DBF2 CD 7F F0      [18]  159 		CALL	PUT_HEX
   DBF5 CD 98 F0      [18]  160 		CALL	PRINTI
   DBF8 20 2D 20 44 69 73   161 		.ascii " - Disk \000"
        6B 20 00
   DC01 7A            [ 4]  162 		MOV	A,D
   DC02 C6 41         [ 7]  163 		ADI	"A"
   DC04 CD EB F0      [18]  164 		CALL	PUT_CHAR
   DC07 CD 98 F0      [18]  165 		CALL	PRINTI
   DC0A 20 3D 20 00         166 		.ascii " = \000"
   DC0E CD 51 F3      [18]  167 		CALL	SD_OPEN
                            168 
   DC11 21 DF FD      [10]  169 		LXI	H,FILESIZE+3		;Convert the 4 byte file size into 8 byte ASCII
   DC14 11 E3 FD      [10]  170 		LXI	D,FILESIZEHEX+3
   DC17 06 04         [ 7]  171 		MVI	B,4			;4 bytes
   DC19 7E            [ 7]  172 FS2ASC_LP:	MOV	A,M
   DC1A CD 85 F0      [18]  173 		CALL	BIN2HEX
   DC1D 12            [ 7]  174 		STAX	D
   DC1E 7E            [ 7]  175 		MOV	A,M
   DC1F 0F            [ 4]  176 		RRC
   DC20 0F            [ 4]  177 		RRC
   DC21 0F            [ 4]  178 		RRC
   DC22 0F            [ 4]  179 		RRC
   DC23 CD 85 F0      [18]  180 		CALL	BIN2HEX
   DC26 1B            [ 6]  181 		DCX	D
   DC27 12            [ 7]  182 		STAX	D
   DC28 1B            [ 6]  183 		DCX	D
   DC29 2B            [ 6]  184 		DCX	H
   DC2A 05            [ 4]  185 		DCR	B
   DC2B C2 19 DC      [10]  186 		JNZ	FS2ASC_LP
                            187 
                            188 
   DC2E 21 00 00      [10]  189 		LXI	H,0		;Read Config file to find paramaters for a file of this size
   DC31 22 99 FD      [16]  190 		SHLD	LOGICAL_SEC
   DC34 21 40 DD      [10]  191 		LXI	H,FCB_CONFIG
   DC37 22 83 FD      [16]  192 		SHLD	FCB_PTR
                            193 
                            194 					;Get Line
   DC3A 01 64 DD      [10]  195 		LXI	B,LINE_BUFF
   DC3D 2A 5C DD      [16]  196 		LHLD	CONFIGSIZE
   DC40 22 5E DD      [16]  197 		SHLD	CONFIGSIZECNT
   DC43 EB            [ 4]  198 		XCHG			;DE = CONFIG FILE SIZE
                            199 
   DC44 C5            [12]  200 GL_LP1:		PUSH	B
   DC45 D5            [12]  201 		PUSH	D
   DC46 CD C7 F1      [18]  202 		CALL	DISK_READ	;HL=BUFF
   DC49 D1            [10]  203 		POP	D		;DE=Count of Remaining Bytes in file
   DC4A C1            [10]  204 		POP	B		;BC=LINE_BUF PTR
ASxxxx Assembler V05.31  (Intel 8085)                                   Page 5
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                            205 
   DC4B 7E            [ 7]  206 GL_LP2:		MOV	A,M		;Get a char
   DC4C FE 20         [ 7]  207 		CPI	" "
   DC4E DA 70 DC      [10]  208 		JC	GL_CTRL		;Jump out when a control char is found
   DC51 02            [ 7]  209 		STAX	B		;Save char to Line Buff
                            210 
   DC52 3E E4         [ 7]  211 		MVI	A, <(LINE_BUFFEND) ;If BC <> End of Line Buffer, then BC = BC + 1
   DC54 B9            [ 4]  212 		CMP	C
   DC55 CA 59 DC      [10]  213 		JZ	GL_BF
   DC58 03            [ 6]  214 		INX	B
   DC59 23            [ 6]  215 GL_BF:		INX	H
   DC5A 1B            [ 6]  216 		DCX	D
   DC5B 7A            [ 4]  217 		MOV	A,D
   DC5C B3            [ 4]  218 		ORA	E
   DC5D CA C3 DC      [10]  219 		JZ	GL_EOF
                            220 
   DC60 AF            [ 4]  221 		XRA	A
   DC61 BC            [ 4]  222 		CMP	H		;IF HL <> End of Disk Buffer, then Loop back for next char
   DC62 C2 4B DC      [10]  223 		JNZ	GL_LP2
                            224 
   DC65 3A 99 FD      [13]  225 		LDA	LOGICAL_SEC	;Advance to next sector (4x128 = 512)
   DC68 C6 04         [ 7]  226 		ADI	4
   DC6A 32 99 FD      [13]  227 		STA	LOGICAL_SEC
   DC6D C3 44 DC      [10]  228 		JMP	GL_LP1
                            229 
   DC70 AF            [ 4]  230 GL_CTRL:		XRA	A		;Save 000 at end of line
   DC71 02            [ 7]  231 		STAX	B
   DC72 E5            [12]  232 		PUSH	H
                            233 
   DC73 01 DC FD      [10]  234 		LXI	B,FILESIZE
   DC76 21 64 DD      [10]  235 		LXI	H,LINE_BUFF
   DC79 0A            [ 7]  236 GLT_LP:		LDAX	B
   DC7A BE            [ 7]  237 		CMP	M
   DC7B C2 BC DC      [10]  238 		JNZ	GLT_NOTEQ
   DC7E 03            [ 6]  239 		INX	B
   DC7F 23            [ 6]  240 		INX	H
   DC80 3E 6C         [ 7]  241 		MVI	A, <(LINE_BUFF+8)
   DC82 BD            [ 4]  242 		CMP	L
   DC83 C2 79 DC      [10]  243 		JNZ	GLT_LP
                            244 					;HURRAY, WE HAVE FOUND THE RIGHT DISK SIZE
                            245 					;COPY DPB, PRINT MSG
   DC86 23            [ 6]  246 		INX	H
   DC87 EB            [ 4]  247 		XCHG
   DC88 2A 62 DD      [16]  248 		LHLD	DPBPTR
   DC8B 06 0F         [ 7]  249 		MVI	B,15
   DC8D CD A7 DC      [18]  250 GTL_COPY_LP:	CALL	GTL_GETHEX
   DC90 07            [ 4]  251 		RLC
   DC91 07            [ 4]  252 		RLC
   DC92 07            [ 4]  253 		RLC
   DC93 07            [ 4]  254 		RLC
   DC94 77            [ 7]  255 		MOV	M,A
   DC95 CD A7 DC      [18]  256 		CALL	GTL_GETHEX
   DC98 B6            [ 7]  257 		ORA	M
   DC99 77            [ 7]  258 		MOV	M,A
   DC9A 23            [ 6]  259 		INX	H
ASxxxx Assembler V05.31  (Intel 8085)                                   Page 6
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                            260 
   DC9B 05            [ 4]  261 		DCR	B
   DC9C C2 8D DC      [10]  262 		JNZ	GTL_COPY_LP
   DC9F EB            [ 4]  263 		XCHG
   DCA0 CD 8E F0      [18]  264 		CALL	PRINT		;Print rest of line.
   DCA3 E1            [10]  265 		POP	H
   DCA4 C3 DE DC      [10]  266 		JMP	BMD_NEXT
                            267 
   DCA7 1A            [ 7]  268 GTL_GETHEX:	LDAX	D
   DCA8 13            [ 6]  269 		INX	D
   DCA9 CD 24 E3      [18]  270 		CALL	ASC2HEX
   DCAC D0            [12]  271 		RNC
   DCAD CD 98 F0      [18]  272 		CALL	PRINTI
   DCB0 20 42 41 44 20 48   273 		.ascii " BAD HEX\000"
        45 58 00
   DCB9 C3 7E DB      [10]  274 		JMP	GO_HALT
                            275 
                            276 
   DCBC E1            [10]  277 GLT_NOTEQ:	POP	H
   DCBD 01 64 DD      [10]  278 		LXI	B,LINE_BUFF
   DCC0 C3 59 DC      [10]  279 		JMP	GL_BF
                            280 
   DCC3 CD 98 F0      [18]  281 GL_EOF:		CALL	PRINTI
   DCC6 20 2D 20 44 49 53   282 		.ascii " - DISK SIZE NOT LISTED\000"
        4B 20 53 49 5A 45
        20 4E 4F 54 20 4C
        49 53 54 45 44 00
                            283 
   DCDE F1            [10]  284 BMD_NEXT:	POP	PSW
   DCDF 3C            [ 4]  285 		INR	A
   DCE0 FE 04         [ 7]  286 		CPI	4
   DCE2 C2 D9 DB      [10]  287 		JNZ	BMD_LP
                            288 
   DCE5 21 80 00      [10]  289 		LXI	H,CPM_DSK_BUFF		;Default CPM DMAADD
   DCE8 22 E7 FD      [16]  290 		SHLD	DMAADD
   DCEB 21 00 FD      [10]  291 		LXI	H,SDISKA		;Default FCB_PTR for Disk-A
   DCEE 22 83 FD      [16]  292 		SHLD	FCB_PTR
                            293 
   DCF1 CD 98 F0      [18]  294  		CALL	PRINTI		;BOOT Menu
   DCF4 0D 0A 3E 00         295 		.ascii "\r\n>\000"
                            296 
   DCF8 3E FF         [ 7]  297 		MVI	A,0xFF
   DCFA 32 81 FD      [13]  298 		STA	ECHO_ON		;TURN ON ECHO
   DCFD CD D8 F0      [18]  299 		CALL 	GET_CHAR	;get char
   DD00 CD 7E F8      [18]  300 		CALL	TO_UPPER
   DD03 FE 43         [ 7]  301 		CPI 	"C"		;Branch to Command entered
   DD05 CA 00 EE      [10]  302 		JZ 	CBOOTV		; C = BOOT CP/M
   DD08 FE 4D         [ 7]  303 		CPI 	"M"		;Branch to Command entered
   DD0A CA E5 DD      [10]  304 		JZ 	MAIN_MENU	; C = BOOT CP/M
   DD0D FE 31         [ 7]  305 		CPI	"1"
   DD0F DA B6 DB      [10]  306 		JC	BOOT_MENU
   DD12 FE 35         [ 7]  307 		CPI	"5"
   DD14 D2 B6 DB      [10]  308 		JNC	BOOT_MENU
   DD17 3D            [ 4]  309 		DCR	A
   DD18 CD 38 F1      [18]  310 		CALL	SET_FCB_PTR
ASxxxx Assembler V05.31  (Intel 8085)                                   Page 7
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   DD1B CD F2 F7      [18]  311 		CALL	INPUT_FNAME
   DD1E 2A 83 FD      [16]  312 		LHLD	FCB_PTR
   DD21 23            [ 6]  313 		INX	H		;FNAME
   DD22 EB            [ 4]  314 		XCHG
   DD23 21 C8 FD      [10]  315 		LXI	H,FILENAME
   DD26 06 0B         [ 7]  316 		MVI	B,11
   DD28 CD E2 F8      [18]  317 		CALL	COPY_RAM
   DD2B C3 B6 DB      [10]  318 		JMP	BOOT_MENU
                            319 
                            320 ;------------------------
   DD2E E3            [16]  321 INIT_BLOCK:	XTHL	;HL = Top of Stack
   DD2F 5E            [ 7]  322 		MOV	E,M	;Fetch address of SD_FCB to DE
   DD30 23            [ 6]  323 		INX	H
   DD31 56            [ 4]  324 		MOV	D,M
   DD32 23            [ 6]  325 		INX	H
   DD33 7E            [ 7]  326 IB_LP:		MOV	A,M	;Copy all data up to 0x00 to SD_FCB
   DD34 23            [ 6]  327 		INX	H	;Inc HL, so on finding 0x00, exit to next instruction
   DD35 B7            [ 4]  328 		ORA	A
   DD36 CA 3E DD      [10]  329 		JZ	IB_RET
   DD39 12            [ 7]  330 		STAX	D
   DD3A 13            [ 6]  331 		INX	D
   DD3B C3 33 DD      [10]  332 		JMP	IB_LP
   DD3E E3            [16]  333 IB_RET:		XTHL		;Move updated return address back to stack
   DD3F C9            [10]  334 		RET
                            335 
                            336 ;LOCAL RAM SPACE
                            337 
   DD40 00                  338 FCB_CONFIG:	.DB	0	;FSTAT		.blkb	1	;+0  Status of FCB, 00=File Not Open
   DD41 43 50 4D 44 49 53   339 		.ascii "CPMDISKSTXT"		;+1
        4B 53 54 58 54
   DD4C                     340 FCB_CONFIG_C1:	.blkb	2	;AFClus0	;+12 First Cluster of File as given by the Directory Entry.
   DD4E FF FF               341 		.DW	0xFFFF	;CRFClus	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
   DD50 FF FF               342 		.DW	0xFFFF	;CAFClus	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
   DD52 FF FF               343 		.DW	0xFFFF	;RFSec		;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
   DD54 FF FF               344 		.DW	0xFFFF	;SSOC		;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
   DD56 FF FF               345 		.DW	0xFFFF
   DD58 FF FF               346 		.DW	0xFFFF	;ABS_SEC	;+24 Absolute Sector of Current Relative Sector
   DD5A FF FF               347 		.DW	0xFFFF
                            348 
   DD5C 00 00               349 CONFIGSIZE:	.DW	0			;Size of Config File
   DD5E 00 00               350 CONFIGSIZECNT:	.DW	0
   DD60 00 00               351 CONFIGPTR:	.DW	0
   DD62 7F EE               352 DPBPTR:		.DW	DPB0
                            353 
   DD64                     354 LINE_BUFF:	.blkb 128
   DDE4 00                  355 LINE_BUFFEND:	.DB	0
                            356 
                            357 
                            358 
                            359 ;----------------------------------------------------------------------------------------------------; MONITOR MAIN MENU
                            360 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            361 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            362 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            363 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            364 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
ASxxxx Assembler V05.31  (Intel 8085)                                   Page 8
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                            365 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            366 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            367 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            368 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            369 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            370 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            371 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            372 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            373 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            374 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            375 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            376 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            377 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            378 ;----------------------------------------------------------------------------------------------------; MAIN MENU
   DDE5 21 E5 DD      [10]  379 MAIN_MENU:	LXI	H, MAIN_MENU	;Push Mainmenu onto stack as default return address
   DDE8 E5            [12]  380 		PUSH	H
   DDE9 CD 98 F0      [18]  381 		CALL	PRINTI		;Monitor Start, Display Welcome Message
   DDEC 0D 0A 4D 45 4E 55   382 		.ascii "\r\nMENU>\000"
        3E 00
   DDF4 3E FF         [ 7]  383 		MVI	A,0xFF
   DDF6 32 81 FD      [13]  384 		STA	ECHO_ON		;TURN ON ECHO
   DDF9 CD D8 F0      [18]  385 		CALL 	GET_CHAR	;get char
   DDFC FE 3A         [ 7]  386 		CPI	":"
   DDFE CA 58 E3      [10]  387 		JZ 	GETHEXFILE	; : = START HEX FILE LOAD
   DE01 E6 5F         [ 7]  388 		ANI 	0x5F		;to upper case
   DE03 FE 44         [ 7]  389 		CPI 	"D"		;Branch to Command entered
   DE05 CA FF DE      [10]  390 		JZ 	MEM_DUMP	; D = Memory Dump
   DE08 FE 45         [ 7]  391 		CPI 	"E"
   DE0A CA BE DF      [10]  392 		JZ 	MEM_EDIT	; E = Edit Memory
   DE0D FE 47         [ 7]  393 		CPI 	"G"
   DE0F CA E7 DF      [10]  394 		JZ 	MEM_EXEC	; G = Go (Execute at)
   DE12 FE 4F         [ 7]  395 		CPI 	"O"
   DE14 CA FC DF      [10]  396 		JZ 	PORT_OUT	; O = Output to port
   DE17 FE 49         [ 7]  397 		CPI 	"I"
   DE19 CA EC DF      [10]  398 		JZ 	PORT_INP	; I = Input from Port
   DE1C FE 53         [ 7]  399 		CPI 	"S"
   DE1E CA 11 E0      [10]  400 		JZ 	SD_MENU		; S = SD Card Functions
   DE21 FE 58         [ 7]  401 		CPI 	"X"
   DE23 CA C8 E3      [10]  402 		JZ 	XMODEM		; X = XMODEM
   DE26 FE 52         [ 7]  403 		CPI 	"R"
   DE28 CA 2A E6      [10]  404 		JZ	RAM_TEST	; R = RAM TEST
   DE2B FE 55         [ 7]  405 		CPI 	"U"
   DE2D CA E0 DE      [10]  406 		JZ	MEM_UNASM	; U = UNASSEMBLE
   DE30 CD 98 F0      [18]  407 		CALL 	PRINTI		;Display Err when input is invalid
   DE33 0D 0A 49 4E 56 41   408 		.ascii "\r\nINVALID CMD\000"
        4C 49 44 20 43 4D
        44 00
                            409 
   DE41 CD 98 F0      [18]  410 		CALL 	PRINTI		;Display Err when input is invalid
   DE44 0D 0A 48 45 4C 50   411 		.ascii "\r\nHELP"
   DE4A 0D 0A 44 20 2D 44   412 		.ascii "\r\nD -Dump"
        75 6D 70
   DE53 0D 0A 45 20 2D 45   413 		.ascii "\r\nE -Edit"
        64 69 74
   DE5C 0D 0A 47 20 2D 47   414 		.ascii "\r\nG -Go (Exec)"
ASxxxx Assembler V05.31  (Intel 8085)                                   Page 9
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



        6F 20 28 45 78 65
        63 29
   DE6A 0D 0A 4F 20 2D 4F   415 		.ascii "\r\nO -Output to port"
        75 74 70 75 74 20
        74 6F 20 70 6F 72
        74
   DE7D 0D 0A 49 20 2D 49   416 		.ascii "\r\nI -Input to port"
        6E 70 75 74 20 74
        6F 20 70 6F 72 74
   DE8F 0D 0A 53 20 2D 53   417 		.ascii "\r\nS -SD Card Functions"
        44 20 43 61 72 64
        20 46 75 6E 63 74
        69 6F 6E 73
   DEA5 0D 0A 58 20 2D 58   418 		.ascii "\r\nX -XModem Up/Down Load"
        4D 6F 64 65 6D 20
        55 70 2F 44 6F 77
        6E 20 4C 6F 61 64
   DEBD 0D 0A 52 20 2D 52   419 		.ascii "\r\nR -RAM TEST"
        41 4D 20 54 45 53
        54
   DECA 0D 0A 55 20 2D 55   420 		.ascii "\r\nU -Unassemble"
        6E 61 73 73 65 6D
        62 6C 65
   DED9 0D 0A 3E 00         421 		.ascii "\r\n>\000"
   DEDD C3 E5 DD      [10]  422 		JMP 	MAIN_MENU
                            423 
                            424 
                            425 ;=============================================================================
                            426 ;MEMORY UNASSEMBLE
                            427 ;-----------------------------------------------------------------------------
   DEE0 CD FF E2      [18]  428 MEM_UNASM:	CALL	SPACE_GET_WORD	;Input start address
   DEE3 EB            [ 4]  429 		XCHG			;HL = Start
   DEE4 CD 48 F0      [18]  430 		CALL	PUT_NEW_LINE
   DEE7 AF            [ 4]  431 		XRA	A
   DEE8 32 81 FD      [13]  432 		STA	ECHO_ON		;TURN OFF ECHO
   DEEB 06 0A         [ 7]  433 MU_LP1:		MVI	B,10
   DEED C5            [12]  434 MU_LP2:		PUSH	B
   DEEE CD F9 EA      [18]  435 		CALL	DISASM
   DEF1 C1            [10]  436 		POP	B
   DEF2 05            [ 4]  437 		DCR	B
   DEF3 C2 ED DE      [10]  438 		JNZ	MU_LP2
   DEF6 CD D8 F0      [18]  439 		CALL	GET_CHAR
   DEF9 FE 1B         [ 7]  440 		CPI	27
   DEFB C2 EB DE      [10]  441 		JNZ	MU_LP1
   DEFE C9            [10]  442 		RET
                            443 
                            444 ;=============================================================================
                            445 ;MEMORY DUMP
                            446 ;-----------------------------------------------------------------------------
   DEFF CD FF E2      [18]  447 MEM_DUMP:	CALL	SPACE_GET_WORD	;Input start address
   DF02 EB            [ 4]  448 		XCHG			;HL = Start
   DF03 CD FF E2      [18]  449 		CALL	SPACE_GET_WORD	;Input end address (DE = end)
                            450 
   DF06 CD 48 F0      [18]  451 MEM_DUMP_LP:	CALL	PUT_NEW_LINE
   DF09 CD 40 DF      [18]  452 		CALL	DUMP_LINE	;Dump 16 byte lines (advances HL)
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 10
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   DF0C C8            [12]  453 		RZ			;RETURN WHEN HL=DE
   DF0D 7D            [ 4]  454 		MOV	A,L
   DF0E B7            [ 4]  455 		ORA	A
   DF0F C2 06 DF      [10]  456 		JNZ	MEM_DUMP_LP	;Dump 1 Page, then prompt for continue
   DF12 CD 18 DF      [18]  457 		CALL	GET_CONTINUE
   DF15 C3 06 DF      [10]  458 		JMP	MEM_DUMP_LP
                            459 
                            460 
   DF18 CD 48 F0      [18]  461 GET_CONTINUE:	CALL	PUT_NEW_LINE
   DF1B CD 98 F0      [18]  462 		CALL	PRINTI
   DF1E 50 72 65 73 73 20   463 		.ascii "Press any key to continue\000"
        61 6E 79 20 6B 65
        79 20 74 6F 20 63
        6F 6E 74 69 6E 75
        65 00
   DF38 CD D8 F0      [18]  464 		CALL	GET_CHAR
   DF3B FE 1B         [ 7]  465 		CPI	27
   DF3D C0            [12]  466 		RNZ
   DF3E E1            [10]  467 		POP	H		;Scrap return address
   DF3F C9            [10]  468 		RET
                            469 
                            470 
                            471 ;-----------------------------------------------------------------------------
                            472 ;DUMP_LINE -- Dumps a line
                            473 ;xxx0:  <pre spaces> XX XX XX XX XX After spaces | ....ASCII....
                            474 ;-----------------------------------------------------------------------------
   DF40 C5            [12]  475 DUMP_LINE:	PUSH	B		;+1
   DF41 E5            [12]  476 		PUSH	H		;+2 Save H for 2nd part of display
   DF42 E5            [12]  477 		PUSH	H		;+3 Start line with xxx0 address
   DF43 7D            [ 4]  478 		MOV	A,L
   DF44 E6 F0         [ 7]  479 		ANI	0xF0		;Mask FFF0
   DF46 6F            [ 4]  480 		MOV	L,A
   DF47 CD 65 F0      [18]  481 		CALL	PUT_HL		;Print Address
   DF4A CD 98 F0      [18]  482 		CALL	PRINTI
   DF4D 3A 20 00            483 		.ascii ": \000"
   DF50 E1            [10]  484 		POP	H		;-3
   DF51 7D            [ 4]  485 		MOV	A,L
   DF52 E6 0F         [ 7]  486 		ANI	0x0F		;Fetch how many prespaces to print
   DF54 4F            [ 4]  487 		MOV	C,A
   DF55 47            [ 7]  488 		MOV	B,A		;Save count of prespaces for part 2 of display
   DF56 CD B0 DF      [18]  489 		CALL	PUT_3C_SPACES
                            490 
   DF59 CD 53 E3      [18]  491 DL_P1L:		CALL	PUT_SPACE
   DF5C 7E            [ 7]  492 		MOV	A,M
   DF5D CD 70 F0      [18]  493 		CALL	PUT_BYTE
   DF60 CD AA DF      [18]  494 		CALL	CMP_HL_DE
   DF63 CA 70 DF      [10]  495 		JZ	DL_P1E
   DF66 23            [ 6]  496 		INX	H
   DF67 7D            [ 4]  497 		MOV	A,L
   DF68 E6 0F         [ 7]  498 		ANI	0x0F
   DF6A C2 59 DF      [10]  499 		JNZ	DL_P1L
   DF6D C3 78 DF      [10]  500 		JMP	DL_P2
                            501 
   DF70 7D            [ 4]  502 DL_P1E:		MOV	A,L
   DF71 2F            [ 4]  503 		CMA
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 11
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   DF72 E6 0F         [ 7]  504 		ANI	0x0F
   DF74 4F            [ 4]  505 		MOV	C,A
   DF75 CD B0 DF      [18]  506 		CALL	PUT_3C_SPACES
                            507 
   DF78 CD 98 F0      [18]  508 DL_P2:		CALL	PRINTI		;Print Seperator between part 1 and part 2
   DF7B 20 7C 20 00         509 		.ascii " | \000"
                            510 
   DF7F 78            [ 4]  511 DL_PSL2:		MOV	A,B		;Print prespaces for part 2
   DF80 B7            [ 4]  512 		ORA	A
   DF81 CA 8B DF      [10]  513 		JZ	DL_PSE2
   DF84 CD 53 E3      [18]  514 		CALL	PUT_SPACE
   DF87 05            [ 4]  515 		DCR	B
   DF88 C3 7F DF      [10]  516 		JMP	DL_PSL2
   DF8B                     517 DL_PSE2:
   DF8B E1            [10]  518 		POP	H		;-2
   DF8C C1            [10]  519 		POP	B		;-1
   DF8D 7E            [ 7]  520 DL_P2L:		MOV	A,M
   DF8E FE 20         [ 7]  521 		CPI	" "		;A - 0x20	Test for Valid ASCII characters
   DF90 F2 95 DF      [10]  522 		JP	DL_P2K1
   DF93 3E 2E         [ 7]  523 		MVI	A,"."				;Replace with . if not ASCII
   DF95 FE 7F         [ 7]  524 DL_P2K1:		CPI	0x7F		;A - 07Fh
   DF97 FA 9C DF      [10]  525 		JM	DL_P2K2
   DF9A 3E 2E         [ 7]  526 		MVI	A,"."
   DF9C CD EB F0      [18]  527 DL_P2K2:		CALL	PUT_CHAR
                            528 
   DF9F CD AA DF      [18]  529 		CALL	CMP_HL_DE
   DFA2 C8            [12]  530 		RZ
   DFA3 23            [ 6]  531 		INX	H
   DFA4 7D            [ 4]  532 		MOV	A,L
   DFA5 E6 0F         [ 7]  533 		ANI	0x0F
   DFA7 C2 8D DF      [10]  534 		JNZ	DL_P2L
                            535 
                            536 ;-----------------------------------------------------------------------------
                            537 ;Compare HL with DE
                            538 ;Exit:		Z=1 if HL=DE
                            539 ;		M=1 if DE > HL
   DFAA 7C            [ 4]  540 CMP_HL_DE:	MOV	A,H
   DFAB BA            [ 4]  541 		CMP	D		;H-D
   DFAC C0            [12]  542 		RNZ			;M flag set if D > H
   DFAD 7D            [ 4]  543 		MOV	A,L
   DFAE BB            [ 4]  544 		CMP	E		;L-E
   DFAF C9            [10]  545 		RET
                            546 
                            547 
   DFB0 79            [ 4]  548 PUT_3C_SPACES:	MOV	A,C		;Print 3C Spaces
   DFB1 B7            [ 4]  549 		ORA	A
   DFB2 C8            [12]  550 		RZ
   DFB3 0D            [ 4]  551 		DCR	C		;Count down Prespaces
   DFB4 CD 98 F0      [18]  552 		CALL	PRINTI		;Print pre spaces
   DFB7 20 20 20 00         553 		.ascii "   \000"
   DFBB C3 B0 DF      [10]  554 		JMP	PUT_3C_SPACES
                            555 
                            556 
                            557 ;-----------------------------------------------------------------------------
                            558 ;EDIT MEMORY
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 12
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                            559 ;Edit memory from a starting address until X is pressed.
                            560 ;Display mem loc, contents, and results of write.
                            561 ;-----------------------------------------------------------------------------
   DFBE CD FF E2      [18]  562 MEM_EDIT:	CALL	SPACE_GET_WORD	;Input Address
   DFC1 EB            [ 4]  563 		XCHG			;HL = Address to edit
   DFC2 CD 48 F0      [18]  564 ME_LP:		CALL	PUT_NEW_LINE
   DFC5 CD 65 F0      [18]  565 		CALL	PUT_HL		;Print current contents of memory
   DFC8 CD 53 E3      [18]  566 		CALL	PUT_SPACE
   DFCB 3E 3A         [ 7]  567 		MVI	A, ":"
   DFCD CD EB F0      [18]  568 		CALL	PUT_CHAR
   DFD0 CD 53 E3      [18]  569 		CALL	PUT_SPACE
   DFD3 7E            [ 7]  570 		MOV	A, M
   DFD4 CD 70 F0      [18]  571 		CALL	PUT_BYTE
   DFD7 CD CE E2      [18]  572 		CALL	SPACE_GET_BYTE	;Input new value or Exit if invalid
   DFDA D8            [12]  573 		RC			;Exit to Command Loop
   DFDB 77            [ 7]  574 		MOV	M, A		;or Save new value
   DFDC CD 53 E3      [18]  575 		CALL	PUT_SPACE
   DFDF 7E            [ 7]  576 		MOV	A, M
   DFE0 CD 70 F0      [18]  577 		CALL	PUT_BYTE
   DFE3 23            [ 6]  578 		INX	H		;Advance to next location
   DFE4 C3 C2 DF      [10]  579 		JMP	ME_LP		;repeat input
                            580 
                            581 
                            582 ;=============================================================================
                            583 ;	MEM_EXEC - Execute at
                            584 ;	Get an address and jump to it
                            585 ;-----------------------------------------------------------------------------
   DFE7 CD FF E2      [18]  586 MEM_EXEC:	CALL	SPACE_GET_WORD	;Input address
   DFEA EB            [ 4]  587 		XCHG			;HL = Address
   DFEB E9            [ 6]  588 		PCHL			;Jump to HL
                            589 
                            590 
                            591 ;===============================================
                            592 ;Input from port, print contents
   DFEC CD CE E2      [18]  593 PORT_INP:	CALL	SPACE_GET_BYTE
   DFEF 47            [ 7]  594 		MOV	B, A
   DFF0 CD 53 E3      [18]  595 		CALL	PUT_SPACE
   DFF3 0E DB         [ 7]  596 		MVI	C, 0xDB
   DFF5 CD 05 E0      [18]  597 		CALL	GOBYTE
   DFF8 CD 70 F0      [18]  598 		CALL	PUT_BYTE
   DFFB C9            [10]  599 		RET
                            600 
                            601 ;Get a port address, write byte out
   DFFC CD CE E2      [18]  602 PORT_OUT:	CALL	SPACE_GET_BYTE
   DFFF 47            [ 7]  603 		MOV	B, A
   E000 CD CE E2      [18]  604 		CALL	SPACE_GET_BYTE
   E003 0E D3         [ 7]  605 		MVI	C, 0xD3
                            606 
                            607 ;===============================================
                            608 ;GOBYTE -- Push a two-byte instruction and RET
                            609 ;         and jump to it
                            610 ;
                            611 ;pre: B register contains operand
                            612 ;pre: C register contains opcode
                            613 ;post: code executed, returns to caller
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 13
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                            614 ;-----------------------------------------------
   E005 21 00 00      [10]  615 GOBYTE:		LXI	H, 0000
   E008 39            [10]  616 		DAD	SP	;HL = STACK
   E009 2B            [ 6]  617 		DCX	H
   E00A 36 C9         [10]  618 		MVI	M, 0xC9	;Stuff RET instruction in STACK RAM
   E00C 2B            [ 6]  619 		DCX	H
   E00D 70            [ 7]  620 		MOV	M, B	;Stuff Port
   E00E 2B            [ 6]  621 		DCX	H
   E00F 71            [ 7]  622 		MOV	M, C	;Stuff Input or Output instruction
   E010 E9            [ 6]  623 		PCHL
                            624 
                            625 
                            626 
                            627 ;=====================================================================================================
                            628 ;Monitor Section for the SD Memory Card.  Not required for BIOS
                            629 ;=====================================================================================================
                            630 
                            631 
   E011 CD 98 F0      [18]  632 SD_MENU:	CALL 	PRINTI		;Display Menu
   E014 0D 0A 2B 20 2D 53   633 		.ascii "\r\n+ -Select"
        65 6C 65 63 74
   E01F 0D 0A 2D 20 2D 44   634 		.ascii "\r\n- -Deselct"
        65 73 65 6C 63 74
   E02B 0D 0A 43 20 2D 43   635 		.ascii "\r\nC -Clock/RX"
        6C 6F 63 6B 2F 52
        58
   E038 0D 0A 58 20 2D 54   636 		.ascii "\r\nX -TX MSG"
        58 20 4D 53 47
   E043 0D 0A 49 20 2D 49   637 		.ascii "\r\nI -Init"
        6E 69 74
   E04C 0D 0A 53 20 2D 53   638 		.ascii "\r\nS -SET SECTOR"
        45 54 20 53 45 43
        54 4F 52
   E05B 0D 0A 52 20 2D 52   639 		.ascii "\r\nR -READ SECTOR"
        45 41 44 20 53 45
        43 54 4F 52
   E06B 0D 0A 57 20 2D 57   640 		.ascii "\r\nW -WRITE SECTOR"
        52 49 54 45 20 53
        45 43 54 4F 52
   E07C 0D 0A 46 20 2D 49   641 		.ascii "\r\nF -INITFAT"
        4E 49 54 46 41 54
   E088 0D 0A 51 20 2D 46   642 		.ascii "\r\nQ -Find File"
        69 6E 64 20 46 69
        6C 65
   E096 0D 0A 44 20 2D 44   643 		.ascii "\r\nD -Directory"
        69 72 65 63 74 6F
        72 79
   E0A4 0D 0A 4B 20 2D 52   644 		.ascii "\r\nK -READ LOG-D/F SECTOR"
        45 41 44 20 4C 4F
        47 2D 44 2F 46 20
        53 45 43 54 4F 52
   E0BC 0D 0A 42 20 20 2D   645 		.ascii "\r\nB  -Select FCB#"
        53 65 6C 65 63 74
        20 46 43 42 23
   E0CD 0D 0A 31 2D 34 20   646 		.ascii "\r\n1-4 -Open File #"
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 14
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



        2D 4F 70 65 6E 20
        46 69 6C 65 20 23
   E0DF 00                  647 		.ascii "\000"
   E0E0 CD 98 F0      [18]  648 SD_MENUCMD:	CALL 	PRINTI		;Display Menu Prompt
   E0E3 0D 0A 53 44 3E 00   649 		.ascii "\r\nSD>\000"
   E0E9 3E FF         [ 7]  650 		MVI	A,0xFF
   E0EB 32 81 FD      [13]  651 		STA	ECHO_ON		;TURN ON ECHO
   E0EE CD D8 F0      [18]  652 		CALL 	GET_CHAR	;get char
   E0F1 FE 1B         [ 7]  653 		CPI	27		;<Esc>?
   E0F3 CA E5 DD      [10]  654 		JZ	MAIN_MENU
   E0F6 CD 7E F8      [18]  655 		CALL	TO_UPPER	;to upper case
   E0F9 FE 49         [ 7]  656 		CPI 	"I"		;Branch to Command entered
   E0FB CA AA E2      [10]  657 		JZ 	DO_INIT_SDCARD	; I = Init SD CARD
   E0FE FE 2B         [ 7]  658 		CPI 	"+"		;
   E100 CA B0 E2      [10]  659 		JZ 	DO_SD_SELECT	; + = Select SD CARD
   E103 FE 2D         [ 7]  660 		CPI 	"-"		;
   E105 CA B6 E2      [10]  661 		JZ 	DO_SD_DESELECT	; - = Deselect SD CARD
   E108 FE 43         [ 7]  662 		CPI 	"C"		;
   E10A CA BC E2      [10]  663 		JZ 	DO_SD_CLK	; C = Clock SD CARD
   E10D FE 58         [ 7]  664 		CPI 	"X"		;
   E10F CA 86 E2      [10]  665 		JZ 	DO_SD_TXM	; T = TX MSG SD CARD
   E112 FE 53         [ 7]  666 		CPI 	"S"		;
   E114 CA DB E1      [10]  667 		JZ 	DO_SD_PARAM	; S = SET SECTOR
   E117 FE 52         [ 7]  668 		CPI 	"R"		;
   E119 CA 2D E2      [10]  669 		JZ 	DO_SD_READSEC	; R = READ SECTOR
   E11C FE 57         [ 7]  670 		CPI 	"W"		;
   E11E CA 1B E2      [10]  671 		JZ 	DO_SD_WRITESEC	; W = WRITE SECTOR
   E121 FE 46         [ 7]  672 		CPI 	"F"		;
   E123 CA 97 E1      [10]  673 		JZ 	DO_SD_IFAT	; F = INIT FAT
   E126 FE 51         [ 7]  674 		CPI 	"Q"		;
   E128 CA 8B E1      [10]  675 		JZ 	DO_SD_FINDFILE	; Q = FIND FILE
   E12B FE 44         [ 7]  676 		CPI 	"D"		;
   E12D CA 76 E1      [10]  677 		JZ 	DO_DIR		; D = DIRECTORY
   E130 FE 4B         [ 7]  678 		CPI 	"K"		;
   E132 CA 52 E2      [10]  679 		JZ 	DO_DK_READSEC	; K = READ LOGICAL DISK SECTOR
   E135 FE 42         [ 7]  680 		CPI 	"B"		;
   E137 CA 9D E1      [10]  681 		JZ 	DO_SEL_FCB	; B = SELECT FCB#
   E13A 21 00 FD      [10]  682 		LXI	H,SDISKA
   E13D FE 31         [ 7]  683 		CPI 	"1"		;
   E13F CA 5D E1      [10]  684 		JZ 	DO_OPEN		; 1 = OPEN 1
   E142 21 20 FD      [10]  685 		LXI	H,SDISKB
   E145 FE 32         [ 7]  686 		CPI 	"2"		;
   E147 CA 5D E1      [10]  687 		JZ 	DO_OPEN		; 2 = OPEN 2
   E14A 21 40 FD      [10]  688 		LXI	H,SDISKC
   E14D FE 33         [ 7]  689 		CPI 	"3"		;
   E14F CA 5D E1      [10]  690 		JZ 	DO_OPEN		; 3 = OPEN 3
   E152 21 60 FD      [10]  691 		LXI	H,SDISKD
   E155 FE 34         [ 7]  692 		CPI 	"4"		;
   E157 CA 5D E1      [10]  693 		JZ 	DO_OPEN		; 4 = OPEN 4
   E15A C3 11 E0      [10]  694 		JMP 	SD_MENU
                            695 
                            696 
                            697 ;-------------------------------------------------
   E15D 22 83 FD      [16]  698 DO_OPEN:		SHLD	FCB_PTR
   E160 CD F2 F7      [18]  699 		CALL	INPUT_FNAME
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 15
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E163 2A 83 FD      [16]  700 		LHLD	FCB_PTR
   E166 23            [ 6]  701 		INX	H		;FNAME
   E167 EB            [ 4]  702 		XCHG
   E168 21 C8 FD      [10]  703 		LXI	H,FILENAME
   E16B 06 0B         [ 7]  704 		MVI	B,11
   E16D CD E2 F8      [18]  705 		CALL	COPY_RAM
   E170 CD 51 F3      [18]  706 		CALL	SD_OPEN
   E173 C3 E0 E0      [10]  707 		JMP	SD_MENUCMD
                            708 
                            709 ;-------------------------------------------------
   E176 CD 48 F0      [18]  710 DO_DIR:		CALL	PUT_NEW_LINE
   E179 CD 58 F1      [18]  711 		CALL	SD_LDIR1
   E17C CA E0 E0      [10]  712 SDLF_LP: 	JZ	SD_MENUCMD		;End of list
   E17F CD 2B F8      [18]  713 		CALL	PRINT_FILENAME
   E182 CD 48 F0      [18]  714 		CALL	PUT_NEW_LINE
   E185 CD 6E F1      [18]  715 		CALL	SD_LDIRN
   E188 C3 7C E1      [10]  716 		JMP	SDLF_LP
                            717 
                            718 ;-------------------------------------------------
   E18B CD F2 F7      [18]  719 DO_SD_FINDFILE:	CALL	INPUT_FNAME
   E18E DA 11 E0      [10]  720 		JC	SD_MENU		;ABORT ON <ESC>
   E191 CD 96 F1      [18]  721 		CALL	SDV_FIND_FILE1
   E194 C3 E0 E0      [10]  722 		JMP	SD_MENUCMD
                            723 
                            724 ;-------------------------------------------------
   E197 CD A3 F3      [18]  725 DO_SD_IFAT:	CALL	INIT_FAT
   E19A C3 11 E0      [10]  726 		JMP 	SD_MENU
                            727 
                            728 ;-------------------------------------------------
   E19D CD 98 F0      [18]  729 DO_SEL_FCB:	CALL 	PRINTI		;
   E1A0 0D 0A 46 43 42 23   730 		.ascii "\r\nFCB#\000"
        00
   E1A7 CD D8 F0      [18]  731 		CALL	GET_CHAR
   E1AA FE 31         [ 7]  732 		CPI 	"1"		;
   E1AC DA E0 E0      [10]  733 		JC	SD_MENUCMD
   E1AF FE 35         [ 7]  734 		CPI 	"5"		;
   E1B1 D2 E0 E0      [10]  735 		JNC	SD_MENUCMD
   E1B4 3D            [ 4]  736 		DCR	A
   E1B5 CD 38 F1      [18]  737 		CALL	SET_FCB_PTR
   E1B8 E5            [12]  738 		PUSH	H
   E1B9 CD 98 F0      [18]  739 		CALL 	PRINTI		;
   E1BC 20 46 43 42 5F 50   740 		.ascii " FCB_PTR:\000"
        54 52 3A 00
   E1C6 2A 83 FD      [16]  741 		LHLD	FCB_PTR
   E1C9 CD 65 F0      [18]  742 		CALL	PUT_HL
   E1CC E1            [10]  743 		POP	H
   E1CD CD 98 F0      [18]  744 		CALL 	PRINTI		;
   E1D0 20 48 4C 3A 00      745 		.ascii " HL:\000"
   E1D5 CD 65 F0      [18]  746 		CALL	PUT_HL
   E1D8 C3 E0 E0      [10]  747 		JMP	SD_MENUCMD
                            748 
                            749 ;-------------------------------------------------
   E1DB CD 98 F0      [18]  750 DO_SD_PARAM:	CALL 	PRINTI		;
   E1DE 0D 0A 3C 00         751 		.ascii "\r\n<\000"
   E1E2 21 D3 FD      [10]  752 		LXI	H,SEC_PTR
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 16
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E1E5 CD 87 F8      [18]  753 		CALL	MOV_32_HL
   E1E8 CD 4F F0      [18]  754 		CALL	PUT_BC
   E1EB CD 5A F0      [18]  755 		CALL	PUT_DE
   E1EE CD 98 F0      [18]  756 		CALL 	PRINTI		;
   E1F1 3E 20 45 6E 74 65   757 		.ascii "> Enter 4 BYTE SECTOR#> \000"
        72 20 34 20 42 59
        54 45 20 53 45 43
        54 4F 52 23 3E 20
        00
   E20A 06 04         [ 7]  758 		MVI	B,4
   E20C CD D1 E2      [18]  759 GDW_LP:		CALL	GET_BYTE
   E20F 77            [ 7]  760 		MOV	M,A
   E210 05            [ 4]  761 		DCR	B
   E211 CA 11 E0      [10]  762 		JZ	SD_MENU
   E214 2B            [ 6]  763 		DCX	H
   E215 CD 53 E3      [18]  764 		CALL	PUT_SPACE
   E218 C3 0C E2      [10]  765 		JMP	GDW_LP
                            766 
                            767 ;-------------------------------------------------
   E21B CD DB F5      [18]  768 DO_SD_WRITESEC:	CALL	SD_WRITE_SEC
   E21E C2 44 E2      [10]  769 		JNZ	DSDR_FAIL
   E221 CD 98 F0      [18]  770 		CALL 	PRINTI		;
   E224 0D 0A 2D 4F 4B 00   771 		.ascii "\r\n-OK\000"
   E22A C3 11 E0      [10]  772 		JMP	SD_MENU
                            773 
                            774 ;-------------------------------------------------
   E22D 21 D3 FD      [10]  775 DO_SD_READSEC:	LXI	H,SEC_PTR
   E230 CD 87 F8      [18]  776 		CALL	MOV_32_HL	;Fetch SEC_PTR to 32bit BCDE
   E233 37            [ 4]  777 		STC			;Set Carry to force Read
   E234 CD 71 F5      [18]  778 		CALL	SD_READ_SEC
   E237 C2 44 E2      [10]  779 		JNZ	DSDR_FAIL
   E23A EB            [ 4]  780 		XCHG			;Set end of buffer
   E23B 21 00 FE      [10]  781 		LXI	H,SD_RAM_BUFFER	;Set buffer space
   E23E CD 06 DF      [18]  782 		CALL	MEM_DUMP_LP
   E241 C3 E0 E0      [10]  783 		JMP	SD_MENUCMD
   E244 CD 98 F0      [18]  784 DSDR_FAIL:	CALL 	PRINTI		;
   E247 2D 46 41 49 4C 45   785 		.ascii "-FAILED\000"
        44 00
   E24F C3 11 E0      [10]  786 		JMP	SD_MENU
                            787 
                            788 ;-------------------------------------------------
   E252 CD 98 F0      [18]  789 DO_DK_READSEC:	CALL 	PRINTI		;
   E255 0D 0A 45 6E 74 65   790 		.ascii "\r\nEnter Log-Sector> \000"
        72 20 4C 6F 67 2D
        53 65 63 74 6F 72
        3E 20 00
   E26A CD FF E2      [18]  791 		CALL	SPACE_GET_WORD
   E26D FE 1B         [ 7]  792 		CPI	27
   E26F CA E0 E0      [10]  793 		JZ	SD_MENUCMD	;On Abort...EXIT
   E272 EB            [ 4]  794 		XCHG
   E273 22 99 FD      [16]  795 		SHLD	LOGICAL_SEC
   E276 CD C7 F1      [18]  796 		CALL	DISK_READ	;HL = Quarter Buffer
   E279 E5            [12]  797 		PUSH	H
   E27A D1            [10]  798 		POP	D		;DE = Quarter Buffer
   E27B 01 80 00      [10]  799 		LXI	B,128
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 17
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E27E 09            [10]  800 		DAD	B		;HL = Quarter Buffer +128
   E27F EB            [ 4]  801 		XCHG			;HL=START, DE=STOP of Dump
   E280 CD 06 DF      [18]  802 		CALL	MEM_DUMP_LP
   E283 C3 E0 E0      [10]  803 		JMP	SD_MENUCMD
                            804 
                            805 ;-------------------------------------------------
   E286 CD 98 F0      [18]  806 DO_SD_TXM:	CALL 	PRINTI		;
   E289 0D 0A 45 6E 74 65   807 		.ascii "\r\nEnter HEX> \000"
        72 20 48 45 58 3E
        20 00
   E297 CD D1 E2      [18]  808 DST_LP:		CALL	GET_BYTE
   E29A DA 11 E0      [10]  809 		JC	SD_MENU
   E29D D3 30         [10]  810 		OUT	SPI
   E29F 3E 2E         [ 7]  811 		MVI	A,"."
   E2A1 CD EB F0      [18]  812 		CALL	PUT_CHAR
   E2A4 CD 53 E3      [18]  813 		CALL	PUT_SPACE
   E2A7 C3 97 E2      [10]  814 		JMP	DST_LP
                            815 
                            816 ;-------------------------------------------------
   E2AA CD 6F F6      [18]  817 DO_INIT_SDCARD:	CALL	INIT_SDCARD
   E2AD C3 E0 E0      [10]  818 		JMP	SD_MENUCMD
                            819 
                            820 ;-------------------------------------------------
   E2B0 CD 63 F7      [18]  821 DO_SD_SELECT:	CALL	SD_SELECT
   E2B3 C3 E0 E0      [10]  822 		JMP	SD_MENUCMD
                            823 
                            824 ;-------------------------------------------------
   E2B6 CD 5C F7      [18]  825 DO_SD_DESELECT:	CALL	SD_DESELECT
   E2B9 C3 E0 E0      [10]  826 		JMP	SD_MENUCMD
                            827 
                            828 ;-------------------------------------------------
   E2BC 06 08         [ 7]  829 DO_SD_CLK:	MVI	B,0x08
   E2BE CD 53 E3      [18]  830 DSC_0:		CALL	PUT_SPACE
   E2C1 CD BA F7      [18]  831 		CALL	SPI_RX
   E2C4 CD 70 F0      [18]  832 		CALL	PUT_BYTE
   E2C7 05            [ 4]  833 		DCR	B
   E2C8 C2 BE E2      [10]  834 		JNZ	DSC_0
   E2CB C3 E0 E0      [10]  835 		JMP	SD_MENUCMD
                            836 
                            837 
                            838 ;=============================================================================
   E2CE CD 53 E3      [18]  839 SPACE_GET_BYTE:	CALL	PUT_SPACE
                            840 
                            841 ;=============================================================================
                            842 ;GET_BYTE -- Get byte from console as hex
                            843 ;
                            844 ;in:	Nothing
                            845 ;out:	A = Byte (if CY=0)
                            846 ;	A = non-hex char input (if CY=1)
                            847 ;-----------------------------------------------------------------------------
   E2D1 CD 21 E3      [18]  848 GET_BYTE:	CALL	GET_HEX_CHAR	;Get 1st HEX CHAR
   E2D4 D2 DE E2      [10]  849 		JNC	GB_1
   E2D7 FE 20         [ 7]  850 		CPI	" "		;Exit if not HEX CHAR (ignoring SPACE)
   E2D9 CA D1 E2      [10]  851 		JZ	GET_BYTE	;Loop back if first char is a SPACE
   E2DC 37            [ 4]  852 		STC			;Set Carry
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 18
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E2DD C9            [10]  853 		RET			;or EXIT with delimiting char
   E2DE D5            [12]  854 GB_1:		PUSH	D		;Process 1st HEX CHAR
   E2DF 07            [ 4]  855 		RLC
   E2E0 07            [ 4]  856 		RLC
   E2E1 07            [ 4]  857 		RLC
   E2E2 07            [ 4]  858 		RLC
   E2E3 E6 F0         [ 7]  859 		ANI	0xF0
   E2E5 57            [ 7]  860 		MOV	D,A
   E2E6 CD 21 E3      [18]  861 		CALL	GET_HEX_CHAR
   E2E9 D2 F4 E2      [10]  862 		JNC	GB_2		;If 2nd char is HEX CHAR
   E2EC FE 20         [ 7]  863 		CPI	" "
   E2EE CA F7 E2      [10]  864 		JZ	GB_UNDO		;If 2nd char is SPACE, Move 1st back to lower nibble
   E2F1 37            [ 4]  865 		STC			;Set Carry
   E2F2 D1            [10]  866 		POP	D
   E2F3 C9            [10]  867 		RET			;or EXIT with delimiting char
   E2F4 B2            [ 4]  868 GB_2:		ORA	D
   E2F5 D1            [10]  869 		POP	D
   E2F6 C9            [10]  870 		RET
   E2F7 7A            [ 4]  871 GB_UNDO:		MOV	A,D		;Move 1st back to lower nibble
   E2F8 0F            [ 4]  872 		RRC
   E2F9 0F            [ 4]  873 		RRC
   E2FA 0F            [ 4]  874 		RRC
   E2FB 0F            [ 4]  875 		RRC
   E2FC B7            [ 4]  876 GB_RET:		ORA	A
   E2FD D1            [10]  877 		POP	D
   E2FE C9            [10]  878 		RET
                            879 
                            880 
                            881 ;=============================================================================
   E2FF CD 53 E3      [18]  882 SPACE_GET_WORD:	CALL	PUT_SPACE
                            883 
                            884 ;=============================================================================
                            885 ;GET_WORD -- Get word from console as hex
                            886 ;
                            887 ;in:	Nothing
                            888 ;out:	A = non-hex char input
                            889 ;	DE = Word
                            890 ;-----------------------------------------------------------------------------
   E302 11 00 00      [10]  891 GET_WORD:	LXI	D,0
   E305 CD 21 E3      [18]  892 		CALL	GET_HEX_CHAR	;Get 1st HEX CHAR
   E308 D2 12 E3      [10]  893 		JNC	GW_LP
   E30B FE 20         [ 7]  894 		CPI	" "		;Exit if not HEX CHAR (ignoring SPACE)
   E30D CA 02 E3      [10]  895 		JZ	GET_WORD	;Loop back if first char is a SPACE
   E310 B7            [ 4]  896 		ORA	A		;Clear Carry
   E311 C9            [10]  897 		RET			;or EXIT with delimiting char
   E312 5F            [ 4]  898 GW_LP:		MOV	E,A
   E313 CD 21 E3      [18]  899 		CALL	GET_HEX_CHAR
   E316 D8            [12]  900 		RC			;EXIT when a delimiting char is entered
   E317 EB            [ 4]  901 		XCHG			;Else, shift new HEX Char Value into DE
   E318 29            [10]  902 		DAD	H
   E319 29            [10]  903 		DAD	H
   E31A 29            [10]  904 		DAD	H
   E31B 29            [10]  905 		DAD	H
   E31C EB            [ 4]  906 		XCHG
   E31D B3            [ 4]  907 		ORA	E
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 19
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E31E C3 12 E3      [10]  908 		JMP	GW_LP
                            909 
                            910 
                            911 
                            912 ;===============================================
                            913 ;Get HEX CHAR
                            914 ;in:	Nothing
                            915 ;out:	A = Value of HEX Char when CY=0
                            916 ;	A = Received (non-hex) char when CY=1
                            917 ;-----------------------------------------------
   E321 CD D8 F0      [18]  918 GET_HEX_CHAR:	CALL	GET_CHAR
   E324 FE 30         [ 7]  919 ASC2HEX:		CPI	"0"
   E326 FA 42 E3      [10]  920 		JM	GHC_NOT_RET
   E329 FE 3A         [ 7]  921 		CPI	"9"+1
   E32B FA 46 E3      [10]  922 		JM	GHC_NRET
   E32E FE 41         [ 7]  923 		CPI	"A"
   E330 FA 42 E3      [10]  924 		JM	GHC_NOT_RET
   E333 FE 47         [ 7]  925 		CPI	"F"+1
   E335 FA 44 E3      [10]  926 		JM	GHC_ARET
   E338 FE 61         [ 7]  927 		CPI	"a"
   E33A FA 42 E3      [10]  928 		JM	GHC_NOT_RET
   E33D FE 67         [ 7]  929 		CPI	"f"+1
   E33F FA 44 E3      [10]  930 		JM	GHC_ARET
   E342 37            [ 4]  931 GHC_NOT_RET:	STC
   E343 C9            [10]  932 		RET
   E344 D6 07         [ 7]  933 GHC_ARET:	SUI	0x07
   E346 E6 0F         [ 7]  934 GHC_NRET:	ANI	0x0F
   E348 C9            [10]  935 		RET
                            936 
                            937 
                            938 
                            939 
                            940 ;===============================================
                            941 ;ASCHEX -- Convert ASCII coded hex to nibble
                            942 ;
                            943 ;pre:	A register contains ASCII coded nibble
                            944 ;post:	A register contains nibble
                            945 ;-----------------------------------------------
   E349 D6 30         [ 7]  946 ASCHEX:		SUI	0x30
   E34B FE 0A         [ 7]  947 		CPI	0x0A
   E34D F8            [12]  948 		RM
   E34E E6 5F         [ 7]  949 		ANI	0x5F
   E350 D6 07         [ 7]  950 		SUI	0x07
   E352 C9            [10]  951 		RET
                            952 
                            953 
                            954 
                            955 
                            956 
                            957 
                            958 ;===============================================
                            959 ;PUT_SPACE -- Print a space to the console
                            960 ;
                            961 ;pre: none
                            962 ;post: 0x20 printed to console
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 20
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                            963 ;-----------------------------------------------
   E353 3E 20         [ 7]  964 PUT_SPACE:	MVI	A, " "
   E355 C3 EB F0      [10]  965 		JMP	PUT_CHAR
                            966 
                            967 
                            968 
                            969 
                            970 
                            971 ;----------------------------------------------------------------------------------------------------; ASCII HEXFILE TRANSFER
                            972 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            973 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            974 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            975 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            976 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            977 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            978 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            979 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            980 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            981 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            982 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            983 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            984 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            985 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            986 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            987 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            988 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                            989 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                            990 ;----------------------------------------------------------------------------------------------------; ASCII HEXFILE TRANSFER
   E358 3E 00         [ 7]  991 GETHEXFILE:	MVI	A,0
   E35A 5F            [ 4]  992 		MOV	E,A		;ZERO ERROR COUNTER
   E35B 32 81 FD      [13]  993 		STA	ECHO_ON		;TURN OFF ECHO
   E35E C3 69 E3      [10]  994 		JMP	GHDOLINE
                            995 
   E361 CD D8 F0      [18]  996 GHWAIT:		CALL	GET_CHAR
   E364 FE 3A         [ 7]  997 		CPI	":"
   E366 C2 61 E3      [10]  998 		JNZ	GHWAIT
                            999 
   E369 CD D1 E2      [18] 1000 GHDOLINE:	CALL	GET_BYTE	;GET BYTE COUNT
   E36C 4F            [ 4] 1001 		MOV	C,A		;BYTE COUNTER
   E36D 57            [ 7] 1002 		MOV	D,A		;CHECKSUM
                           1003 
   E36E CD D1 E2      [18] 1004 		CALL	GET_BYTE	;GET HIGH ADDRESS
   E371 67            [ 7] 1005 		MOV	H,A
   E372 82            [ 4] 1006 		ADD	D
   E373 57            [ 7] 1007 		MOV	D,A
                           1008 
   E374 CD D1 E2      [18] 1009 		CALL	GET_BYTE	;GET LOW ADDRESS
   E377 6F            [ 4] 1010 		MOV	L,A
   E378 82            [ 4] 1011 		ADD	D
   E379 57            [ 7] 1012 		MOV	D,A
                           1013 
   E37A CD D1 E2      [18] 1014 		CALL	GET_BYTE	;GET RECORD TYPE
   E37D FE 01         [ 7] 1015 		CPI	1
   E37F CA 9E E3      [10] 1016 		JZ	GHEND	;IF RECORD TYPE IS 01 THEN END
   E382 82            [ 4] 1017 		ADD	D
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 21
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E383 57            [ 7] 1018 		MOV	D,A
                           1019 
   E384 CD D1 E2      [18] 1020 GHLOOP:		CALL	GET_BYTE	;GET DATA
   E387 77            [ 7] 1021 		MOV	M,A
   E388 82            [ 4] 1022 		ADD	D
   E389 57            [ 7] 1023 		MOV	D,A
   E38A 23            [ 6] 1024 		INX	H
                           1025 
   E38B 0D            [ 4] 1026 		DCR	C
   E38C C2 84 E3      [10] 1027 		JNZ	GHLOOP
                           1028 
   E38F CD D1 E2      [18] 1029 		CALL	GET_BYTE	;GET CHECKSUM
   E392 82            [ 4] 1030 		ADD	D
   E393 CA 61 E3      [10] 1031 		JZ	GHWAIT
   E396 1C            [ 4] 1032 		INR	E
   E397 C2 61 E3      [10] 1033 		JNZ	GHWAIT
   E39A 1D            [ 4] 1034 		DCR	E
   E39B C3 61 E3      [10] 1035 		JMP	GHWAIT
                           1036 
   E39E CD 98 F0      [18] 1037 GHEND:		CALL	PRINTI
   E3A1 0D 0A 48 45 58 20  1038 		.ascii "\r\nHEX TRANSFER COMPLETE ERRORS=\000"
        54 52 41 4E 53 46
        45 52 20 43 4F 4D
        50 4C 45 54 45 20
        45 52 52 4F 52 53
        3D 00
   E3C1 7B            [ 4] 1039 		MOV	A,E
   E3C2 CD 70 F0      [18] 1040 		CALL	PUT_BYTE
   E3C5 C3 21 E6      [10] 1041 		JMP	PURGE
                           1042 
                           1043 
                           1044 ;----------------------------------------------------------------------------------------------------; XMODEM ROUTINES
                           1045 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1046 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1047 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1048 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1049 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1050 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1051 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1052 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1053 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1054 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1055 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1056 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1057 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1058 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1059 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1060 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1061 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1062 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1063 ;----------------------------------------------------------------------------------------------------; XMODEM ROUTINES
                           1064 
                     0001  1065 SOH	.equ	1	;Start of Header
                     0004  1066 EOT	.equ	4	;End of Transmission
                     0006  1067 ACK	.equ	6
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 22
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                     0010  1068 DLE	.equ	16
                     0011  1069 DC1	.equ	17	; (X-ON)
                     0013  1070 DC3	.equ	19	; (X-OFF)
                     0015  1071 NAK	.equ	21
                     0016  1072 SYN	.equ	22
                     0018  1073 CAN	.equ	24	;(Cancel)
                           1074 
                           1075 ;---------------------------------------------------------------------------------
                           1076 ;XMODEM MENU
                           1077 ;ENTRY:	TOP OF STACK HOLDS RETURN ADDRESS (EXIT MECHANISM IF XMODEM IS CANCELLED)
                           1078 ;---------------------------------------------------------------------------------
   E3C8 CD 53 E3      [18] 1079 XMODEM:		CALL	PUT_SPACE
   E3CB CD D8 F0      [18] 1080 		CALL	GET_CHAR	;get char
   E3CE E6 5F         [ 7] 1081 		ANI	0x5F		;to upper case
   E3D0 FE 44         [ 7] 1082 		CPI	"D"
   E3D2 CA E0 E3      [10] 1083 		JZ	XMDN		; D = DOWNLOAD
   E3D5 FE 55         [ 7] 1084 		CPI	"U"
   E3D7 CA FC E3      [10] 1085 		JZ	XMUP		; U = UPLOAD
   E3DA CD 98 F0      [18] 1086 		CALL 	PRINTI
   E3DD 3F 00              1087 		.ascii "?\000"
   E3DF C9            [10] 1088 		RET
                           1089 
                           1090 ;---------------------------------------------------------------------------------
                           1091 ;XMDN - XMODEM DOWNLOAD (send file from IMSAI to Terminal)
                           1092 ;INPUT STARTING ADDRESS AND COUNT OF BLOCKS (WORD)
                           1093 ;WAIT FOR 'C' OR NAK FROM HOST TO START CRC/CS TRANSFER
                           1094 ;---------------------------------------------------------------------------------
   E3E0 CD FF E2      [18] 1095 XMDN:		CALL	SPACE_GET_WORD	;Input Address
   E3E3 EB            [ 4] 1096 		XCHG			;HL = Address to SAVE DATA
   E3E4 CD FF E2      [18] 1097 		CALL	SPACE_GET_WORD	;Input #Blocks to Send
                           1098 					;DE = Count of Blocks
                           1099 
   E3E7 7A            [ 4] 1100 		MOV	A,D
   E3E8 B3            [ 4] 1101 		ORA	E
   E3E9 C8            [12] 1102 		RZ			;Exit if Block Count = 0
                           1103 
                           1104 	;HL = Address of data to send from the IMSAI 8080
                           1105 	;DE = Count of Blocks to send.
                           1106 
   E3EA CD 0C E4      [18] 1107 		CALL	XMS_INIT	;Starts the Seq, Sets the CS/CRC format
                           1108 					;Cancelled Transfers will cause a RET
                           1109 
   E3ED CD 34 E4      [18] 1110 XMDN_LP:		CALL	XMS_SEND	;Sends the packet @HL, Resends if NAK
                           1111 					;Cancelled Transfers will cause a RET
   E3F0 1B            [ 6] 1112 		DCX	D
   E3F1 7A            [ 4] 1113 		MOV	A,D
   E3F2 B3            [ 4] 1114 		ORA	E
   E3F3 C2 ED E3      [10] 1115 		JNZ	XMDN_LP
                           1116 
   E3F6 CD 8B E4      [18] 1117 		CALL	XMS_EOT		;Send End of Transmission
   E3F9 C3 21 E6      [10] 1118 		JMP	PURGE
                           1119 
                           1120 
                           1121 ;---------------------------------------------------------------------------------
                           1122 ;XMUP - XMODEM UPLOAD (receive file from Terminal to IMSAI 8080)
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 23
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           1123 ;INPUT STARTING ADDRESS
                           1124 ;SEND 'C' OR NAK TO HOST TO START CRC/CS TRANSFER
                           1125 ;---------------------------------------------------------------------------------
   E3FC CD FF E2      [18] 1126 XMUP:		CALL	SPACE_GET_WORD	;Input Address
   E3FF EB            [ 4] 1127 		XCHG			;HL = Address to SAVE DATA
                           1128 
                           1129 	;HL = Address of where data is to be received
                           1130 
   E400 CD E1 E4      [18] 1131 		CALL	XMR_INIT	;Starts the transfer & Receives first PACKET
                           1132 					;Cancelled Transfers will cause a RET
                           1133 
   E403 CD 1D E5      [18] 1134 XMUP_LP:		CALL	XMR_RECV	;Receives the next packet @HL, Resends if NAK
                           1135 					;Cancelled Transfers will cause a RET
   E406 DA 03 E4      [10] 1136 		JC	XMUP_LP		;Jump until EOT Received
   E409 C3 21 E6      [10] 1137 		JMP	PURGE
                           1138 
                           1139 
                           1140 
                           1141 ;---------------------------------------------------------------------------------
                           1142 ;INIT FOR SENDING XMODEM PROTOCOL, GET NAK OR 'C', SAVE THE XMTYPE
                           1143 ;---------------------------------------------------------------------------------
   E40C 3E 01         [ 7] 1144 XMS_INIT:	MVI	A,1		;First SEQ number
   E40E 32 87 FD      [13] 1145 		STA	XMSEQ
                           1146 
   E411 06 0A         [ 7] 1147 		MVI	B,10		;10 retries for initiating the transfer
   E413 3E 2D         [ 7] 1148 XMS_INIT_LP:	MVI	A,45		;GET CHAR, 45 SECONDS TIMEOUT (EXPECT C OR NAK)
   E415 CD 00 E6      [18] 1149 		CALL	TIMED_GETCHAR
   E418 DA BD E4      [10] 1150 		JC	XM_CANCEL	;Cancel if Host Timed out
                           1151 
   E41B FE 15         [ 7] 1152 		CPI	NAK		;If NAK, Start Checksum Download
   E41D CA 2C E4      [10] 1153 		JZ	XMS_DO
   E420 FE 43         [ 7] 1154 		CPI	"C"		;If C, Start CRC Download
   E422 CA 2C E4      [10] 1155 		JZ	XMS_DO
   E425 05            [ 4] 1156 		DCR	B		;Count down Retries
   E426 C2 13 E4      [10] 1157 		JNZ	XMS_INIT_LP
   E429 C3 BD E4      [10] 1158 		JMP	XM_CANCEL	;Cancel XModem if all retries exhausted
                           1159 
   E42C 32 88 FD      [13] 1160 XMS_DO:		STA	XMTYPE
   E42F C9            [10] 1161 		RET
                           1162 
                           1163 ;---------------------------------------------------------------------------------
                           1164 ;SEND A PACKET (RESEND UPON NAK)
                           1165 ;---------------------------------------------------------------------------------
   E430 01 80 FF      [10] 1166 XMS_RESEND:	LXI	B,0xFF80
   E433 09            [10] 1167 		DAD	B
   E434 D5            [12] 1168 XMS_SEND:	PUSH	D
   E435 3E 01         [ 7] 1169 		MVI	A,SOH		;SEND THE HEADER FOR CRC OR CHECKSUM
   E437 CD EB F0      [18] 1170 		CALL	PUT_CHAR
   E43A 3A 87 FD      [13] 1171 		LDA	XMSEQ
   E43D CD EB F0      [18] 1172 		CALL	PUT_CHAR
   E440 2F            [ 4] 1173 		CMA
   E441 CD EB F0      [18] 1174 		CALL	PUT_CHAR
   E444 11 00 00      [10] 1175 		LXI	D,0x0000		;Init DE=0000 (CRC Accumulator)
   E447 0E 00         [ 7] 1176 		MVI	C,0		;Init C=00 (CS Accumulator)
   E449 06 80         [ 7] 1177 		MVI	B,128		;Count 128 bytes per block
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 24
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E44B 7E            [ 7] 1178 XMS_BLP:		MOV	A,M		;Fetch bytes to send  -------------------\
   E44C CD EB F0      [18] 1179 		CALL	PUT_CHAR	;Send them
   E44F 81            [ 4] 1180 		ADD	C		;Update the CS
   E450 4F            [ 4] 1181 		MOV	C,A
   E451 7E            [ 7] 1182 		MOV	A,M
   E452 CD D0 E5      [18] 1183 		CALL	CRC_UPDATE	;Update the CRC
   E455 23            [ 6] 1184 		INX	H		;Advance to next byte in block
   E456 05            [ 4] 1185 		DCR	B		;Count down bytes sent
   E457 C2 4B E4      [10] 1186 		JNZ	XMS_BLP		;Loop back until 128 bytes are sent -----^
   E45A 3A 88 FD      [13] 1187 		LDA	XMTYPE
   E45D FE 15         [ 7] 1188 		CPI	NAK		;If NAK, send Checksum
   E45F CA 67 E4      [10] 1189 		JZ	XMS_CS		;----------------------v
   E462 7A            [ 4] 1190 		MOV	A,D		;else, Send the CRC next
   E463 CD EB F0      [18] 1191 		CALL	PUT_CHAR
   E466 4B            [ 4] 1192 		MOV	C,E
   E467 79            [ 4] 1193 XMS_CS:		MOV	A,C		;----------------------/
   E468 CD EB F0      [18] 1194 		CALL	PUT_CHAR
                           1195 					;Packet Sent, get Ack/Nak Response
   E46B 3E 2D         [ 7] 1196 		MVI	A,45		;GET CHAR, 45 SECONDS TIMEOUT (EXPECT C OR NAK)
   E46D CD 00 E6      [18] 1197 		CALL	TIMED_GETCHAR
   E470 D1            [10] 1198 		POP	D
                           1199 
   E471 DA BD E4      [10] 1200 		JC	XM_CANCEL	;Cancel download if no response within 45 seconds
   E474 FE 15         [ 7] 1201 		CPI	NAK
   E476 CA 30 E4      [10] 1202 		JZ	XMS_RESEND	;Loop back to resend packet
   E479 FE 18         [ 7] 1203 		CPI	CAN
   E47B CA BD E4      [10] 1204 		JZ	XM_CANCEL
   E47E FE 06         [ 7] 1205 		CPI	ACK
   E480 C2 BD E4      [10] 1206 		JNZ	XM_CANCEL
                           1207 
   E483 3A 87 FD      [13] 1208 		LDA	XMSEQ
   E486 3C            [ 4] 1209 		INR	A		;NEXT SEQ
   E487 32 87 FD      [13] 1210 		STA	XMSEQ
   E48A C9            [10] 1211 		RET
                           1212 
                           1213 
                           1214 ;---------------------------------------------------------------------------------
                           1215 ;XMDN - DOWNLOAD XMODEM PACKET
                           1216 ;---------------------------------------------------------------------------------
   E48B 3E 04         [ 7] 1217 XMS_EOT:		MVI	A,EOT		;HANDLE THE END OF TRANSFER FOR CRC OR CHECKSUM
   E48D CD EB F0      [18] 1218 		CALL	PUT_CHAR
   E490 3E 2D         [ 7] 1219 		MVI	A,45		;GET CHAR, 45 SECONDS TIMEOUT (EXPECT C OR NAK)
   E492 CD 00 E6      [18] 1220 		CALL	TIMED_GETCHAR
   E495 DA BD E4      [10] 1221 		JC	XM_CANCEL
   E498 FE 15         [ 7] 1222 		CPI	NAK
   E49A CA 8B E4      [10] 1223 		JZ	XMS_EOT
   E49D FE 06         [ 7] 1224 		CPI	ACK
   E49F C2 BD E4      [10] 1225 		JNZ	XM_CANCEL
                           1226 
   E4A2 CD 98 F0      [18] 1227 XM_DONE:		CALL	PRINTI
   E4A5 0D 0A 54 52 41 4E  1228 		.ascii "\r\nTRANSFER COMPLETE\r\n\000"
        53 46 45 52 20 43
        4F 4D 50 4C 45 54
        45 0D 0A 00
   E4BB AF            [ 4] 1229 		XRA	A		;CLEAR A, CY
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 25
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E4BC C9            [10] 1230 		RET
                           1231 
                           1232 ;FINISHING CODE PRIOR TO LEAVING XMODEM
   E4BD 3E 18         [ 7] 1233 XM_CANCEL:	MVI	A,CAN
   E4BF CD EB F0      [18] 1234 		CALL	PUT_CHAR
   E4C2 CD EB F0      [18] 1235 		CALL	PUT_CHAR
   E4C5 CD 21 E6      [18] 1236 		CALL	PURGE
   E4C8 CD 98 F0      [18] 1237 		CALL	PRINTI
   E4CB 54 52 41 4E 53 46  1238 		.ascii "TRANSFER CANCELED\r\n\000"
        45 52 20 43 41 4E
        43 45 4C 45 44 0D
        0A 00
   E4DF C1            [10] 1239 		POP	B		;SCRAP CALLING ROUTINE AND HEAD TO PARENT
   E4E0 C9            [10] 1240 		RET
                           1241 
                           1242 
                           1243 
                           1244 
                           1245 
                           1246 
                           1247 ;---------------------------------------------------------------------------------
                           1248 ;START XMODEM RECEIVING and RECEIVE FIRST PACKET
                           1249 ;---------------------------------------------------------------------------------
   E4E1 1E 05         [ 7] 1250 XMR_INIT:	MVI	E,5		;5 ATTEMPTS TO INITIATE XMODEM CRC TRANSFER
   E4E3 3E 01         [ 7] 1251 		MVI	A,1		;EXPECTED SEQ NUMBER starts at 1
   E4E5 32 87 FD      [13] 1252 		STA	XMSEQ
   E4E8 CD 21 E6      [18] 1253 XMR_CRC:		CALL	PURGE
   E4EB 3E 43         [ 7] 1254 		MVI	A,"C"		;Send C
   E4ED 32 88 FD      [13] 1255 		STA	XMTYPE		;Save as XM Type (CRC or CS)
   E4F0 CD EB F0      [18] 1256 		CALL	PUT_CHAR
   E4F3 CD A9 E5      [18] 1257 		CALL	XMGET_HDR	;Await a packet
   E4F6 D2 3A E5      [10] 1258 		JNC	XMR_TSEQ	;Jump if first packet received
   E4F9 C2 BD E4      [10] 1259 		JNZ	XM_CANCEL	;Cancel if there was a response that was not a header
   E4FC 1D            [ 4] 1260 		DCR	E		;Otherwise, if no response, retry a few times
   E4FD C2 E8 E4      [10] 1261 		JNZ	XMR_CRC
                           1262 
   E500 1E 05         [ 7] 1263 		MVI	E,5		;5 ATTEMPTS TO INITIATE XMODEM CHECKSUM TRANSFER
   E502 CD 21 E6      [18] 1264 XMR_CS:		CALL	PURGE
   E505 3E 15         [ 7] 1265 		MVI	A,NAK		;Send NAK
   E507 32 88 FD      [13] 1266 		STA	XMTYPE		;Save as XM Type (CRC or CS)
   E50A CD EB F0      [18] 1267 		CALL	PUT_CHAR
   E50D CD A9 E5      [18] 1268 		CALL	XMGET_HDR	;Await a packet
   E510 D2 3A E5      [10] 1269 		JNC	XMR_TSEQ	;Jump if first packet received
   E513 C2 BD E4      [10] 1270 		JNZ	XM_CANCEL	;Cancel if there was a response that was not a header
   E516 1D            [ 4] 1271 		DCR	E		;Otherwise, if no response, retry a few times
   E517 C2 02 E5      [10] 1272 		JNZ	XMR_CS
   E51A C3 BD E4      [10] 1273 		JMP	XM_CANCEL	;Abort
                           1274 
                           1275 
                           1276 ;--------------------- XMODEM RECEIVE
                           1277 ;Entry:	XMR_TSEQ in the middle of the routine
                           1278 ;Pre:	C=1 (expected first block as received when negogiating CRC or Checksum)
                           1279 ;	HL=Memory to dump the file to
                           1280 ;Uses:	B to count the 128 bytes per block
                           1281 ;	C to track Block Number expected
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 26
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           1282 ;	DE as CRC (Within Loop) (D is destroyed when Getting Header)
                           1283 ;------------------------------------
   E51D 3E 06         [ 7] 1284 XMR_RECV:	MVI	A,ACK		;Send Ack to start Receiving next packet
   E51F CD EB F0      [18] 1285 		CALL	PUT_CHAR
   E522 CD A9 E5      [18] 1286 XMR_LP:		CALL	XMGET_HDR
   E525 D2 3A E5      [10] 1287 		JNC	XMR_TSEQ
   E528 E5            [12] 1288 		PUSH	H
   E529 CA 9D E5      [10] 1289 		JZ	XMR_NAK		;NACK IF TIMED OUT
   E52C E1            [10] 1290 		POP	H
   E52D FE 04         [ 7] 1291 		CPI	EOT
   E52F C2 BD E4      [10] 1292 		JNZ	XM_CANCEL	;CANCEL IF CAN RECEIVED (OR JUST NOT EOT)
   E532 3E 06         [ 7] 1293 		MVI	A,ACK
   E534 CD EB F0      [18] 1294 		CALL	PUT_CHAR
   E537 C3 A2 E4      [10] 1295 		JMP	XM_DONE
                           1296 
   E53A 4F            [ 4] 1297 XMR_TSEQ:	MOV	C,A
   E53B 3A 87 FD      [13] 1298 		LDA	XMSEQ
   E53E B9            [ 4] 1299 		CMP	C		;CHECK IF THIS SEQ IS EXPECTED
   E53F CA 50 E5      [10] 1300 		JZ	XMR_SEQ_OK	;Jump if CORRECT SEQ
   E542 3D            [ 4] 1301 		DCR	A		;Else test if Previous SEQ
   E543 32 87 FD      [13] 1302 		STA	XMSEQ
   E546 B9            [ 4] 1303 		CMP	C
   E547 C2 BD E4      [10] 1304 		JNZ	XM_CANCEL	;CANCEL IF SEQUENCE ISN'T PREVIOUS BLOCK
   E54A CD 21 E6      [18] 1305 		CALL	PURGE		;ELSE, PURGE AND SEND ACK (ASSUMING PREVIOUS ACK WAS NOT RECEIVED)
   E54D C3 93 E5      [10] 1306 		JMP	XMR_ACK
                           1307 
   E550 06 80         [ 7] 1308 XMR_SEQ_OK:	MVI	B,128		;128 BYTES PER BLOCK
   E552 0E 00         [ 7] 1309 		MVI	C,0		;Clear Checksum
   E554 11 00 00      [10] 1310 		LXI	D,0x0000		;CLEAR CRC
   E557 E5            [12] 1311 		PUSH	H		;Save HL where block is to go
   E558 CD FE E5      [18] 1312 XMR_BLK_LP:	CALL	TIMED1_GETCHAR
   E55B DA 9D E5      [10] 1313 		JC	XMR_NAK
   E55E 77            [ 7] 1314 		MOV	M,A		;SAVE DATA BYTE
   E55F CD D0 E5      [18] 1315 		CALL	CRC_UPDATE
   E562 7E            [ 7] 1316 		MOV	A,M		;Update checksum
   E563 81            [ 4] 1317 		ADD	C
   E564 4F            [ 4] 1318 		MOV	C,A
   E565 23            [ 6] 1319 		INX	H		;ADVANCE
   E566 05            [ 4] 1320 		DCR	B
   E567 C2 58 E5      [10] 1321 		JNZ	XMR_BLK_LP
                           1322 					;After 128 byte packet, verify error checking byte(s)
   E56A 3A 88 FD      [13] 1323 		LDA	XMTYPE		;Determine if we are using CRC or Checksum
   E56D FE 15         [ 7] 1324 		CPI	NAK		;If NAK, then use Checksum
   E56F CA 89 E5      [10] 1325 		JZ	XMR_CCS
   E572 CD FE E5      [18] 1326 		CALL	TIMED1_GETCHAR
   E575 DA 9D E5      [10] 1327 		JC	XMR_NAK
   E578 BA            [ 4] 1328 		CMP	D
   E579 C2 9D E5      [10] 1329 		JNZ	XMR_NAK
   E57C CD FE E5      [18] 1330 		CALL	TIMED1_GETCHAR
   E57F DA 9D E5      [10] 1331 		JC	XMR_NAK
   E582 BB            [ 4] 1332 		CMP	E
   E583 C2 9D E5      [10] 1333 		JNZ	XMR_NAK
   E586 C3 93 E5      [10] 1334 		JMP	XMR_ACK
                           1335 
   E589 CD FE E5      [18] 1336 XMR_CCS:		CALL	TIMED1_GETCHAR
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 27
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E58C DA 9D E5      [10] 1337 		JC	XMR_NAK
   E58F B9            [ 4] 1338 		CMP	C
   E590 C2 9D E5      [10] 1339 		JNZ	XMR_NAK
                           1340 
                           1341 		;If we were transfering to a FILE, this is where we would write the
                           1342 		;sector and reset HL to the same 128 byte sector buffer.
                           1343 		;CALL	WRITE_SECTOR
                           1344 
   E593                    1345 XMR_ACK:		;MVI	A,ACK		;The sending of the Ack is done by
                           1346 		;CALL	PUT_CHAR	;the calling routine, to allow writes to disk
   E593 3A 87 FD      [13] 1347 		LDA	XMSEQ
   E596 3C            [ 4] 1348 		INR	A		;Advance to next SEQ BLOCK
   E597 32 87 FD      [13] 1349 		STA	XMSEQ
   E59A C1            [10] 1350 		POP	B
   E59B 37            [ 4] 1351 		STC			;Carry set when NOT last packet
   E59C C9            [10] 1352 		RET
                           1353 
   E59D E1            [10] 1354 XMR_NAK:		POP	H		;Return HL to start of block
   E59E CD 21 E6      [18] 1355 		CALL	PURGE
   E5A1 3E 15         [ 7] 1356 		MVI	A,NAK
   E5A3 CD EB F0      [18] 1357 		CALL	PUT_CHAR
   E5A6 C3 22 E5      [10] 1358 		JMP	XMR_LP
                           1359 
                           1360 
                           1361 ;--------------------- XMODEM - GET HEADER
                           1362 ;
                           1363 ;pre:	Nothing
                           1364 ;post:	Carry Set: A=0, (Zero set) if Timeout
                           1365 ;	Carry Set: A=CAN (Not Zero) if Cancel received
                           1366 ;	Carry Set: A=EOT (Not Zero) if End of Tranmission received
                           1367 ;	Carry Clear and A = B = Seq if Header found and is good
                           1368 ;------------------------------------------
   E5A9 3E 05         [ 7] 1369 XMGET_HDR:	MVI	A,5		;GET CHAR, 5 SECONDS TIMEOUT (EXPECT SOH)
   E5AB CD 00 E6      [18] 1370 		CALL	TIMED_GETCHAR
   E5AE D8            [12] 1371 		RC			;Return if Timed out
   E5AF FE 01         [ 7] 1372 		CPI	SOH		;TEST IF START OF HEADER
   E5B1 CA C1 E5      [10] 1373 		JZ	GS_SEQ		;IF SOH RECEIVED, GET SEQ NEXT
   E5B4 FE 04         [ 7] 1374 		CPI	EOT		;TEST IF END OF TRANSMISSION
   E5B6 CA BE E5      [10] 1375 		JZ	GS_ESC		;IF EOT RECEIVED, TERMINATE XMODEM
   E5B9 FE 18         [ 7] 1376 		CPI	CAN		;TEST IF CANCEL
   E5BB C2 A9 E5      [10] 1377 		JNZ	XMGET_HDR
   E5BE B7            [ 4] 1378 GS_ESC:		ORA	A		;Clear Z flag (because A<>0)
   E5BF 37            [ 4] 1379 		STC
   E5C0 C9            [10] 1380 		RET
   E5C1 CD FE E5      [18] 1381 GS_SEQ:		CALL	TIMED1_GETCHAR	;GET SEQ CHAR
   E5C4 D8            [12] 1382 		RC			;Return if Timed out
   E5C5 47            [ 7] 1383 		MOV	B,A		;SAVE SEQ
   E5C6 CD FE E5      [18] 1384 		CALL	TIMED1_GETCHAR	;GET SEQ COMPLEMENT
   E5C9 D8            [12] 1385 		RC			;Return if Timed out
   E5CA 2F            [ 4] 1386 		CMA
   E5CB B8            [ 4] 1387 		CMP	B		;TEST IF SEQ VALID
   E5CC C2 A9 E5      [10] 1388 		JNZ	XMGET_HDR	;LOOP BACK AND TRY AGAIN IF HEADER INCORRECT (SYNC FRAME)
   E5CF C9            [10] 1389 		RET
                           1390 
                           1391 ;------------------------------------------ CRC_UPDATE
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 28
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           1392 ;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
                           1393 ;Total Time=775 cycles = 388uSec
                           1394 ;In:	A  = New char to roll into CRC accumulator
                           1395 ;	DE = 16bit CRC accumulator
                           1396 ;Out:	DE = 16bit CRC accumulator
                           1397 ;------------------------------------------
                           1398 ;CRC_UPDATE:	XRA	D		;4
                           1399 ;		MOV	D,A		;5
                           1400 ;		PUSH	B		;11
                           1401 ;		MVI	B,8		;7	PRELOOP=27
                           1402 ;CRCU_LP:	ORA	A		;4	CLEAR CARRY
                           1403 ;		MOV	A,E		;5
                           1404 ;		RAL			;4
                           1405 ;		MOV	E,A		;5
                           1406 ;		MOV	A,D		;5
                           1407 ;		RAL			;4
                           1408 ;		MOV	D,A		;5
                           1409 ;		JNC	CRCU_NX		;10
                           1410 ;		MOV	A,D		;5
                           1411 ;		XRI	10h		;7
                           1412 ;		MOV	D,A		;5
                           1413 ;		MOV	A,E		;5
                           1414 ;		XRI	21H		;7
                           1415 ;		MOV	E,A		;5
                           1416 ;CRCU_NX:		DCR	B		;5
                           1417 ;		JNZ	CRCU_LP		;10	LOOP=91*8 (WORSE CASE)
                           1418 ;		POP	B		;10	POSTLOOP=20
                           1419 ;		RET			;10
                           1420 
                           1421 
                           1422 ;------------------------------------------ CRC_UPDATE
                           1423 ;HANDLE THE CRC CALCULATION FOR UP/DOWNLOADING
                           1424 ;Total Time=604 cycles = 302uSec MAX
                           1425 ;In:	A  = New char to roll into CRC accumulator
                           1426 ;	DE = 16bit CRC accumulator
                           1427 ;Out:	DE = 16bit CRC accumulator
                           1428 ;------------------------------------------
   E5D0 EB            [ 4] 1429 CRC_UPDATE:	XCHG			;4
   E5D1 AC            [ 4] 1430 		XRA	H		;4
   E5D2 67            [ 7] 1431 		MOV	H,A		;5
   E5D3 29            [10] 1432 		DAD	H		;10	Shift HL Left 1
   E5D4 DC F5 E5      [18] 1433 		CC	CRC_UPC		;17 (10/61)
   E5D7 29            [10] 1434 		DAD	H		;10	Shift HL Left 2
   E5D8 DC F5 E5      [18] 1435 		CC	CRC_UPC		;17
   E5DB 29            [10] 1436 		DAD	H		;10	Shift HL Left 3
   E5DC DC F5 E5      [18] 1437 		CC	CRC_UPC		;17
   E5DF 29            [10] 1438 		DAD	H		;10	Shift HL Left 4
   E5E0 DC F5 E5      [18] 1439 		CC	CRC_UPC		;17
   E5E3 29            [10] 1440 		DAD	H		;10	Shift HL Left 5
   E5E4 DC F5 E5      [18] 1441 		CC	CRC_UPC		;17
   E5E7 29            [10] 1442 		DAD	H		;10	Shift HL Left 6
   E5E8 DC F5 E5      [18] 1443 		CC	CRC_UPC		;17
   E5EB 29            [10] 1444 		DAD	H		;10	Shift HL Left 7
   E5EC DC F5 E5      [18] 1445 		CC	CRC_UPC		;17
   E5EF 29            [10] 1446 		DAD	H		;10	Shift HL Left 8
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 29
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E5F0 DC F5 E5      [18] 1447 		CC	CRC_UPC		;17
   E5F3 EB            [ 4] 1448 		XCHG			;4
   E5F4 C9            [10] 1449 		RET			;10
                           1450 
   E5F5 7C            [ 4] 1451 CRC_UPC:		MOV	A,H		;5
   E5F6 EE 10         [ 7] 1452 		XRI	0x10		;7
   E5F8 67            [ 7] 1453 		MOV	H,A		;5
   E5F9 7D            [ 4] 1454 		MOV	A,L		;5
   E5FA EE 21         [ 7] 1455 		XRI	0x21		;7
   E5FC 6F            [ 4] 1456 		MOV	L,A		;5
   E5FD C9            [10] 1457 		RET			;10
                           1458 
                           1459 
                           1460 ;===============================================
                           1461 ;TIMED1_GETCHAR - Gets a character within 1 second
                           1462 ;
                           1463 ;pre:	nothing
                           1464 ;post: 	Carry Set = No Char, Time Out
                           1465 ;	Carry Clear, A = Char
                           1466 ;-----------------------------------------------
   E5FE 3E 01         [ 7] 1467 TIMED1_GETCHAR:	MVI	A,1
                           1468 
                           1469 ;===============================================
                           1470 ;TIMED_GETCHAR - Gets a character within a time limit
                           1471 ;
                           1472 ;pre:	A contains # of seconds to wait before returning
                           1473 ;post: 	Carry Set & Zero Set = No Char, Time Out
                           1474 ;	Carry Clear, A = Char
                           1475 ;-----------------------------------------------
   E600 D5            [12] 1476 TIMED_GETCHAR:	PUSH	D
   E601 C5            [12] 1477 		PUSH	B
   E602 57            [ 7] 1478 		MOV	D,A
                           1479 		;MVI	C,0	;B,C=Loop Count down until timeout
   E603 06 6B         [ 7] 1480 TGC_LP1:		MVI	B,107		;107 * 9.3mSec = 1 Second
   E605 CD 06 EE      [18] 1481 TGC_LP2:		CALL	CONSTV	;45  TEST FOR RX DATA
   E608 C2 1B E6      [10] 1482 		JNZ	TGC_DO	;10
   E60B 0D            [ 4] 1483 		DCR	C	;5
   E60C C2 05 E6      [10] 1484 		JNZ	TGC_LP2	;10	;73 Cycles Loop time. 39*256*.5 ~= 9.3 mSec
   E60F 05            [ 4] 1485 		DCR	B
   E610 C2 05 E6      [10] 1486 		JNZ	TGC_LP2	;	1 Second waiting
   E613 15            [ 4] 1487 		DCR	D		;Count down Seconds until Time Out
   E614 C2 03 E6      [10] 1488 		JNZ	TGC_LP1
   E617 37            [ 4] 1489 		STC		;SET CARRY TO INDICATE TIME OUT
                           1490 		;MVI	A,0
   E618 C3 1E E6      [10] 1491 		JMP	TGC_RET
   E61B CD AA F0      [18] 1492 TGC_DO:		CALL	GET_CHAR_UART
   E61E C1            [10] 1493 TGC_RET:		POP	B
   E61F D1            [10] 1494 		POP	D
   E620 C9            [10] 1495 		RET
                           1496 
                           1497 
                           1498 ;===============================================
                           1499 ;PURGE - Clears all in coming bytes until the line is clear for a full 2 seconds
                           1500 ;-----------------------------------------------
   E621 3E 02         [ 7] 1501 PURGE:		MVI	A,2	;2 seconds for time out
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 30
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E623 CD 00 E6      [18] 1502 		CALL	TIMED_GETCHAR
   E626 D2 21 E6      [10] 1503 		JNC	PURGE
   E629 C9            [10] 1504 		RET
                           1505 
                           1506 
                           1507 
                           1508 ;XModem implementation on 8080 Monitor (CP/M-80)
                           1509 ;
                           1510 ;Terminal uploads to 8080 system:
                           1511 ;-Terminal user enters command "XU aaaa"
                           1512 ;-8080 "drives" the protocol since it's the receiver
                           1513 ;-8080 sends <Nak> every 10 seconds until the transmitter sends a packet
                           1514 ;-if transmitter does not begin within 10 trys (100 seconds), 8080 aborts XMODEM
                           1515 ;-a packet is:
                           1516 ; <SOH> [seq] [NOT seq] [128 bytes of data] [checksum or CRC]
                           1517 ;
                           1518 ;<SOH> = 1 (Start of Header)
                           1519 ;<EOT> = 4 (End of Transmission)
                           1520 ;<ACK> = 6
                           1521 ;<DLE> = 16
                           1522 ;<DC1> = 17 (X-ON)
                           1523 ;<DC3> = 19 (X-OFF)
                           1524 ;<NAK> = 21
                           1525 ;<SYN> = 22
                           1526 ;<CAN> = 24 (Cancel)
                           1527 ;
                           1528 ;Checksum is the Modulo 256 sum of all 128 data bytes
                           1529 ;
                           1530 ;                                     <<<<<          [NAK]
                           1531 ;       [SOH][001][255][...][csum]    >>>>>
                           1532 ;                                     <<<<<          [ACK]
                           1533 ;       [SOH][002][254][...][csum]    >>>>>
                           1534 ;                                     <<<<<          [ACK]
                           1535 ;       [SOH][003][253][...][csum]    >>>>>
                           1536 ;                                     <<<<<          [ACK]
                           1537 ;       [EOT]                         >>>>>
                           1538 ;                                     <<<<<          [ACK]
                           1539 ;
                           1540 ;-if we get <EOT> then ACK and terminate XModem
                           1541 ;-if we get <CAN> then terminate XModem
                           1542 ;-if checksum invalid, then NAK
                           1543 ;-if seq number not correct as per [NOT seq], then NAK
                           1544 ;-if seq number = previous number, then ACK (But ignore block)
                           1545 ;-if seq number not the expected number, then <CAN><CAN> and terminate XModem
                           1546 ;-if data not received after 10 seconds, then NAK (inc Timeout Retry)
                           1547 ;-if timeout retry>10 then <CAN><CAN> and terminate XModem
                           1548 ;
                           1549 ;-To keep synchronized,
                           1550 ;  -Look for <SOH>, qualify <SOH> by checking the [seq] / [NOT seq]
                           1551 ;  -if no <SOH> found after 135 chars, then NAK
                           1552 ;
                           1553 ;-False EOT condtion
                           1554 ;  -NAK the first EOT
                           1555 ;  -if the next char is EOT again, then ACK and leave XModem
                           1556 ;
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 31
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           1557 ;-False <CAN>, expect a 2nd <CAN> ?
                           1558 ;
                           1559 ;-Using CRC, send "C" instead of <NAK> for the first packet
                           1560 ;  -Send "C" every 3 seconds for 3 tries, then degrade to checksums by sending <NAK>
                           1561 ;
                           1562 ;
                           1563 ;
                           1564 ;* The character-receive subroutine should be called with a
                           1565 ;parameter specifying the number of seconds to wait.  The
                           1566 ;receiver should first call it with a time of 10, then <nak> and
                           1567 ;try again, 10 times.
                           1568 ;  After receiving the <soh>, the receiver should call the
                           1569 ;character receive subroutine with a 1-second timeout, for the
                           1570 ;remainder of the message and the <cksum>.  Since they are sent
                           1571 ;as a continuous stream, timing out of this implies a serious
                           1572 ;like glitch that caused, say, 127 characters to be seen instead
                           1573 ;of 128.
                           1574 ;
                           1575 ;* When the receiver wishes to <nak>, it should call a "PURGE"
                           1576 ;subroutine, to wait for the line to clear.  Recall the sender
                           1577 ;tosses any characters in its UART buffer immediately upon
                           1578 ;completing sending a block, to ensure no glitches were mis-
                           1579 ;interpreted.
                           1580 ;  The most common technique is for "PURGE" to call the
                           1581 ;character receive subroutine, specifying a 1-second timeout,
                           1582 ;and looping back to PURGE until a timeout occurs.  The <nak> is
                           1583 ;then sent, ensuring the other end will see it.
                           1584 ;
                           1585 ;* You may wish to add code recommended by Jonh Mahr to your
                           1586 ;character receive routine - to set an error flag if the UART
                           1587 ;shows framing error, or overrun.  This will help catch a few
                           1588 ;more glitches - the most common of which is a hit in the high
                           1589 ;bits of the byte in two consecutive bytes.  The <cksum> comes
                           1590 ;out OK since counting in 1-byte produces the same result of
                           1591 ;adding 80H + 80H as with adding 00H + 00H.
                           1592 
                           1593 
                           1594 
                           1595 ;----------------------------------------------------------------------------------------------------; RAM TEST
                           1596 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1597 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1598 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1599 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1600 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1601 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1602 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1603 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1604 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1605 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1606 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1607 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1608 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1609 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1610 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1611 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 32
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           1612 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           1613 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           1614 ;----------------------------------------------------------------------------------------------------; RAM TEST
                           1615 ;B=START PAGE
                           1616 ;C=END PAGE
   E62A CD CE E2      [18] 1617 RAM_TEST:	CALL	SPACE_GET_BYTE
   E62D 47            [ 7] 1618 		MOV	B, A
   E62E CD CE E2      [18] 1619 		CALL	SPACE_GET_BYTE
   E631 4F            [ 4] 1620 		MOV	C, A
                           1621 
                           1622 ;Page March Test.  1 Sec/K
                           1623 ;
                           1624 ; FOR E = 00 TO FF STEP FF   'March 00 then March FF
                           1625 ;   FOR H = B TO C
                           1626 ;      PAGE(H) = E
                           1627 ;   NEXT H
                           1628 ;   FOR D = B TO C
                           1629 ;      PAGE(D) = NOT E
                           1630 ;      FOR H = B TO C
                           1631 ;         A = E
                           1632 ;         IF H = D THEN A = NOT E
                           1633 ;         IF PAGE(H) <> A THEN ERROR1
                           1634 ;      NEXT H
                           1635 ;   NEXT D
                           1636 ; NEXT E
                           1637 ;
                           1638 
   E632 CD 98 F0      [18] 1639 		CALL	PRINTI
   E635 0D 0A 54 45 53 54  1640 		.ascii "\r\nTESTING RAM\000"
        49 4E 47 20 52 41
        4D 00
   E643 1E FF         [ 7] 1641 		MVI	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's
                           1642 
                           1643 ;Clear/Set all pages
   E645 60            [ 4] 1644 RT1_LP0:		MOV	H,B		;HL = BASE RAM ADDRESS
   E646 2E 00         [ 7] 1645 		MVI	L,0
   E648 7B            [ 4] 1646 RT1_LP1:		MOV	A,E		;CLEAR A
   E649 2F            [ 4] 1647 		CMA
   E64A 77            [ 7] 1648 RT1_LP2:		MOV	M,A		;WRITE PAGE
   E64B 2C            [ 4] 1649 		INR	L
   E64C C2 4A E6      [10] 1650 		JNZ	RT1_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
   E64F 7C            [ 4] 1651 		MOV	A,H
   E650 24            [ 4] 1652 		INR	H		;ADVANCE TO NEXT PAGE
   E651 B9            [ 4] 1653 		CMP	C		;COMPARE WITH END PAGE
   E652 C2 48 E6      [10] 1654 		JNZ	RT1_LP1		;LOOP UNTIL = END PAGE
                           1655 
                           1656 ;March 1 PAGE through RAM
   E655 50            [ 4] 1657 		MOV	D,B		;Begin with START PAGE
                           1658 
                           1659 ;Write FF to page D
   E656 62            [ 4] 1660 RT1_LP3:		MOV	H,D		;HL = Marched Page ADDRESS
                           1661 		;MVI	L,0
   E657 CD C2 E8      [18] 1662 		CALL	ABORT_CHECK
                           1663 
   E65A 7A            [ 4] 1664 		MOV	A,D
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 33
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E65B 2F            [ 4] 1665 		CMA
   E65C D3 FF         [10] 1666 		OUT	FPLED
                           1667 		;MOV	A,E		;SET A
   E65E 73            [ 7] 1668 RT1_LP4:		MOV	M,E		;WRITE PAGE
   E65F 2C            [ 4] 1669 		INR	L
   E660 C2 5E E6      [10] 1670 		JNZ	RT1_LP4		;LOOP TO QUICKLY WRITE 1 PAGE
                           1671 
                           1672 ;Test all pages for 0 (except page D = FF)
   E663 60            [ 4] 1673 		MOV	H,B		;HL = BASE RAM ADDRESS
                           1674 		;MVI	L,0
                           1675 
   E664 7C            [ 4] 1676 RT1_LP5:		MOV	A,H		;IF H = D
   E665 BA            [ 4] 1677 		CMP	D
   E666 7B            [ 4] 1678 		MOV	A,E		;THEN Value = FF
   E667 CA 6B E6      [10] 1679 		JZ	RT1_LP6
   E66A 2F            [ 4] 1680 		CMA			;ELSE Value = 00
                           1681 
   E66B BE            [ 7] 1682 RT1_LP6:		CMP	M		;TEST RAM
   E66C C2 2C E8      [10] 1683 		JNZ	RT_FAIL1
   E66F 2C            [ 4] 1684 		INR	L
   E670 C2 6B E6      [10] 1685 		JNZ	RT1_LP6		;LOOP TO QUICKLY TEST 1 PAGE
   E673 7C            [ 4] 1686 		MOV	A,H
   E674 24            [ 4] 1687 		INR	H		;ADVANCE TO NEXT PAGE
   E675 B9            [ 4] 1688 		CMP	C		;COMPARE WITH END PAGE
   E676 C2 64 E6      [10] 1689 		JNZ	RT1_LP5		;LOOP UNTIL = END PAGE
                           1690 
                           1691 ;Write 00 back to page D
   E679 62            [ 4] 1692 		MOV	H,D		;HL = Marched Page ADDRESS
                           1693 		;MVI	L,0
   E67A 7B            [ 4] 1694 		MOV	A,E
   E67B 2F            [ 4] 1695 		CMA
   E67C 77            [ 7] 1696 RT1_LP7:		MOV	M,A		;WRITE PAGE
   E67D 2C            [ 4] 1697 		INR	L
   E67E C2 7C E6      [10] 1698 		JNZ	RT1_LP7		;LOOP TO QUICKLY WRITE 1 PAGE
                           1699 
   E681 7A            [ 4] 1700 		MOV	A,D
   E682 14            [ 4] 1701 		INR	D		;ADVANCE TO NEXT PAGE
   E683 B9            [ 4] 1702 		CMP	C		;COMPARE WITH END PAGE
   E684 C2 56 E6      [10] 1703 		JNZ	RT1_LP3		;LOOP UNTIL = END PAGE
                           1704 
   E687 1C            [ 4] 1705 		INR	E
   E688 CA 45 E6      [10] 1706 		JZ	RT1_LP0
                           1707 
   E68B CD 98 F0      [18] 1708 		CALL	PRINTI
   E68E 0D 0A 52 41 4D 20  1709 		.ascii "\r\nRAM PAGE MARCH PASSED\000"
        50 41 47 45 20 4D
        41 52 43 48 20 50
        41 53 53 45 44 00
                           1710 
                           1711 
                           1712 ;Byte March Test.  7 Sec/K
                           1713 ;
                           1714 ; FOR E = 00 TO FF STEP FF   'March 00 then March FF
                           1715 ;   FOR H = B TO C
                           1716 ;      PAGE(H) = E
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 34
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           1717 ;      FOR D = 00 TO FF
                           1718 ;         PAGE(H).D = NOT E
                           1719 ;         FOR L=0 TO FF
                           1720 ;            IF PAGE(H).L <> E THEN
                           1721 ;               IF PAGE(H).L <> NOT E THEN ERROR2
                           1722 ;               IF L<>D THEN ERROR2
                           1723 ;            ENDIF
                           1724 ;         NEXT L
                           1725 ;      NEXT D
                           1726 ;   NEXT H
                           1727 ; NEXT E
                           1728 
   E6A6 1E FF         [ 7] 1729 		MVI	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's
                           1730 
                           1731 ;Clear/Set all pages
                           1732 
   E6A8 60            [ 4] 1733 RT2_LP0:		MOV	H,B		;HL = BASE RAM ADDRESS
   E6A9 2E 00         [ 7] 1734 RT2_LP1:		MVI	L,0
   E6AB CD C2 E8      [18] 1735 		CALL	ABORT_CHECK
                           1736 
   E6AE 7C            [ 4] 1737 		MOV	A,H
   E6AF 2F            [ 4] 1738 		CMA
   E6B0 D3 FF         [10] 1739 		OUT	FPLED
                           1740 
   E6B2 7B            [ 4] 1741 		MOV	A,E		;CLEAR A
   E6B3 2F            [ 4] 1742 		CMA
   E6B4 77            [ 7] 1743 RT2_LP2:		MOV	M,A		;WRITE PAGE
   E6B5 2C            [ 4] 1744 		INR	L
   E6B6 C2 B4 E6      [10] 1745 		JNZ	RT2_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
                           1746 
                           1747 
   E6B9 16 00         [ 7] 1748 		MVI	D,0		;Starting with BYTE 00 of page
                           1749 
   E6BB 6A            [ 4] 1750 RT2_LP3:		MOV	L,D		;Save at byte march ptr
   E6BC 7B            [ 4] 1751 		MOV	A,E		;SET A
   E6BD 77            [ 7] 1752 		MOV	M,A
                           1753 
                           1754 		;MOV	A,E
   E6BE 2F            [ 4] 1755 		CMA			;CLEAR A
   E6BF 2E 00         [ 7] 1756 		MVI	L,0
                           1757 
   E6C1 BE            [ 7] 1758 RT2_LP4:		CMP	M		;TEST BYTE FOR CLEAR
   E6C2 CA D1 E6      [10] 1759 		JZ	RT2_NX1
   E6C5 2F            [ 4] 1760 		CMA			;SET A
   E6C6 BE            [ 7] 1761 		CMP	M		;TEST BYTE FOR SET
   E6C7 C2 51 E8      [10] 1762 		JNZ	RT_FAIL2	;IF NOT FULLY SET, THEN DEFINITELY FAIL
   E6CA 7D            [ 4] 1763 		MOV	A,L		;ELSE CHECK WE ARE ON MARCHED BYTE
   E6CB BA            [ 4] 1764 		CMP	D
   E6CC C2 51 E8      [10] 1765 		JNZ	RT_FAIL2
   E6CF 7B            [ 4] 1766 		MOV	A,E		;CLEAR A
   E6D0 2F            [ 4] 1767 		CMA
   E6D1 2C            [ 4] 1768 RT2_NX1:		INR	L
   E6D2 C2 C1 E6      [10] 1769 		JNZ	RT2_LP4		;LOOP TO QUICKLY WRITE 1 PAGE
                           1770 
   E6D5 6A            [ 4] 1771 		MOV	L,D		;Save at byte march ptr
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 35
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E6D6 7B            [ 4] 1772 		MOV	A,E
   E6D7 2F            [ 4] 1773 		CMA			;CLEAR A
   E6D8 77            [ 7] 1774 		MOV	M,A
                           1775 
   E6D9 14            [ 4] 1776 		INR	D
   E6DA C2 BB E6      [10] 1777 		JNZ	RT2_LP3
                           1778 
   E6DD 7C            [ 4] 1779 		MOV	A,H
   E6DE 24            [ 4] 1780 		INR	H		;ADVANCE TO NEXT PAGE
   E6DF B9            [ 4] 1781 		CMP	C		;COMPARE WITH END PAGE
   E6E0 C2 A9 E6      [10] 1782 		JNZ	RT2_LP1		;LOOP UNTIL = END PAGE
                           1783 
   E6E3 1C            [ 4] 1784 		INR	E
   E6E4 CA A8 E6      [10] 1785 		JZ	RT2_LP0
                           1786 
   E6E7 CD 98 F0      [18] 1787 		CALL	PRINTI
   E6EA 0D 0A 52 41 4D 20  1788 		.ascii "\r\nRAM BYTE MARCH 1 PASSED\000"
        42 59 54 45 20 4D
        41 52 43 48 20 31
        20 50 41 53 53 45
        44 00
                           1789 
                           1790 ;26 Sec/K
                           1791 
   E704                    1792 BYTEMARCH2:
   E704 1E FF         [ 7] 1793 		MVI	E,0xFF		;E selects the polarity of the test, ie March a page of 1'S or 0's
                           1794 
   E706 16 00         [ 7] 1795 RT4_LP0:		MVI	D,0		;Starting with BYTE 00 of page
                           1796 
                           1797 ;CLEAR all pages
                           1798 
   E708 60            [ 4] 1799 		MOV	H,B		;HL = BASE RAM ADDRESS
   E709 2E 00         [ 7] 1800 		MVI	L,0
                           1801 
   E70B 7B            [ 4] 1802 RT4_LP1:		MOV	A,E		;CLEAR A
   E70C 2F            [ 4] 1803 		CMA
   E70D 77            [ 7] 1804 RT4_LP2:		MOV	M,A		;WRITE PAGE
   E70E 2C            [ 4] 1805 		INR	L
   E70F C2 0D E7      [10] 1806 		JNZ	RT4_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
                           1807 
   E712 7C            [ 4] 1808 		MOV	A,H
   E713 24            [ 4] 1809 		INR	H		;ADVANCE TO NEXT PAGE
   E714 B9            [ 4] 1810 		CMP	C		;COMPARE WITH END PAGE
   E715 C2 0B E7      [10] 1811 		JNZ	RT4_LP1		;LOOP UNTIL = END PAGE
                           1812 
                           1813 
   E718 CD C2 E8      [18] 1814 RT4_LP3:		CALL	ABORT_CHECK
   E71B 7A            [ 4] 1815 		MOV	A,D
   E71C 2F            [ 4] 1816 		CMA
   E71D D3 FF         [10] 1817 		OUT	FPLED
                           1818 
                           1819 					;Write SET byte at "D" in every page
   E71F 60            [ 4] 1820 		MOV	H,B		;HL = BASE RAM ADDRESS
   E720 6A            [ 4] 1821 		MOV	L,D		;Save at byte march ptr
   E721 73            [ 7] 1822 RT4_LP4:		MOV	M,E
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 36
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           1823 
   E722 7C            [ 4] 1824 		MOV	A,H
   E723 24            [ 4] 1825 		INR	H		;ADVANCE TO NEXT PAGE
   E724 B9            [ 4] 1826 		CMP	C		;COMPARE WITH END PAGE
   E725 C2 21 E7      [10] 1827 		JNZ	RT4_LP4		;LOOP UNTIL = END PAGE
                           1828 
                           1829 
   E728 2E 00         [ 7] 1830 		MVI	L,0
                           1831 
   E72A 60            [ 4] 1832 RT4_LP5:		MOV	H,B		;HL = BASE RAM ADDRESS
   E72B 7D            [ 4] 1833 		MOV	A,L
   E72C BA            [ 4] 1834 		CMP	D
   E72D CA 3F E7      [10] 1835 		JZ	RT4_LP7		;Test for marked byte in all pages
                           1836 
   E730 7B            [ 4] 1837 RT4_LP6:		MOV	A,E
   E731 2F            [ 4] 1838 		CMA			;CLEAR A
   E732 BE            [ 7] 1839 		CMP	M		;TEST BYTE FOR CLEAR
   E733 C2 51 E8      [10] 1840 		JNZ	RT_FAIL2
                           1841 
   E736 7C            [ 4] 1842 		MOV	A,H
   E737 24            [ 4] 1843 		INR	H		;ADVANCE TO NEXT PAGE
   E738 B9            [ 4] 1844 		CMP	C		;COMPARE WITH END PAGE
   E739 C2 30 E7      [10] 1845 		JNZ	RT4_LP6		;LOOP UNTIL = END PAGE
   E73C C3 4A E7      [10] 1846 		JMP	RT4_NX
                           1847 
   E73F 7B            [ 4] 1848 RT4_LP7:		MOV	A,E
   E740 BE            [ 7] 1849 		CMP	M		;TEST BYTE FOR SET
   E741 C2 51 E8      [10] 1850 		JNZ	RT_FAIL2
                           1851 
   E744 7C            [ 4] 1852 		MOV	A,H
   E745 24            [ 4] 1853 		INR	H		;ADVANCE TO NEXT PAGE
   E746 B9            [ 4] 1854 		CMP	C		;COMPARE WITH END PAGE
   E747 C2 3F E7      [10] 1855 		JNZ	RT4_LP7		;LOOP UNTIL = END PAGE
                           1856 
   E74A 2C            [ 4] 1857 RT4_NX:		INR	L
   E74B C2 2A E7      [10] 1858 		JNZ	RT4_LP5
                           1859 
                           1860 					;Write CLEAR byte at "D" in every page
   E74E 60            [ 4] 1861 		MOV	H,B		;HL = BASE RAM ADDRESS
   E74F 6A            [ 4] 1862 		MOV	L,D		;Save at byte march ptr
   E750 7B            [ 4] 1863 RT4_LP8:		MOV	A,E
   E751 2F            [ 4] 1864 		CMA
   E752 77            [ 7] 1865 		MOV	M,A
                           1866 
   E753 7C            [ 4] 1867 		MOV	A,H
   E754 24            [ 4] 1868 		INR	H		;ADVANCE TO NEXT PAGE
   E755 B9            [ 4] 1869 		CMP	C		;COMPARE WITH END PAGE
   E756 C2 50 E7      [10] 1870 		JNZ	RT4_LP8		;LOOP UNTIL = END PAGE
                           1871 
   E759 14            [ 4] 1872 		INR	D
   E75A C2 18 E7      [10] 1873 		JNZ	RT4_LP3
                           1874 
                           1875 
   E75D 1C            [ 4] 1876 		INR	E
   E75E CA 06 E7      [10] 1877 		JZ	RT4_LP0
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 37
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           1878 
   E761 CD 98 F0      [18] 1879 		CALL	PRINTI
   E764 0D 0A 52 41 4D 20  1880 		.ascii "\r\nRAM BYTE MARCH 2 PASSED\000"
        42 59 54 45 20 4D
        41 52 43 48 20 32
        20 50 41 53 53 45
        44 00
                           1881 
                           1882 
   E77E                    1883 BIT_MARCH:
                           1884 ;Bit March Test.  0.1 Sec/K
                           1885 
   E77E 1E 01         [ 7] 1886 		MVI	E,01		;E selects the bit to march
                           1887 
                           1888 ;Clear/Set all pages
                           1889 
   E780 60            [ 4] 1890 RT3_LP1:		MOV	H,B		;HL = BASE RAM ADDRESS
   E781 2E 00         [ 7] 1891 		MVI	L,0
                           1892 
   E783 CD C2 E8      [18] 1893 		CALL	ABORT_CHECK
                           1894 
   E786 7B            [ 4] 1895 		MOV	A,E		;Display bit pattern on LED PORT
   E787 2F            [ 4] 1896 		CMA
   E788 D3 FF         [10] 1897 		OUT	FPLED
                           1898 
   E78A 7B            [ 4] 1899 RT3_LP2:		MOV	A,E		;FETCH MARCHING BIT PATTERN
   E78B 77            [ 7] 1900 RT3_LP3:		MOV	M,A		;WRITE PAGE
   E78C 2C            [ 4] 1901 		INR	L
   E78D C2 8B E7      [10] 1902 		JNZ	RT3_LP3		;LOOP TO QUICKLY WRITE 1 PAGE
                           1903 
   E790 7C            [ 4] 1904 		MOV	A,H
   E791 24            [ 4] 1905 		INR	H		;ADVANCE TO NEXT PAGE
   E792 B9            [ 4] 1906 		CMP	C		;COMPARE WITH END PAGE
   E793 C2 8A E7      [10] 1907 		JNZ	RT3_LP2		;LOOP UNTIL = END PAGE
                           1908 
   E796 60            [ 4] 1909 		MOV	H,B		;HL = BASE RAM ADDRESS
                           1910 ;		MVI	L,0
                           1911 
   E797 7B            [ 4] 1912 RT3_LP4:		MOV	A,E		;FETCH MARCHING BIT PATTERN
   E798 BE            [ 7] 1913 RT3_LP5:		CMP	M
   E799 C2 76 E8      [10] 1914 		JNZ	RT_FAIL3
   E79C 2C            [ 4] 1915 		INR	L
   E79D C2 98 E7      [10] 1916 		JNZ	RT3_LP5		;LOOP TO QUICKLY WRITE 1 PAGE
                           1917 
   E7A0 7C            [ 4] 1918 		MOV	A,H
   E7A1 24            [ 4] 1919 		INR	H		;ADVANCE TO NEXT PAGE
   E7A2 B9            [ 4] 1920 		CMP	C		;COMPARE WITH END PAGE
   E7A3 C2 97 E7      [10] 1921 		JNZ	RT3_LP4		;LOOP UNTIL = END PAGE
                           1922 
                           1923 
                           1924 					;0000 0010
                           1925 					;...
                           1926 					;1000 0000
                           1927 
   E7A6 7B            [ 4] 1928 		MOV	A,E
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 38
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E7A7 17            [ 4] 1929 		RAL			;ROTATE THE 01 UNTIL 00
   E7A8 7B            [ 4] 1930 		MOV	A,E
   E7A9 07            [ 4] 1931 		RLC
   E7AA 5F            [ 4] 1932 		MOV	E,A
   E7AB FE 01         [ 7] 1933 		CPI	1
   E7AD C2 B5 E7      [10] 1934 		JNZ	RT3_NX1
   E7B0 2F            [ 4] 1935 		CMA			;INVERT ALL BITS
   E7B1 5F            [ 4] 1936 		MOV	E,A
   E7B2 C3 80 E7      [10] 1937 		JMP	RT3_LP1
   E7B5 FE FE         [ 7] 1938 RT3_NX1:		CPI	0xFE
   E7B7 C2 80 E7      [10] 1939 		JNZ	RT3_LP1
                           1940 
   E7BA CD 98 F0      [18] 1941 		CALL	PRINTI
   E7BD 0D 0A 52 41 4D 20  1942 		.ascii "\r\nRAM BIT MARCH PASSED\000"
        42 49 54 20 4D 41
        52 43 48 20 50 41
        53 53 45 44 00
                           1943 
                           1944 
                           1945 
   E7D4 1E 01         [ 7] 1946 		MVI	E,01		;E selects the start sequence
                           1947 
                           1948 ;Clear/Set all pages
                           1949 
   E7D6 CD C2 E8      [18] 1950 RT5_LP1:		CALL	ABORT_CHECK
                           1951 
   E7D9 7B            [ 4] 1952 		MOV	A,E		;Display bit pattern on LED PORT
   E7DA 2F            [ 4] 1953 		CMA
   E7DB D3 FF         [10] 1954 		OUT	FPLED
                           1955 
   E7DD 60            [ 4] 1956 		MOV	H,B		;HL = BASE RAM ADDRESS
   E7DE 2E 00         [ 7] 1957 		MVI	L,0
   E7E0 53            [ 4] 1958 		MOV	D,E
                           1959 
   E7E1 14            [ 4] 1960 RT5_LP2:		INR	D
   E7E2 C2 E6 E7      [10] 1961 		JNZ	RT5_NX1
   E7E5 14            [ 4] 1962 		INR	D
   E7E6 72            [ 7] 1963 RT5_NX1:		MOV	M,D		;WRITE PAGE
   E7E7 2C            [ 4] 1964 		INR	L
   E7E8 C2 E1 E7      [10] 1965 		JNZ	RT5_LP2		;LOOP TO QUICKLY WRITE 1 PAGE
                           1966 
   E7EB 7C            [ 4] 1967 		MOV	A,H
   E7EC 24            [ 4] 1968 		INR	H		;ADVANCE TO NEXT PAGE
   E7ED B9            [ 4] 1969 		CMP	C		;COMPARE WITH END PAGE
   E7EE C2 E1 E7      [10] 1970 		JNZ	RT5_LP2		;LOOP UNTIL = END PAGE
                           1971 
   E7F1 60            [ 4] 1972 		MOV	H,B		;HL = BASE RAM ADDRESS
                           1973 		;MVI	L,0
   E7F2 53            [ 4] 1974 		MOV	D,E
                           1975 
   E7F3 14            [ 4] 1976 RT5_LP3:		INR	D
   E7F4 C2 F8 E7      [10] 1977 		JNZ	RT5_NX2
   E7F7 14            [ 4] 1978 		INR	D
   E7F8 7A            [ 4] 1979 RT5_NX2:		MOV	A,D
   E7F9 BE            [ 7] 1980 		CMP	M		;TEST
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 39
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   E7FA C2 9A E8      [10] 1981 		JNZ	RT_FAIL5
   E7FD 2C            [ 4] 1982 		INR	L
   E7FE C2 F3 E7      [10] 1983 		JNZ	RT5_LP3		;LOOP TO QUICKLY WRITE 1 PAGE
                           1984 
   E801 7C            [ 4] 1985 		MOV	A,H
   E802 24            [ 4] 1986 		INR	H		;ADVANCE TO NEXT PAGE
   E803 B9            [ 4] 1987 		CMP	C		;COMPARE WITH END PAGE
   E804 C2 F3 E7      [10] 1988 		JNZ	RT5_LP3		;LOOP UNTIL = END PAGE
                           1989 
   E807 1C            [ 4] 1990 		INR	E
   E808 C2 D6 E7      [10] 1991 		JNZ	RT5_LP1
                           1992 
   E80B CD 98 F0      [18] 1993 		CALL	PRINTI
   E80E 0D 0A 52 41 4D 20  1994 		.ascii "\r\nRAM SEQUENCE TEST PASSED\000"
        53 45 51 55 45 4E
        43 45 20 54 45 53
        54 20 50 41 53 53
        45 44 00
                           1995 
   E829 C3 E5 DD      [10] 1996 		JMP	MAIN_MENU
                           1997 
                           1998 
   E82C CD 98 F0      [18] 1999 RT_FAIL1:	CALL	PRINTI
   E82F 0D 0A 52 41 4D 20  2000 		.ascii "\r\nRAM FAILED PAGE MARCH AT:\000"
        46 41 49 4C 45 44
        20 50 41 47 45 20
        4D 41 52 43 48 20
        41 54 3A 00
   E84B CD 65 F0      [18] 2001 		CALL	PUT_HL
   E84E C3 E5 DD      [10] 2002 		JMP	MAIN_MENU
                           2003 
   E851 CD 98 F0      [18] 2004 RT_FAIL2:	CALL	PRINTI
   E854 0D 0A 52 41 4D 20  2005 		.ascii "\r\nRAM FAILED BYTE MARCH AT:\000"
        46 41 49 4C 45 44
        20 42 59 54 45 20
        4D 41 52 43 48 20
        41 54 3A 00
   E870 CD 65 F0      [18] 2006 		CALL	PUT_HL
   E873 C3 E5 DD      [10] 2007 		JMP	MAIN_MENU
                           2008 
   E876 CD 98 F0      [18] 2009 RT_FAIL3:	CALL	PRINTI
   E879 0D 0A 52 41 4D 20  2010 		.ascii "\r\nRAM FAILED BIT MARCH AT:\000"
        46 41 49 4C 45 44
        20 42 49 54 20 4D
        41 52 43 48 20 41
        54 3A 00
   E894 CD 65 F0      [18] 2011 		CALL	PUT_HL
   E897 C3 E5 DD      [10] 2012 		JMP	MAIN_MENU
                           2013 
   E89A CD 98 F0      [18] 2014 RT_FAIL5:	CALL	PRINTI
   E89D 0D 0A 52 41 4D 20  2015 		.ascii "\r\nRAM FAILED SEQUENCE TEST AT:\000"
        46 41 49 4C 45 44
        20 53 45 51 55 45
        4E 43 45 20 54 45
        53 54 20 41 54 3A
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 40
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



        00
   E8BC CD 65 F0      [18] 2016 		CALL	PUT_HL
   E8BF C3 E5 DD      [10] 2017 		JMP	MAIN_MENU
                           2018 
                           2019 
   E8C2 CD 06 EE      [18] 2020 ABORT_CHECK:	CALL	CONSTV
   E8C5 C8            [12] 2021 		RZ
   E8C6 CD D8 F0      [18] 2022 		CALL	GET_CHAR
   E8C9 FE 1B         [ 7] 2023 		CPI	27
   E8CB C0            [12] 2024 		RNZ
   E8CC E1            [10] 2025 		POP	H			;SCRAP RETURN ADDRESS AND GO TO PARENT ROUTINE
   E8CD CD 98 F0      [18] 2026 		CALL	PRINTI
   E8D0 0D 0A 41 42 4F 52  2027 		.ascii "\r\nABORTED\000"
        54 45 44 00
   E8DA C9            [10] 2028 		RET
                           2029 
                           2030 
                           2031 ;----------------------------------------------------------------------------------------------------; FLOPPY XMODEM TRANSFERS
                           2032 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2033 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2034 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2035 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2036 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2037 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2038 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2039 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2040 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2041 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2042 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2043 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2044 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2045 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2046 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2047 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2048 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2049 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2050 ;----------------------------------------------------------------------------------------------------; FLOPPY XMODEM TRANSFERS
   E8DB CD 98 F0      [18] 2051 FXSERR:		CALL 	PRINTI		;Display Err when input is invalid
   E8DE 0D 0A 45 52 52 4F  2052 		.ascii "\r\nERROR, LOGICAL SECTOR NUMBER WILL BE OUT OF RANGE\000"
        52 2C 20 4C 4F 47
        49 43 41 4C 20 53
        45 43 54 4F 52 20
        4E 55 4D 42 45 52
        20 57 49 4C 4C 20
        42 45 20 4F 55 54
        20 4F 46 20 52 41
        4E 47 45 00
                           2053 
   E912 CD 98 F0      [18] 2054 FXMODEM:	CALL 	PRINTI		;Display Err when input is invalid
   E915 0D 0A 46 4C 4F 50  2055 		.ascii "\r\nFLOPPY XMODEM MENU"
        50 59 20 58 4D 4F
        44 45 4D 20 4D 45
        4E 55
   E929 0D 0A 55 20 73 73  2056 		.ascii "\r\nU ssss      - UPLOAD (WRITE DISK) ssss=Starting Sector"
        73 73 20 20 20 20
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 41
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



        20 20 2D 20 55 50
        4C 4F 41 44 20 28
        57 52 49 54 45 20
        44 49 53 4B 29 20
        73 73 73 73 3D 53
        74 61 72 74 69 6E
        67 20 53 65 63 74
        6F 72
   E961 0D 0A 44 20 73 73  2057 		.ascii "\r\nD ssss cccc - DOWNLOAD (READ DISK) ssss=Starting Sector, cccc=Count of Sectors"
        73 73 20 63 63 63
        63 20 2D 20 44 4F
        57 4E 4C 4F 41 44
        20 28 52 45 41 44
        20 44 49 53 4B 29
        20 73 73 73 73 3D
        53 74 61 72 74 69
        6E 67 20 53 65 63
        74 6F 72 2C 20 63
        63 63 63 3D 43 6F
        75 6E 74 20 6F 66
        20 53 65 63 74 6F
        72 73
   E9B1 0D 0A 20 20 73 73  2058 		.ascii "\r\n  ssss = 0000 for 1st sector on track 0"
        73 73 20 3D 20 30
        30 30 30 20 66 6F
        72 20 31 73 74 20
        73 65 63 74 6F 72
        20 6F 6E 20 74 72
        61 63 6B 20 30
   E9DA 0D 0A 20 20 63 63  2059 		.ascii "\r\n  cccc = 07D2 (2002) for a whole disk (77 Tracks, 26 Sectors per)"
        63 63 20 3D 20 30
        37 44 32 20 28 32
        30 30 32 29 20 66
        6F 72 20 61 20 77
        68 6F 6C 65 20 64
        69 73 6B 20 28 37
        37 20 54 72 61 63
        6B 73 2C 20 32 36
        20 53 65 63 74 6F
        72 73 20 70 65 72
        29
   EA1D 0D 0A              2060 		.ascii "\r\n"
   EA1F 0D 0A 00           2061 		.ascii "\r\n\000"
                           2062 
   EA22 3E 3A         [ 7] 2063 FXMENU_LP:	MVI	A,":"
   EA24 CD EB F0      [18] 2064 		CALL	PUT_CHAR
   EA27 CD D8 F0      [18] 2065 		CALL 	GET_CHAR	;get char
   EA2A FE 1B         [ 7] 2066 		CPI 	27		;Branch to Command entered
   EA2C C8            [12] 2067 		RZ 			; <ESC> = Exit
   EA2D FE 3F         [ 7] 2068 		CPI 	"?"		;
   EA2F CA 12 E9      [10] 2069 		JZ 	FXMODEM		; ? = Help
   EA32 E6 5F         [ 7] 2070 		ANI 	0x5F		;to upper case
   EA34 FE 44         [ 7] 2071 		CPI 	"D"		;Branch to Command entered
   EA36 CA 41 EA      [10] 2072 		JZ 	FXMDN		; D = Download to Terminal (Read Disk)  D XXXX YYYY Where XXXX is Logicial sector and YYYY is Count of Sectors to send
   EA39 FE 55         [ 7] 2073 		CPI 	"U"
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 42
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   EA3B CA A3 EA      [10] 2074 		JZ 	FXMUP		; U = Upload from Terminal (Write Disk)
   EA3E C3 22 EA      [10] 2075 		JMP 	FXMENU_LP
                           2076 
                           2077 
   EA41 CD FF E2      [18] 2078 FXMDN:		CALL	SPACE_GET_WORD	;Input Logical Sector (to DE)
   EA44 EB            [ 4] 2079 		XCHG
   EA45 22 8D FD      [16] 2080 		SHLD	XSUM		;Save to sum up Logical sector + count of sectors
   EA48 22 8F FD      [16] 2081 		SHLD	XPOS		;Save position of next read
   EA4B EB            [ 4] 2082 		XCHG
   EA4C CD D9 EA      [18] 2083 		CALL	LOG2PHY		;Set the Physical Track and Sector based on the Logical Sector 0=Sector 1, Track 0
   EA4F D2 DB E8      [10] 2084 		JNC	FXSERR		;Sector out of range
   EA52 EB            [ 4] 2085 		XCHG
   EA53 22 89 FD      [16] 2086 		SHLD	XSECTOR		;Set XSECTOR & XTRACK (16 bit save to two 8 bit variables)
   EA56 CD FF E2      [18] 2087 		CALL	SPACE_GET_WORD	;Input # Sectors (Blocks)  to Send
   EA59 EB            [ 4] 2088 		XCHG
   EA5A 22 8B FD      [16] 2089 		SHLD	XCOUNT
   EA5D EB            [ 4] 2090 		XCHG			;Now test if the read of sectors will extend out of range.
   EA5E 2A 8D FD      [16] 2091 		LHLD	XSUM
   EA61 19            [10] 2092 		DAD	D		;HL = HL + DE.  START_SECTOR = START_SECTOR + SECTOR_COUNT
   EA62 DA DB E8      [10] 2093 		JC	FXSERR		;Sector out of range
   EA65 11 FF FF      [10] 2094 		LXI	D,0xFFFF
   EA68 19            [10] 2095 		DAD	D		;HL = HL - 1
   EA69 EB            [ 4] 2096 		XCHG
   EA6A CD D9 EA      [18] 2097 		CALL	LOG2PHY		;Test Start + Count - 1 <= Valid Track/Sector
   EA6D D2 DB E8      [10] 2098 		JNC	FXSERR		;Sector out of range
                           2099 
   EA70 CD 0C E4      [18] 2100 		CALL	XMS_INIT	;Starts the Seq, Sets the CS/CRC format
                           2101 					;Cancelled Transfers will cause a RET
                           2102 
   EA73 2A 8B FD      [16] 2103 FXMDN_LP:	LHLD	XCOUNT		;IF COUNT = 0 THEN EXIT
   EA76 7C            [ 4] 2104 		MOV	A,H
   EA77 B5            [ 4] 2105 		ORA	L
   EA78 CA 9D EA      [10] 2106 		JZ	FXMDN_DONE
   EA7B 2B            [ 6] 2107 		DCX	H		;ELSE, COUNT = COUNT - 1
   EA7C 22 8B FD      [16] 2108 		SHLD	XCOUNT
                           2109 					;Future? Check if Drive is already on correct Track
   EA7F 3A 8A FD      [13] 2110 		LDA	XTRACK		;Seek to correct Track (can't be much of a delay if already on correct track)
                           2111 ;		CALL	FSEEK
                           2112 
   EA82 3A 89 FD      [13] 2113 		LDA	XSECTOR		;Read the Sector
                           2114 ;		OUT	DSECTOR
                           2115 		;LXI	H, TRACK_BUFFER
                           2116 ;		MVI	A,08Ch		;Read Sector (with 10mS delay for head load)
                           2117 ;		CALL	READ_CMD
                           2118 
                           2119 		;LXI	H,TRACK_BUFFER	;Where to Send the Packet from
                           2120 
   EA85 CD 34 E4      [18] 2121 		CALL	XMS_SEND	;Sends the packet @HL, Resends if NAK
                           2122 					;Cancelled Transfers will cause a RET
                           2123 
   EA88 2A 8F FD      [16] 2124 		LHLD	XPOS		;Advance to next Logical Sector
   EA8B 23            [ 6] 2125 		INX	H
   EA8C 22 8F FD      [16] 2126 		SHLD	XPOS
   EA8F EB            [ 4] 2127 		XCHG
   EA90 CD D9 EA      [18] 2128 		CALL	LOG2PHY		;Set the Physical Track and Sector based on the Logical Sector 0=Sector 1, Track 0
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 43
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   EA93 D2 9D EA      [10] 2129 		JNC	FXMDN_DONE	;Sector out of range
   EA96 EB            [ 4] 2130 		XCHG
   EA97 22 89 FD      [16] 2131 		SHLD	XSECTOR		;Set XSECTOR & XTRACK (16 bit save to two 8 bit variables)
                           2132 
   EA9A C3 73 EA      [10] 2133 		JMP	FXMDN_LP
                           2134 
   EA9D CD 8B E4      [18] 2135 FXMDN_DONE:	CALL	XMS_EOT		;Send End of Transmission
   EAA0 C3 21 E6      [10] 2136 		JMP	PURGE
                           2137 
                           2138 
                           2139 
                           2140 ;Disk XMODEM
   EAA3 CD FF E2      [18] 2141 FXMUP:		CALL	SPACE_GET_WORD	;Input Logical Sector (to DE)
   EAA6 EB            [ 4] 2142 		XCHG
   EAA7 22 8F FD      [16] 2143 		SHLD	XPOS		;Save position of next write
   EAAA EB            [ 4] 2144 		XCHG
   EAAB CD D9 EA      [18] 2145 		CALL	LOG2PHY		;Set the Physical Track and Sector based on the Logical Sector 0=Sector 1, Track 0
   EAAE D2 DB E8      [10] 2146 		JNC	FXSERR		;Sector out of range
   EAB1 EB            [ 4] 2147 		XCHG
   EAB2 22 89 FD      [16] 2148 		SHLD	XSECTOR		;Set XSECTOR & XTRACK (16 bit save to two 8 bit variables)
                           2149 
                           2150 
                           2151 		;LXI	H,TRACK_BUFFER	;Where to receive data
   EAB5 CD E1 E4      [18] 2152 		CALL	XMR_INIT	;Starts the transfer, Sets the CS/CRC format & Receives first PACKET
                           2153 					;Cancelled Transfers will cause a RET
                           2154 
   EAB8 3A 8A FD      [13] 2155 XMU_DISK_LP:	LDA	XTRACK		;Seek to correct Track (can't be much of a delay if already on correct track)
                           2156 ;		CALL	FSEEK
                           2157 
                           2158 		;LXI	H,TRACK_BUFFER	;Where to save data
   EABB 3A 89 FD      [13] 2159 		LDA	XSECTOR		;Read the Sector
                           2160 ;		OUT	DSECTOR
                           2161 ;		MVI	A,0ACh		;WRITE SECTOR (w/ 10mSec Head Load Delay)
                           2162 ;		CALL	WRITE_CMD
                           2163 
   EABE 2A 8F FD      [16] 2164 		LHLD	XPOS		;Advance to next Logical Sector
   EAC1 23            [ 6] 2165 		INX	H
   EAC2 22 8F FD      [16] 2166 		SHLD	XPOS
   EAC5 EB            [ 4] 2167 		XCHG
   EAC6 CD D9 EA      [18] 2168 		CALL	LOG2PHY		;Set the Physical Track and Sector based on the Logical Sector 0=Sector 1, Track 0
   EAC9 D2 DB E8      [10] 2169 		JNC	FXSERR		;Sector out of range
   EACC EB            [ 4] 2170 		XCHG
   EACD 22 89 FD      [16] 2171 		SHLD	XSECTOR		;Set XSECTOR & XTRACK (16 bit save to two 8 bit variables)
                           2172 
                           2173 		;LXI	H,TRACK_BUFFER	;Where to receive data
   EAD0 CD 1D E5      [18] 2174 		CALL	XMR_RECV	;Receives the next packet @HL, Resends if NAK
                           2175 					;Cancelled Transfers will cause a RET
                           2176 
   EAD3 DA B8 EA      [10] 2177 		JC	XMU_DISK_LP	;Jump until EOT Received
   EAD6 C3 21 E6      [10] 2178 		JMP	PURGE
                           2179 
                           2180 
                           2181 
                           2182 
                           2183 
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 44
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           2184 ;---------------------------------------------------------------------------------------------------------------------
                           2185 ;Logical Sector to Physical Sector and Track #
                           2186 ;0=Track 0 : Sector 1
                           2187 ;1=0:2, 25=0:26, 26=1:1, 2001=77:26 (Last logical Sector)
                           2188 ;In:	DE = Logical Sector 0 to 2001
                           2189 ;Out:	D  = Track (0-76)
                           2190 ;	E  = Sector (1-26)
                           2191 ;	CY = Set for Valid Log Sec
                           2192 ;Uses:	A
                           2193 ;---------------------------------------------------------------------------------------------------------------------
   EAD9 7A            [ 4] 2194 LOG2PHY:		MOV	A,D
   EADA E6 F8         [ 7] 2195 		ANI	0xF8
   EADC C0            [12] 2196 		RNZ			;Return with CY clear
   EADD C5            [12] 2197 		PUSH	B
   EADE 06 00         [ 7] 2198 		MVI	B,0		;Track=0
   EAE0 D5            [12] 2199 L2LP:		PUSH	D		;Save DE before subtracting 26 sectors per track
   EAE1 7B            [ 4] 2200 		MOV	A,E		;Subtrack 26 from E
   EAE2 D6 1A         [ 7] 2201 		SUI	26
   EAE4 5F            [ 4] 2202 		MOV	E,A
   EAE5 D2 EC EA      [10] 2203 		JNC	L2PNT		;If no borrow occurs, then set track
   EAE8 15            [ 4] 2204 		DCR	D		;Decrement D
   EAE9 FA F1 EA      [10] 2205 		JM	L2PSS		;If negative, Set Sector
   EAEC F1            [10] 2206 L2PNT:		POP	PSW		;Scrap saved DE, accept DE as it's still positive
   EAED 04            [ 4] 2207 		INR	B		;Else, Advance Track
   EAEE C3 E0 EA      [10] 2208 		JMP	L2LP
   EAF1 D1            [10] 2209 L2PSS:		POP	D
   EAF2 1C            [ 4] 2210 		INR	E
   EAF3 78            [ 4] 2211 		MOV	A,B
   EAF4 57            [ 7] 2212 		MOV	D,A
   EAF5 FE 4D         [ 7] 2213 		CPI	77		;Test for invalid TRACK# (happens
   EAF7 C1            [10] 2214 		POP	B		;Return CY set for valid Logical Sector
   EAF8 C9            [10] 2215 		RET
                           2216 
                           2217 
                           2218 
                           2219 
                           2220 
                           2221 ;----------------------------------------------------------------------------------------------------; DISASSEMBLER
                           2222 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2223 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2224 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2225 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2226 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2227 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2228 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2229 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2230 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2231 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2232 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2233 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2234 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2235 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2236 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2237 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2238 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 45
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           2239 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2240 ;----------------------------------------------------------------------------------------------------; DISASSEMBLER
   EAF9 CD 65 F0      [18] 2241 DISASM:		CALL	PUT_HL		;Print Address	***CAUTION**** This routine has 3 tables that must NOT cross page boundaries.
   EAFC CD 98 F0      [18] 2242 		CALL	PRINTI
   EAFF 20 20 00           2243 		.ascii	"  \000"
   EB02 4E            [ 7] 2244 		MOV	C,M
   EB03 E5            [12] 2245 		PUSH	H
   EB04 CD 2C EB      [18] 2246 		CALL	DA_LOOKUP	;Print Mnemonic code
   EB07 E1            [10] 2247 		POP	H
   EB08 B7            [ 4] 2248 		ORA	A		;Test if there are any operands to print
   EB09 CA 27 EB      [10] 2249 		JZ	DA_NOOP		;Jump if NO operands
   EB0C 3D            [ 4] 2250 		DCR	A
   EB0D C2 18 EB      [10] 2251 		JNZ	DA_N1OP		;Jump if 2 operands (actually, if NOT 1 operand)
   EB10 23            [ 6] 2252 		INX	H
   EB11 7E            [ 7] 2253 		MOV	A,M		;Print Byte
   EB12 CD 70 F0      [18] 2254 		CALL	PUT_BYTE
   EB15 C3 27 EB      [10] 2255 		JMP	DA_NOOP
   EB18 3D            [ 4] 2256 DA_N1OP:		DCR	A
   EB19 C2 27 EB      [10] 2257 		JNZ	DA_NOOP
   EB1C 23            [ 6] 2258 		INX	H		;Print Word (high/low)
   EB1D 46            [ 4] 2259 		MOV	B,M
   EB1E 23            [ 6] 2260 		INX	H
   EB1F 7E            [ 7] 2261 		MOV	A,M
   EB20 CD 70 F0      [18] 2262 		CALL	PUT_BYTE
   EB23 78            [ 4] 2263 		MOV	A,B
   EB24 CD 70 F0      [18] 2264 		CALL	PUT_BYTE
   EB27 CD 48 F0      [18] 2265 DA_NOOP:		CALL	PUT_NEW_LINE
   EB2A 23            [ 6] 2266 		INX	H
   EB2B C9            [10] 2267 		RET
                           2268 
                           2269 					;Print Operand for Machine Code in C
   EB2C 21 A0 EC      [10] 2270 DA_LOOKUP:	LXI	H, TBL_1A
   EB2F 3E FF         [ 7] 2271 		MVI	A,0xFF		;Bit Mast (Mask no bits)
   EB31 11 05 00      [10] 2272 		LXI	D,5		;DE=LEN of table entry
   EB34 CD 94 EC      [18] 2273 		CALL	LS_SEARCH	;Search for commands without embedded codes or extra operands.
   EB37 CA 2E EC      [10] 2274 		JZ	DA_FOUND
   EB3A 79            [ 4] 2275 		MOV	A,C		;Fetch Code
   EB3B E6 C0         [ 7] 2276 		ANI	0xC0
   EB3D FE 40         [ 7] 2277 		CPI	0x40		;Test for MOV code
   EB3F CA 3D EC      [10] 2278 		JZ	DA_MOV
   EB42 3E CF         [ 7] 2279 		MVI	A,0xCF		;Mask out register pairs
   EB44 CD 94 EC      [18] 2280 		CALL	LS_SEARCH	;Search for 1C commands (Reg Pairs)
   EB47 CA 23 EC      [10] 2281 		JZ	DA_FOUND_1C
   EB4A CD 94 EC      [18] 2282 		CALL	LS_SEARCH	;Search for 3C command (LXI Reg Pairs,Immediate)
   EB4D CA 18 EC      [10] 2283 		JZ	DA_FOUND_3C
   EB50 3E F8         [ 7] 2284 		MVI	A,0xF8		;Mask out SSS register
   EB52 CD 94 EC      [18] 2285 		CALL	LS_SEARCH	;Search for 1B commands (Source Register)
   EB55 CA 0F EC      [10] 2286 		JZ	DA_FOUND_1B
   EB58 3E C7         [ 7] 2287 		MVI	A,0xC7		;Mask out DDD register
   EB5A CD 94 EC      [18] 2288 		CALL	LS_SEARCH	;Search for 1B commands (Source Register)
   EB5D CA 06 EC      [10] 2289 		JZ	DA_FOUND_1D
   EB60 FE 06         [ 7] 2290 		CPI	0x06		;Search for MVI command
   EB62 CA F2 EB      [10] 2291 		JZ	DA_FOUND_2B
   EB65 FE C7         [ 7] 2292 		CPI	0xC7		;Search for RST command
   EB67 CA DF EB      [10] 2293 		JZ	DA_FOUND_1R
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 46
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   EB6A 3E EF         [ 7] 2294 		MVI	A,0xEF
   EB6C CD 94 EC      [18] 2295 		CALL	LS_SEARCH	;Search for 1E commands (STAX or LDAX Reg Pairs)
   EB6F CA 23 EC      [10] 2296 		JZ	DA_FOUND_1C
   EB72 3E FF         [ 7] 2297 		MVI	A,0xFF
   EB74 CD 94 EC      [18] 2298 		CALL	LS_SEARCH	;Search for 2A commands (Acc Immediate functions)
   EB77 CA A2 EB      [10] 2299 		JZ	DA_FOUND_2A
   EB7A CD 94 EC      [18] 2300 		CALL	LS_SEARCH	;Search for 3C commands (LDA,STA,LHLD,SHLD)
   EB7D CA 99 EB      [10] 2301 		JZ	DA_FOUND_3D
   EB80 3E C7         [ 7] 2302 		MVI	A,0xC7		;Mask out Condition Code & LSB
   EB82 1E 02         [ 7] 2303 		MVI	E,2		;DE=LEN of table entry
   EB84 CD 94 EC      [18] 2304 		CALL	LS_SEARCH	;Search for 3B commands (Jump / Call Commands)
   EB87 CA AB EB      [10] 2305 		JZ	DA_FOUND_3B
                           2306 
   EB8A CD 98 F0      [18] 2307 DA_DB:		CALL	PRINTI		;When all searchs fail, print byte as a DB
   EB8D 44 42 20 20 20 00  2308 		.ascii	"DB   \000"
   EB93 79            [ 4] 2309 		MOV	A,C
   EB94 CD 70 F0      [18] 2310 		CALL	PUT_BYTE
   EB97 AF            [ 4] 2311 		XRA	A
   EB98 C9            [10] 2312 		RET
                           2313 
   EB99 CD 2E EC      [18] 2314 DA_FOUND_3D:	CALL	DA_FOUND	;Print opcode
   EB9C CD 53 E3      [18] 2315 		CALL	PUT_SPACE
   EB9F 3E 02         [ 7] 2316 		MVI	A,2		;Return to print 16 bit Memory operand
   EBA1 C9            [10] 2317 		RET
                           2318 
   EBA2 CD 2E EC      [18] 2319 DA_FOUND_2A:	CALL	DA_FOUND	;Print opcode
   EBA5 CD 53 E3      [18] 2320 		CALL	PUT_SPACE
   EBA8 3E 01         [ 7] 2321 		MVI	A,1		;Return to print 8 bit immediate Operand
   EBAA C9            [10] 2322 		RET
                           2323 
   EBAB 23            [ 6] 2324 DA_FOUND_3B:	INX	H
   EBAC 7E            [ 7] 2325 		MOV	A,M		;Print First letter of Op Code (J,C or R)
   EBAD CD EB F0      [18] 2326 		CALL	PUT_CHAR
   EBB0 79            [ 4] 2327 		MOV	A,C		;Fetch Code for DDD
   EBB1 0F            [ 4] 2328 		RRC
   EBB2 0F            [ 4] 2329 		RRC
   EBB3 21 CF EB      [10] 2330 		LXI	H, TBL_CC
   EBB6 E6 0E         [ 7] 2331 		ANI	0x0E		;Print 2 character Condition Code
   EBB8 85            [ 4] 2332 		ADD	L
   EBB9 6F            [ 4] 2333 		MOV	L,A
   EBBA 7E            [ 7] 2334 		MOV	A,M
   EBBB CD EB F0      [18] 2335 		CALL	PUT_CHAR
   EBBE 23            [ 6] 2336 		INX	H
   EBBF 7E            [ 7] 2337 		MOV	A,M
   EBC0 CD EB F0      [18] 2338 		CALL	PUT_CHAR
   EBC3 CD 98 F0      [18] 2339 		CALL	PRINTI
   EBC6 20 20 00           2340 		.ascii	"  \000"
   EBC9 79            [ 4] 2341 DAF_3B_RET:	MOV	A,C		;Codes that end in 100 or 010 result with 2 Operands
   EBCA 0F            [ 4] 2342 		RRC			;This allows address to be printed for JMP's and CALL's
   EBCB B1            [ 4] 2343 		ORA	C		;but not RET's
   EBCC E6 02         [ 7] 2344 		ANI	2
   EBCE C9            [10] 2345 		RET
                           2346 
   EBCF 4E 5A 5A 20 4E 43  2347 TBL_CC:		.ascii	"NZZ NCC POPEP M "
        43 20 50 4F 50 45
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 47
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



        50 20 4D 20
                           2348 
   EBDF CD 98 F0      [18] 2349 DA_FOUND_1R:	CALL	PRINTI
   EBE2 52 53 54 20 00     2350 		.ascii	"RST \000"
   EBE7 79            [ 4] 2351 		MOV	A,C
   EBE8 0F            [ 4] 2352 		RRC
   EBE9 0F            [ 4] 2353 		RRC
   EBEA 0F            [ 4] 2354 		RRC
   EBEB E6 07         [ 7] 2355 		ANI	7
   EBED CD 7F F0      [18] 2356 		CALL	PUT_HEX
   EBF0 AF            [ 4] 2357 		XRA	A
   EBF1 C9            [10] 2358 		RET
                           2359 
   EBF2 CD 98 F0      [18] 2360 DA_FOUND_2B:	CALL	PRINTI
   EBF5 4D 56 49 20 20 00  2361 		.ascii	"MVI  \000"
   EBFB CD 5C EC      [18] 2362 		CALL	DA_PUT_DDD
   EBFE CD 98 F0      [18] 2363 		CALL	PRINTI
   EC01 2C 00              2364 		.ascii	",\000"
   EC03 3E 01         [ 7] 2365 		MVI	A,1
   EC05 C9            [10] 2366 		RET
                           2367 
   EC06 CD 2E EC      [18] 2368 DA_FOUND_1D:	CALL	DA_FOUND
   EC09 CD 53 E3      [18] 2369 		CALL	PUT_SPACE
   EC0C C3 5C EC      [10] 2370 		JMP	DA_PUT_DDD
                           2371 
   EC0F CD 2E EC      [18] 2372 DA_FOUND_1B:	CALL	DA_FOUND
   EC12 CD 53 E3      [18] 2373 		CALL	PUT_SPACE
   EC15 C3 4E EC      [10] 2374 		JMP	DA_PUT_SSS
                           2375 
                           2376 
   EC18 CD 23 EC      [18] 2377 DA_FOUND_3C:	CALL	DA_FOUND_1C
   EC1B CD 98 F0      [18] 2378 		CALL	PRINTI
   EC1E 2C 00              2379 		.ascii	",\000"
   EC20 3E 02         [ 7] 2380 		MVI	A,2
   EC22 C9            [10] 2381 		RET
                           2382 
   EC23 CD 2E EC      [18] 2383 DA_FOUND_1C:	CALL	DA_FOUND	;Print the opcode
   EC26 CD 53 E3      [18] 2384 		CALL	PUT_SPACE
   EC29 CD 6B EC      [18] 2385 		CALL	DA_PUT_REGPAIR
   EC2C AF            [ 4] 2386 		XRA	A
   EC2D C9            [10] 2387 		RET
                           2388 
   EC2E 43            [ 4] 2389 DA_FOUND:	MOV	B,E		;Prints Opcode (no operands)
   EC2F 05            [ 4] 2390 		DCR	B
   EC30 23            [ 6] 2391 DAF_LP:		INX	H
   EC31 7E            [ 7] 2392 		MOV	A,M
   EC32 B7            [ 4] 2393 		ORA	A
   EC33 C8            [12] 2394 		RZ
   EC34 CD EB F0      [18] 2395 		CALL	PUT_CHAR
   EC37 05            [ 4] 2396 		DCR	B
   EC38 C2 30 EC      [10] 2397 		JNZ	DAF_LP
   EC3B AF            [ 4] 2398 		XRA	A
   EC3C C9            [10] 2399 		RET
                           2400 
   EC3D CD 98 F0      [18] 2401 DA_MOV:		CALL	PRINTI		;Prints MOV Opcode with 2 operands DDD, SSS
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 48
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   EC40 4D 4F 56 20 20 00  2402 		.ascii	"MOV  \000"
   EC46 CD 5C EC      [18] 2403 		CALL	DA_PUT_DDD
   EC49 CD 98 F0      [18] 2404 		CALL	PRINTI
   EC4C 2C 00              2405 		.ascii	",\000"
   EC4E 79            [ 4] 2406 DA_PUT_SSS:	MOV	A,C		;Fetch Code for SSS
   EC4F 21 63 EC      [10] 2407 DA_PUT_SSSDDD:	LXI	H, TBL_DDDSSS
   EC52 E6 07         [ 7] 2408 		ANI	0x07
   EC54 85            [ 4] 2409 		ADD	L
   EC55 6F            [ 4] 2410 		MOV	L,A
   EC56 7E            [ 7] 2411 		MOV	A,M
   EC57 CD EB F0      [18] 2412 		CALL	PUT_CHAR
   EC5A AF            [ 4] 2413 		XRA	A
   EC5B C9            [10] 2414 		RET
                           2415 
   EC5C 79            [ 4] 2416 DA_PUT_DDD:	MOV	A,C		;Fetch Code for DDD
   EC5D 0F            [ 4] 2417 		RRC
   EC5E 0F            [ 4] 2418 		RRC
   EC5F 0F            [ 4] 2419 		RRC
   EC60 C3 4F EC      [10] 2420 		JMP	DA_PUT_SSSDDD
                           2421 
   EC63 42 43 44 45 48 4C  2422 TBL_DDDSSS:	.ascii	"BCDEHLMA"
        4D 41
                           2423 
   EC6B 79            [ 4] 2424 DA_PUT_REGPAIR:	MOV	A,C		;Fetch Code for Reg Pair
   EC6C 0F            [ 4] 2425 		RRC
   EC6D 0F            [ 4] 2426 		RRC
   EC6E 0F            [ 4] 2427 		RRC
   EC6F 21 87 EC      [10] 2428 		LXI	H, TBL_REGPAIR
   EC72 E6 0E         [ 7] 2429 		ANI	0x0E
   EC74 FE 0E         [ 7] 2430 		CPI	0x0E		;Test for PSW Reg Pair
   EC76 C2 7E EC      [10] 2431 		JNZ	DAPR_OK
   EC79 3E 09         [ 7] 2432 		MVI	A,9
   EC7B C3 80 EC      [10] 2433 		JMP	DAPR_OK2
   EC7E E6 06         [ 7] 2434 DAPR_OK:		ANI	0x06
   EC80 85            [ 4] 2435 DAPR_OK2:	ADD	L
   EC81 6F            [ 4] 2436 		MOV	L,A
   EC82 CD 8E F0      [18] 2437 		CALL	PRINT
   EC85 AF            [ 4] 2438 		XRA	A		;Print returns with A=00
   EC86 C9            [10] 2439 		RET
                           2440 
   EC87 42 00              2441 TBL_REGPAIR:	.ascii	"B\000"
   EC89 44 00              2442 		.ascii	"D\000"
   EC8B 48 00              2443 		.ascii	"H\000"
   EC8D 53 50 00           2444 		.ascii	"SP\000"
   EC90 50 53 57 00        2445 		.ascii	"PSW\000"
                           2446 
                           2447 
   EC94 A1            [ 4] 2448 LS_SEARCH:	ANA	C		;Fetch Code (AND with bit mask)
   EC95 46            [ 4] 2449 		MOV	B,M		;Count of Elements
   EC96 23            [ 6] 2450 		INX	H
   EC97 BE            [ 7] 2451 LS_LP:		CMP	M
   EC98 C8            [12] 2452 		RZ
   EC99 19            [10] 2453 		DAD	D
   EC9A 05            [ 4] 2454 		DCR	B
   EC9B C2 97 EC      [10] 2455 		JNZ	LS_LP
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 49
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   EC9E 05            [ 4] 2456 		DCR	B		;RETURN WITH Z=0
   EC9F C9            [10] 2457 		RET
                           2458 
   ECA0 11                 2459 TBL_1A:		.DB	17		;COUNT OF TABLE ELEMENTS
   ECA1 EB                 2460 		.DB	0xEB
   ECA2 58 43 48 47        2461 		.ascii	"XCHG"
   ECA6 E3                 2462 		.DB	0xE3
   ECA7 58 54 48 4C        2463 		.ascii	"XTHL"
   ECAB F9                 2464 		.DB	0xF9
   ECAC 53 50 48 4C        2465 		.ascii	"SPHL"
   ECB0 E9                 2466 		.DB	0xE9
   ECB1 50 43 48 4C        2467 		.ascii	"PCHL"
   ECB5 07                 2468 		.DB	0x07
   ECB6 52 4C 43 20        2469 		.ascii	"RLC "
   ECBA 0F                 2470 		.DB	0x0F
   ECBB 52 52 43 20        2471 		.ascii	"RRC "
   ECBF 17                 2472 		.DB	0x17
   ECC0 52 41 4C 20        2473 		.ascii	"RAL "
   ECC4 1F                 2474 		.DB	0x1F
   ECC5 52 41 52 20        2475 		.ascii	"RAR "
   ECC9 2F                 2476 		.DB	0x2F
   ECCA 43 4D 41 20        2477 		.ascii	"CMA "
   ECCE 37                 2478 		.DB	0x37
   ECCF 53 54 43 20        2479 		.ascii	"STC "
   ECD3 3F                 2480 		.DB	0x3F
   ECD4 43 4D 43 20        2481 		.ascii	"CMC "
   ECD8 27                 2482 		.DB	0x27
   ECD9 44 41 41 20        2483 		.ascii	"DAA "
   ECDD FB                 2484 		.DB	0xFB
   ECDE 45 49 20 20        2485 		.ascii	"EI  "
   ECE2 F3                 2486 		.DB	0xF3
   ECE3 44 49 20 20        2487 		.ascii	"DI  "
   ECE7 00                 2488 		.DB	0x00
   ECE8 4E 4F 50 20        2489 		.ascii	"NOP "
   ECEC 76                 2490 		.DB	0x76
   ECED 48 4C 54 20        2491 		.ascii	"HLT "
   ECF1 C9                 2492 		.DB	0xC9
   ECF2 52 45 54 20        2493 		.ascii	"RET "
   ECF6 05                 2494 TBL_1C:		.DB	5		;COUNT OF TABLE ELEMENTS
   ECF7 C5                 2495 		.DB	0xC5
   ECF8 50 55 53 48        2496 		.ascii	"PUSH"
   ECFC C1                 2497 		.DB	0xC1
   ECFD 50 4F 50 20        2498 		.ascii	"POP "
   ED01 03                 2499 		.DB	0x03
   ED02 49 4E 58 20        2500 		.ascii	"INX "
   ED06 0B                 2501 		.DB	0x0B
   ED07 44 43 58 20        2502 		.ascii	"DCX "
   ED0B 09                 2503 		.DB	0x09
   ED0C 44 41 44 20        2504 		.ascii	"DAD "
   ED10 01                 2505 TBL_3C:		.DB	1		;COUNT OF TABLE ELEMENTS
   ED11 01                 2506 		.DB	0x01
   ED12 4C 58 49 20        2507 		.ascii	"LXI "
   ED16 08                 2508 TBL_1B:		.DB	8		;COUNT OF TABLE ELEMENTS
   ED17 80                 2509 		.DB	0x80
   ED18 41 44 44 20        2510 		.ascii	"ADD "
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 50
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   ED1C 88                 2511 		.DB	0x88
   ED1D 41 44 43 20        2512 		.ascii	"ADC "
   ED21 90                 2513 		.DB	0x90
   ED22 53 55 42 20        2514 		.ascii	"SUB "
   ED26 98                 2515 		.DB	0x98
   ED27 53 42 42 20        2516 		.ascii	"SBB "
   ED2B A0                 2517 		.DB	0xA0
   ED2C 41 4E 41 20        2518 		.ascii	"ANA "
   ED30 A8                 2519 		.DB	0xA8
   ED31 58 52 41 20        2520 		.ascii	"XRA "
   ED35 B0                 2521 		.DB	0xB0
   ED36 4F 52 41 20        2522 		.ascii	"ORA "
   ED3A B8                 2523 		.DB	0xB8
   ED3B 43 4D 50 20        2524 		.ascii	"CMP "
   ED3F 02                 2525 TBL_1D:		.DB	2		;COUNT OF TABLE ELEMENTS
   ED40 04                 2526 		.DB	0x04
   ED41 49 4E 52 20        2527 		.ascii	"INR "
   ED45 05                 2528 		.DB	0x05
   ED46 44 43 52 20        2529 		.ascii	"DCR "
   ED4A 02                 2530 TBL_1E:		.DB	2		;COUNT OF TABLE ELEMENTS
   ED4B 02                 2531 		.DB	0x02
   ED4C 53 54 41 58        2532 		.ascii	"STAX"
   ED50 0A                 2533 		.DB	0x0A
   ED51 4C 44 41 58        2534 		.ascii	"LDAX"
   ED55 0A                 2535 TBL_2A:		.DB	10		;COUNT OF TABLE ELEMENTS
   ED56 C6                 2536 		.DB	0xC6
   ED57 41 44 49 20        2537 		.ascii	"ADI "
   ED5B CE                 2538 		.DB	0xCE
   ED5C 41 43 49 20        2539 		.ascii	"ACI "
   ED60 D6                 2540 		.DB	0xD6
   ED61 53 55 49 20        2541 		.ascii	"SUI "
   ED65 DE                 2542 		.DB	0xDE
   ED66 53 42 49 20        2543 		.ascii	"SBI "
   ED6A E6                 2544 		.DB	0xE6
   ED6B 41 4E 49 20        2545 		.ascii	"ANI "
   ED6F EE                 2546 		.DB	0xEE
   ED70 58 52 49 20        2547 		.ascii	"XRI "
   ED74 F6                 2548 		.DB	0xF6
   ED75 4F 52 49 20        2549 		.ascii	"ORI "
   ED79 FE                 2550 		.DB	0xFE
   ED7A 43 50 49 20        2551 		.ascii	"CPI "
   ED7E DB                 2552 		.DB	0xDB
   ED7F 49 4E 20 20        2553 		.ascii	"IN  "
   ED83 D3                 2554 		.DB	0xD3
   ED84 4F 55 54 20        2555 		.ascii	"OUT "
   ED88 06                 2556 TBL_3D:		.DB	6		;COUNT OF TABLE ELEMENTS
   ED89 32                 2557 		.DB	0x32
   ED8A 53 54 41 20        2558 		.ascii	"STA "
   ED8E 3A                 2559 		.DB	0x3A
   ED8F 4C 44 41 20        2560 		.ascii	"LDA "
   ED93 22                 2561 		.DB	0x22
   ED94 53 48 4C 44        2562 		.ascii	"SHLD"
   ED98 2A                 2563 		.DB	0x2A
   ED99 4C 48 4C 44        2564 		.ascii	"LHLD"
   ED9D C3                 2565 		.DB	0xC3
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 51
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   ED9E 4A 4D 50 20        2566 		.ascii	"JMP "
   EDA2 CD                 2567 		.DB	0xCD
   EDA3 43 41 4C 4C        2568 		.ascii	"CALL"
   EDA7 03                 2569 TBL_3B:		.DB	3		;COUNT OF TABLE ELEMENTS
   EDA8 C2                 2570 		.DB	0xC2
   EDA9 4A                 2571 		.ascii	"J"
   EDAA C4                 2572 		.DB	0xC4
   EDAB 43                 2573 		.ascii	"C"
   EDAC C0                 2574 		.DB	0xC0
   EDAD 52                 2575 		.ascii	"R"
                           2576 
                           2577 
                           2578 ;----------------------------------------------------------------------------------------------------; CP/M BIOS
                           2579 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2580 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2581 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2582 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2583 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2584 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2585 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2586 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2587 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2588 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2589 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2590 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2591 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2592 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2593 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2594 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2595 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           2596 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           2597 ;----------------------------------------------------------------------------------------------------; CP/M BIOS
                           2598 
                           2599 
                           2600 
                           2601 ;***************************************************
                           2602 ;*** THIS BEGINS THE AREA WHICH REQUIRES CHANGES ***
                           2603 ;***      FOR DIFFERENT CONSOLE I/O SYSTEMS      ***
                           2604 ;***************************************************
                           2605 
                     003D  2606 MSIZE		.EQU  61	;MEMORY SIZE IN KBYTES.
                           2607 
                           2608 ;*******************************************************
                           2609 ;*** THIS IS THE END OF THE AREA WHICH NORMALLY NEED ***
                           2610 ;***     BE CHANGED FOR MOST CONSOLE I/O SYSTEMS     ***
                           2611 ;*******************************************************
                           2612 
                     0003  2613 IOBYTE		.EQU  3		;ADDRESS OF I/O BYTE.
                     D800  2614 CCP		.EQU  (MSIZE-7)*1024	;START OF CPM (D800)
                     E006  2615 BDOS		.EQU  CCP+0x0806		;START OF BDOS (E006)
                     EE00  2616 BIOS		.EQU  CCP+0x1600		;START OF BIOS (EE00)
                     1600  2617 CPMLEN		.EQU  BIOS-CCP		;LENGTH OF CPM SYSTEM (LESS BIOS)
                     002C  2618 NSECTS		.EQU  CPMLEN/128	;NUMBER OF SECTORS IN IT.
                           2619 
                           2620 ;       Page Zero Definitions.
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 52
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                     0003  2621 IOBYTE		.EQU	3		;Location of IOBYTE
                     0004  2622 CDISK		.EQU	4		;Location of current disk
                     0040  2623 BIORAM		.EQU	0x40		;16 ram cells
                     0040  2624 OPTS		.EQU	BIORAM		;GBC DISK1 board switch options
                           2625 ;			BIORAM+1	;GBC (cell before TICK)
                     0042  2626 TICK		.EQU	BIORAM+2	;GBC Sample period
                     0080  2627 DBUF		.EQU	0x80		;Default sector buffer
                           2628 
   EE00                    2629 		.ORG	BIOS
                           2630 
                           2631 ; I/O JUMP VECTOR
                           2632 ; THIS IS WHERE CP/M CALLS WHENEVER IT NEEDS
                           2633 ; TO DO ANY INPUT/OUTPUT OPERATION.
                           2634 ; USER PROGRAMS MAY USE THESE ENTRY POINTS
                           2635 ; ALSO, BUT NOTE THAT THE LOCATION OF THIS
                           2636 ; VECTOR CHANGES WITH THE MEMORY SIZE.
                           2637 ;
   EE00 C3 BB EE      [10] 2638 CBOOTV:	JMP  	CBOOT	;FROM COLD START LOADER.
   EE03 C3 F0 EE      [10] 2639 WBOOTV:	JMP  	WBOOT	;FROM WARM BOOT.
   EE06 C3 4E EF      [10] 2640 CONSTV:	JMP  	CONST	;CHECK CONSOLE KB STATUS.
   EE09 C3 65 EF      [10] 2641 	JMP  	CONIN	;READ CONSOLE CHARACTER.
   EE0C C3 71 EF      [10] 2642 	JMP  	CONOT	;WRITE CONSOLE CHARACTER.
   EE0F C3 8F EF      [10] 2643 	JMP  	LIST	;WRITE LISTING CHAR.
   EE12 C3 9A EF      [10] 2644 	JMP  	PUNCH	;WRITE PUNCH CHAR.
   EE15 C3 9B EF      [10] 2645 	JMP  	READER	;READ READER CHAR.
   EE18 C3 BC EF      [10] 2646 	JMP  	HOME	;MOVE DISK TO TRACK ZERO.
   EE1B C3 9D EF      [10] 2647 SELDSKV:	JMP  	SELDSK	;SELECT DISK DRIVE.
   EE1E C3 BE EF      [10] 2648 	JMP  	SETTRK	;SEEK TO TRACK IN REG A.
   EE21 C3 C5 EF      [10] 2649 	JMP  	SETSEC	;SET SECTOR NUMBER.
   EE24 C3 CB EF      [10] 2650 SETDMAV:	JMP  	SETDMA	;SET DISK STARTING ADR.
   EE27 C3 D6 EF      [10] 2651 	JMP  	DREAD	;READ SELECTED SECTOR.
   EE2A C3 FE EF      [10] 2652 	JMP  	DWRITE	;WRITE SELECTED SECTOR.
   EE2D C3 9C EF      [10] 2653 	JMP  	LISTST	;List status (output)
   EE30 C3 D3 EF      [10] 2654 	JMP  	SECTRN	;Translate sector number
                           2655 
                           2656 					;My own BIOS routine entries
   EE33 C3 AA F0      [10] 2657 	JMP  	GET_CHAR_UART
   EE36 C3 D8 F0      [10] 2658 	JMP  	GET_CHAR
   EE39 C3 EB F0      [10] 2659 	JMP  	PUT_CHAR
   EE3C C3 2E F1      [10] 2660 	JMP  	GET_CHAR_NE
                           2661 
                           2662 
                     0004  2663 NDSK	.EQU	4
                           2664 
                           2665 ;	Control Blocks for disk drives
                           2666 
   EE3F 00 00 00 00 00 00  2667 DPBASE:	.DW	SKEW,0,0,0,DIRBUF,DPB0,CSV0,ALV0	;Drive A:
        00 00 00 FA 7F EE
        9F FA 80 FA
   EE4F 00 00 00 00 00 00  2668 	.DW	SKEW,0,0,0,DIRBUF,DPB1,CSV1,ALV1	;Drive B:
        00 00 00 FA 8E EE
        CE FA AF FA
   EE5F 00 00 00 00 00 00  2669 	.DW	SKEW,0,0,0,DIRBUF,DPB2,CSV2,ALV2	;Drive C:
        00 00 00 FA 9D EE
        FD FA DE FA
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 53
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   EE6F 00 00 00 00 00 00  2670 	.DW	SKEW,0,0,0,DIRBUF,DPB3,CSV3,ALV3	;Drive D:
        00 00 00 FA AC EE
        2C FB 0D FB
                           2671 
                           2672 ;SKEW:	.DB 	01, 07, 13, 19, 25, 05, 11, 17, 23, 03, 09, 15, 21, 02, 08, 14, 20, 26, 06, 12, 18, 24, 04, 10, 16, 22
                     0000  2673 SKEW	.equ	0
                           2674 
                           2675 ;       Disk type definition blocks for each particular mode.
   EE7F 1A 00              2676 DPB0:	.DW	26		;SEC PER TRACK
   EE81 03                 2677 	.DB	3		;BLOCK SHIFT
   EE82 07                 2678 	.DB	7		;BLOCK MASK
   EE83 00                 2679 	.DB	0		;EXTNT MASK
   EE84 F2 00              2680 	.DW	242		;DISK SIZE-1
   EE86 3F 00              2681 	.DW	63		;DIRECTORY MAX
   EE88 C0                 2682 	.DB	0b11000000	;ALLOC0
   EE89 00                 2683 	.DB	0b00000000	;ALLOC1
   EE8A 10 00              2684 	.DW	16		;CHECK SIZE
   EE8C 02 00              2685 	.DW	2		;OFFSET
                           2686 
   EE8E 1A 00              2687 DPB1:	.DW	26		;SEC PER TRACK
   EE90 03                 2688 	.DB	3		;BLOCK SHIFT
   EE91 07                 2689 	.DB	7		;BLOCK MASK
   EE92 00                 2690 	.DB	0		;EXTNT MASK
   EE93 F2 00              2691 	.DW	242		;DISK SIZE-1
   EE95 3F 00              2692 	.DW	63		;DIRECTORY MAX
   EE97 C0                 2693 	.DB	0b11000000	;ALLOC0
   EE98 00                 2694 	.DB	0b00000000	;ALLOC1
   EE99 10 00              2695 	.DW	16		;CHECK SIZE
   EE9B 02 00              2696 	.DW	2		;OFFSET
                           2697 
   EE9D 1A 00              2698 DPB2:	.DW	26		;SEC PER TRACK
   EE9F 03                 2699 	.DB	3		;BLOCK SHIFT
   EEA0 07                 2700 	.DB	7		;BLOCK MASK
   EEA1 00                 2701 	.DB	0		;EXTNT MASK
   EEA2 F2 00              2702 	.DW	242		;DISK SIZE-1
   EEA4 3F 00              2703 	.DW	63		;DIRECTORY MAX
   EEA6 C0                 2704 	.DB	0b11000000	;ALLOC0
   EEA7 00                 2705 	.DB	0b00000000	;ALLOC1
   EEA8 10 00              2706 	.DW	16		;CHECK SIZE
   EEAA 02 00              2707 	.DW	2		;OFFSET
                           2708 
   EEAC 1A 00              2709 DPB3:	.DW	26		;SEC PER TRACK
   EEAE 03                 2710 	.DB	3		;BLOCK SHIFT
   EEAF 07                 2711 	.DB	7		;BLOCK MASK
   EEB0 00                 2712 	.DB	0		;EXTNT MASK
   EEB1 F2 00              2713 	.DW	242		;DISK SIZE-1
   EEB3 3F 00              2714 	.DW	63		;DIRECTORY MAX
   EEB5 C0                 2715 	.DB	0b11000000	;ALLOC0
   EEB6 00                 2716 	.DB	0b00000000	;ALLOC1
   EEB7 10 00              2717 	.DW	16		;CHECK SIZE
   EEB9 02 00              2718 	.DW	2		;OFFSET
                           2719 
                           2720 		;Amstrad 1.44M disk
                           2721 ;DPB33:	.DW	48h		;SEC PER TRACK
                           2722 ;	.DB	5		;BLOCK SHIFT = 4K Block size
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 54
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           2723 ;	.DB	0x1f		;BLOCK MASK
                           2724 ;	.DB	1		;EXTNT MASK
                           2725 ;	.DW	164H		;DISK SIZE-1
                           2726 ;	.DW	0ffh		;DIRECTORY MAX
                           2727 ;	.DB	0c0h		;ALLOC0
                           2728 ;	.DB	00		;ALLOC1
                           2729 ;	.DW	0x40		;CHECK SIZE
                           2730 ;	.DW	1		;OFFSET
                           2731 
                           2732 ;3.5" DSDD    80*2*18*512 = 1,474,560   1.44M
                           2733 ;5"   DSHD    80*2*15*512 = 1,228,800   1.2 M
                           2734 ;5"   DSDD    40*2* 9*512 = 368,640      360K
                           2735 ;5"   DSDD    40*2* 8*512 = 327,680      320K
                           2736 ;5"   DSDD    40*2*10*512 = 409,600      400K
                           2737 ;5"   DSSD    40*2*18*128 = 184,320      180K
                           2738 ;8"   DSDD    77*2*8*1024 = 1,261,568   1232K
                           2739 ;8"   SSDD    77*1*8*1024 = 630,784      616K
                           2740 ;8"   DSDD    77*2*15*512 = 1,182,720   1155K
                           2741 ;8"   DSDD    77*2*26*256 = 1,025,024   1001K
                           2742 ;8"   SSSD    77*1*26*128 = 256,256      250K
                           2743 
                           2744 
                           2745 ;       B O O T   C P / M   f r o m   d i s k.
                           2746 ;
                           2747 ;       The CBOOT entry point gets control from the cold start
                           2748 ;       loader and is responsible for the basic system initial-
                           2749 ;       ization.  This includes outputting a sign-on message and
                           2750 ;       initializing the following page zero locations:
                           2751 ;
                           2752 ;          0,1,2: Set to the warmstart jump vector.
                           2753 ;              3: Set to the initial IOBYTE value.
                           2754 ;              4: Default and logged on drive.
                           2755 ;          5,6,7: Set to a jump to BDOS.
                           2756 ;             40: (Set by BOOT) Board switch options.
                           2757 ;
                           2758 ;       If BANG is true (DISK1 bit serial latch is to be supported), then
                           2759 ;       board switch option I means to use the BitBanger for console I/O.
                           2760 ;       Register C must contain the selected drive, which is zero to
                           2761 ;       select the A drive.  The exit address is to the CCP routine.
                           2762 ;
                           2763 ;
                           2764 ;       The WBOOT entry point gets control when a warm start occurs,
                           2765 ;       a ^C from the console, a jump to BDOS (function 0), or a jump to
                           2766 ;       location zero.  The WBOOT routine reads the CCP and BDOS from the
                           2767 ;       appropriate disk sectors.  WBOOT must also re-initialize locations
                           2768 ;       0,1,2 and 5,6,7.  The WBOOT routines exits with the C register set
                           2769 ;       to the appropriate drive selection value.  The exit address is to
                           2770 ;       the CCP routine.
                           2771 ;
   EEBB 31 00 FD      [10] 2772 CBOOT:	LXI  SP,HIGHSTACK	;SET STACK POINTER.
   EEBE CD 98 F0      [18] 2773 	CALL PRINTI
   EEC1 0D 0A 41 4C 54 41  2774 	.ascii "\r\nALTAIR/IMSAI CPU CARD. "
        49 52 2F 49 4D 53
        41 49 20 43 50 55
        20 43 41 52 44 2E
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 55
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



        20
   EEDA 36 31              2775 	.DB   (MSIZE / 10) + "0", (MSIZE % 10) + "0"
   EEDC 4B 20 43 50 2F 4D  2776 	.ascii "K CP/M 2.2\r\n\000"
        20 32 2E 32 0D 0A
        00
                           2777 
   EEE9 AF            [ 4] 2778         XRA     A
   EEEA 32 04 00      [13] 2779         STA     CDISK           ;Force A drive
   EEED 32 03 00      [13] 2780         STA     IOBYTE          ;Clear I/O byte
                           2781 
                           2782 ; WARM-BOOT:  READ ALL OF CPM BACK IN
                           2783 ; EXCEPT BIOS, THEN JUMP TO CCP.
                           2784 ;
   EEF0 31 00 FD      [10] 2785 WBOOT:	LXI  SP,HIGHSTACK	;SET STACK POINTER.
                           2786 
   EEF3 CD 98 F0      [18] 2787 	CALL PRINTI
   EEF6 0D 0A 57 42 4F 4F  2788 	.ascii "\r\nWBOOT\r\n\000"
        54 0D 0A 00
                           2789 
                           2790         		      ;Boot CP/M
                           2791 
   EF00 3A 04 00      [13] 2792 	LDA  CDISK	;SAVE DISK NUMBER.
   EF03 32 EA FD      [13] 2793 	STA  TEMP
   EF06 0E 00         [ 7] 2794 	MVI	C,0	;Set DISK A
   EF08 CD 1B EE      [18] 2795 	CALL	SELDSKV
                           2796 
   EF0B 11 00 D8      [10] 2797 	LXI	D,CCP		;Save destination address
   EF0E 06 2C         [ 7] 2798 	MVI	B,NSECTS
   EF10 21 01 00      [10] 2799 	LXI	H,1
   EF13 22 99 FD      [16] 2800 WBLP:	SHLD	LOGICAL_SEC	;Set first sector to read from disk
   EF16 C5            [12] 2801 	PUSH	B
   EF17 D5            [12] 2802 	PUSH	D
   EF18 CD C7 F1      [18] 2803 	CALL	DISK_READ	;HL = Quarter Buffer
   EF1B D1            [10] 2804 	POP	D
   EF1C 06 80         [ 7] 2805 	MVI	B,128
   EF1E CD E2 F8      [18] 2806 	CALL	COPY_RAM	;Copy the SD_RAM_BUFFER to CP/M
   EF21 2A 99 FD      [16] 2807 	LHLD	LOGICAL_SEC	;Set first sector to read from disk
   EF24 23            [ 6] 2808 	INX	H
   EF25 C1            [10] 2809 	POP	B
   EF26 05            [ 4] 2810 	DCR	B
   EF27 C2 13 EF      [10] 2811 	JNZ	WBLP
                           2812 
                           2813 ; SET UP JUMPS IN CP/M PAGE ZERO.
                           2814 
   EF2A 01 80 00      [10] 2815 	LXI  B,DBUF	;SET DEFAULT DMA ADR.
   EF2D CD 24 EE      [18] 2816 	CALL SETDMAV
   EF30 3E C3         [ 7] 2817 	MVI  A,0xC3	;PUT JMP TO WBOOT
   EF32 32 00 00      [13] 2818 	STA  0		;ADR AT ZERO.
   EF35 32 05 00      [13] 2819 	STA  5
   EF38 21 03 EE      [10] 2820 	LXI  H,WBOOTV
   EF3B 22 01 00      [16] 2821 	SHLD 1
   EF3E 21 06 E0      [10] 2822 	LXI  H,BDOS	;PUT JUMP TO BDOS
   EF41 22 06 00      [16] 2823 	SHLD 6		;AT ADR 5,6,7.
                           2824 
   EF44 3A EA FD      [13] 2825 	LDA  TEMP
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 56
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   EF47 32 04 00      [13] 2826 	STA  CDISK
   EF4A 4F            [ 4] 2827         MOV  C,A
   EF4B C3 00 D8      [10] 2828         JMP  CCP             ;Go to CPM
                           2829 
                           2830 
                           2831 ;===============================================
                           2832 ;       C O N S O L   S T A T U S
                           2833 ;
                           2834 ;       This routine samples the Console status and
                           2835 ;       returns the following values in the A register.
                           2836 ;
                           2837 ;       EXIT    A = 0 (zero), means no character
                           2838 ;               currently ready to read.
                           2839 ;
                           2840 ;               A = FFh (255), means character
                           2841 ;               currently ready to read.
                           2842 ;-----------------------------------------------
   EF4E DB 25         [10] 2843 CONST:		IN	UART0+5 ;10	TEST FOR RX DATA
   EF50 E6 01         [ 7] 2844 		ANI	1	;7
   EF52 CA 58 EF      [10] 2845 		JZ	CONST_0	;10
   EF55 F6 FF         [ 7] 2846 		ORI	0xFF
   EF57 C9            [10] 2847 		RET		;10
                           2848 
   EF58 3A 82 FD      [13] 2849 CONST_0:		LDA	PROP_CHECK
   EF5B B7            [ 4] 2850 		ORA	A
   EF5C C8            [12] 2851 		RZ
                           2852 
   EF5D DB 00         [10] 2853 		IN	PROPELLERS
   EF5F E6 02         [ 7] 2854 		ANI	2
   EF61 C8            [12] 2855 		RZ
   EF62 F6 FF         [ 7] 2856 		ORI	0xFF
   EF64 C9            [10] 2857 		RET
                           2858 
                           2859 
                           2860 ;===============================================
                           2861 ;       C O N S O L   I N P U T
                           2862 ;
                           2863 ;       Read the next character into the A register, clearing the high
                           2864 ;       order bit.  If no character currently ready to read then wait
                           2865 ;       for a character to arrive before returning.
                           2866 ;
                           2867 ;       EXIT    A = character read from terminal.
                           2868 ;-----------------------------------------------
   EF65 CD 2E F1      [18] 2869 CONIN:	CALL	GET_CHAR_NE	;Get Char No Echo
   EF68 E6 7F         [ 7] 2870 	ANI  0x7F	;MAKE MOST SIG. BIT = 0.
   EF6A FE 7F         [ 7] 2871 	CPI  0x7F	;IS IT A RUBOUT?
   EF6C C0            [12] 2872 	RNZ		;RETURN IF NOT.
   EF6D 32 80 FD      [13] 2873 	STA  CONOTF	;SET NO PRINT FLAG.
   EF70 C9            [10] 2874 	RET		;RETURN FROM CONIN.
                           2875 
                           2876 ;===============================================
                           2877 ;       C O N S O L   O U T P U T
                           2878 ;
                           2879 ;       Send a character to the console.  If the console is not ready to
                           2880 ;       receive a character wait until the console is ready.
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 57
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           2881 ;
                           2882 ;       ENTRY   C = ASCII character to output to console.
                           2883 ;-----------------------------------------------
   EF71 79            [ 4] 2884 CONOT:	MOV  A,C	;GET CHARACTER.
   EF72 FE 7F         [ 7] 2885 	CPI  0x7F	;IS IT A RUBOUT?
   EF74 C8            [12] 2886 	RZ		;IF SO, DON'T PRINT IT.
   EF75 3A 80 FD      [13] 2887 	LDA  CONOTF	;GET NO PRINT FLAG.
   EF78 B7            [ 4] 2888 	ORA  A		;SET CPU FLAGS.
   EF79 CA 8A EF      [10] 2889 	JZ   CONOTA	;NOT SET, SO PRINT.
   EF7C AF            [ 4] 2890 	XRA  A		;RESET THE FLAG
   EF7D 32 80 FD      [13] 2891 	STA  CONOTF	;TO ZERO.
   EF80 0E 08         [ 7] 2892 	MVI  C,8	;PRINT BACKSPACE.
   EF82 CD 8A EF      [18] 2893 	CALL CONOTA
   EF85 3E 20         [ 7] 2894 	MVI  A,0x20	;PRINT SPACE.
   EF87 CD EB F0      [18] 2895 	CALL PUT_CHAR
                           2896 			;ANOTHER BACKSPACE.
   EF8A 79            [ 4] 2897 CONOTA:	MOV  A,C	;GET CHARACTER.
   EF8B CD EB F0      [18] 2898 	CALL PUT_CHAR	;PRINT IT.
   EF8E C9            [10] 2899 	RET		;RETURN.
                           2900 
                           2901 
                           2902 ;
                           2903 ; WRITE A CHARACTER ON LISTING DEVICE.
                           2904 ;
   EF8F                    2905 LIST:
                           2906 
   EF8F DB 2D         [10] 2907 LTBSY:	IN	UART1+5
   EF91 E6 20         [ 7] 2908 	ANI	0x20	;TEST FOR TX HOLD REG EMPTY
   EF93 CA 8F EF      [10] 2909 	JZ	LTBSY
                           2910 
   EF96 79            [ 4] 2911 	MOV  A,C	;GET DATA BYTE.
   EF97 D3 28         [10] 2912 	OUT	UART1	;PRINT IT.
   EF99 C9            [10] 2913 	RET		;RETURN FROM LIST.
                           2914 
                           2915 
                           2916 ;
                           2917 ; PUNCH PAPER TAPE.
                           2918 ;
   EF9A C9            [10] 2919 PUNCH:	RET		;RETURN FROM PUNCH.
                           2920 
                           2921 ;
                           2922 ;  NORMALLY USED TO READ PAPER TAPE.
                           2923 ;
   EF9B C9            [10] 2924 READER:	RET		;RETURN FROM READER.
                           2925 
   EF9C C9            [10] 2926 LISTST:	RET
                           2927 
                           2928 
                           2929 ;       S E L E C T   D I S K   D R I V E
                           2930 ;
                           2931 ;       Select the disk drive for subsequent disk transfers and
                           2932 ;       return the appropriate DPH address.
                           2933 ;
                           2934 ;       ENTRY   C = disk Selection value.
                           2935 ;
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 58
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           2936 ;       EXIT    HL = 0, if drive not selectable.
                           2937 ;               HL = DPH address if drive is selectable.
                           2938 ;
   EF9D 21 00 00      [10] 2939 SELDSK:	LXI  H,0
   EFA0 79            [ 4] 2940 	MOV  A,C	;GET NEW DISK NUMBER.
   EFA1 FE 04         [ 7] 2941 	CPI  NDSK
   EFA3 D0            [12] 2942 	RNC		;If Disk invalid...EXIT
                           2943 
                           2944 
                     0000  2945 .if (DEBUG & 0x80)
                           2946    CALL SELECT_UART1
                           2947 .endif
                     0000  2948 .if (DEBUG & 1)
                           2949 	CALL PRINTI		;DEBUG
                           2950 	.ascii " :SEL\000"
                           2951 	CALL	PUT_BYTE
                           2952 .endif
                     0000  2953 .if (DEBUG & 0x80)
                           2954    CALL SELECT_UART0
                           2955 .endif
                           2956 
   EFA4 C5            [12] 2957 	PUSH B
   EFA5 D5            [12] 2958 	PUSH D
   EFA6 CD 38 F1      [18] 2959 	CALL SET_FCB_PTR ;Set the FCB PTR for the correct SD File & HL = DPBASE[A] (or 0000 if drive not exist)
   EFA9 D1            [10] 2960 	POP  D
   EFAA E5            [12] 2961 	PUSH H
   EFAB 01 0A 00      [10] 2962 	LXI  B,10
   EFAE 09            [10] 2963 	DAD  B
   EFAF CD EB F8      [18] 2964 	CALL LD_HL_HL
   EFB2 CD EB F8      [18] 2965 	CALL LD_HL_HL
   EFB5 22 85 FD      [16] 2966 	SHLD SEC_PER_TRACK
                           2967 
                           2968 
                     0000  2969 .if (DEBUG & 0x80)
                           2970    CALL SELECT_UART1
                           2971 .endif
                     0000  2972 .if (DEBUG & 1)
                           2973 	CALL PRINTI		;DEBUG
                           2974 	.ascii " :SPT\000"
                           2975 	CALL	PUT_HL
                           2976 .endif
                     0000  2977 .if (DEBUG & 0x80)
                           2978    CALL SELECT_UART0
                           2979 .endif
                           2980 
   EFB8 E1            [10] 2981 	POP  H
   EFB9 C1            [10] 2982 	POP  B
   EFBA AF            [ 4] 2983 	XRA  A		;SET A = 0.
   EFBB C9            [10] 2984 	RET		;RETURN FROM SELDSK.
                           2985 
                           2986 
                           2987 ; MOVE DISK TO TRACK ZERO.
                           2988 ;
   EFBC 0E 00         [ 7] 2989 HOME:	MVI  C,0	;SEEK TO TRACK ZERO.
                           2990 
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 59
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           2991 ;
                           2992 ; SET TRACK NUMBER TO WHATEVER IS IN REGISTER C.
                           2993 ; ALSO PERFORM MOVE TO THE CORRECT TRACK (SEEK).
                           2994 ;
   EFBE 60            [ 4] 2995 SETTRK:	MOV  H,B	;GET NEW TRACK NUMBER.
   EFBF 69            [ 4] 2996 	MOV  L,C	;MOVE B&C TO H&L.
   EFC0 22 E4 FD      [16] 2997 	SHLD  TRK	;UPDATE OLD WITH NEW.
                           2998 
                           2999 ; MOVE THE HEAD TO THE TRACK IN REGISTER A.
                           3000 
                           3001 
                     0000  3002 .if (DEBUG & 0x80)
                           3003    CALL SELECT_UART1
                           3004 .endif
                     0000  3005 .if (DEBUG & 1)
                           3006 	CALL PRINTI		;DEBUG
                           3007 	.ascii " :TRK\000"
                           3008 	CALL	PUT_HL
                           3009 .endif
                     0000  3010 .if (DEBUG & 0x80)
                           3011    CALL SELECT_UART0
                           3012 .endif
                           3013 
                           3014 
   EFC3 AF            [ 4] 3015 	XRA  A		;Clear flags
   EFC4 C9            [10] 3016 	RET		;RETURN FROM SEEK.
                           3017 
                           3018 ;
                           3019 ; SET DISK SECTOR NUMBER.
                           3020 ;
   EFC5 79            [ 4] 3021 SETSEC:	MOV  A,C	;GET SECTOR NUMBER.
   EFC6 32 E6 FD      [13] 3022 	STA  SECT	;PUT AT SECT # ADDRESS.
                           3023 
                           3024 
                           3025 
                     0000  3026 .if (DEBUG & 0x80)
                           3027    CALL SELECT_UART1
                           3028 .endif
                     0000  3029 .if (DEBUG & 1)
                           3030 	CALL PRINTI		;DEBUG
                           3031 	.ascii " :SEC\000"
                           3032 	CALL	PUT_BYTE
                           3033 .endif
                     0000  3034 .if (DEBUG & 0x80)
                           3035    CALL SELECT_UART0
                           3036 .endif
                           3037 
                           3038 
   EFC9 AF            [ 4] 3039 	XRA  A		;Clear flags
   EFCA C9            [10] 3040 	RET		;RETURN FROM SETSEC.
                           3041 ;
                           3042 ; SET DISK DMA ADDRESS.
                           3043 ;
   EFCB E5            [12] 3044 SETDMA:	PUSH H
   EFCC 60            [ 4] 3045 	MOV  H,B	;MOVE B&C TO H&L.
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 60
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   EFCD 69            [ 4] 3046 	MOV  L,C
   EFCE 22 E7 FD      [16] 3047 	SHLD DMAADD	;PUT AT DMA ADR ADDRESS.
   EFD1 E1            [10] 3048 	POP  H
   EFD2 C9            [10] 3049 	RET		;RETURN FROM SETDMA.
                           3050 
                           3051 
                           3052 ;       Translate sector number from logical to physical.
                           3053 ;
                           3054 ;       ENTRY   DE = 0, no translation required.
                           3055 ;               DE = translation table address.
                           3056 ;               BC = sector number to translate.
                           3057 ;
                           3058 ;       EXIT    HL = translated sector.
                           3059 
   EFD3 69            [ 4] 3060 SECTRN:	MOV     L,C	;No Translation
   EFD4 60            [ 4] 3061 	MOV     H,B
   EFD5 C9            [10] 3062 	RET
                           3063 
                           3064 	;CALL PRINTI		;DEBUG
                           3065 	;.ascii " :TR-\000"
                           3066 	;CALL	PUT_BC
                           3067 	;CALL	PUT_DE
                           3068 
                           3069 	;XCHG	;HL=DE
                           3070 	;DAD B	;HL=DE + BC
                           3071 	;MOV L,M ;A=M(HL)
                           3072 	;MVI H,0
                           3073 	;DCR L
                           3074 	;RET
                           3075 
                           3076 
                           3077 
                           3078 
                           3079 
                           3080 
                           3081 ;
                           3082 ; READ THE SECTOR AT SECT, FROM THE PRESENT DISK/TRACK/SSECT.
                           3083 ; USE STARTING ADDRESS AT DMAADD.
                           3084 ;
   EFD6 E5            [12] 3085 DREAD:	PUSH	H	;Save HL
   EFD7 21 00 00      [10] 3086 	LXI	H,0
   EFDA 39            [10] 3087 	DAD	SP	;HL = SP
   EFDB 31 00 FA      [10] 3088 	LXI	SP,TEMP_STACK
   EFDE E5            [12] 3089 	PUSH	H	;Save SP on new stack
                           3090 
   EFDF C5            [12] 3091 	PUSH	B
   EFE0 D5            [12] 3092 	PUSH	D
   EFE1 CD 26 F0      [18] 3093 	CALL 	GETLOG	;Fetch Logical FSector of requested read
                           3094 
                           3095 
                     0000  3096 .if (DEBUG & 0x80)
                           3097    CALL SELECT_UART1
                           3098 .endif
                     0000  3099 .if (DEBUG & 1)
                           3100 	CALL PRINTI		;DEBUG
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 61
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           3101 	.ascii " :DR\000"
                           3102 	CALL	PUT_HL
                           3103 .endif
                     0000  3104 .if (DEBUG & 0x80)
                           3105    CALL SELECT_UART0
                           3106 .endif
                           3107 
                           3108 
                           3109 	;LXI	D,-2002
                           3110 	;DAD	D
                           3111 	;JC	DREADE
                           3112 
   EFE4 CD C7 F1      [18] 3113 	CALL	DISK_READ	;HL = Quarter Buffer
   EFE7 EB            [ 4] 3114 	XCHG
   EFE8 2A E7 FD      [16] 3115 	LHLD	DMAADD	;Destination, CP/M Data Buffer
   EFEB EB            [ 4] 3116 	XCHG
   EFEC 06 80         [ 7] 3117 	MVI	B,128
   EFEE CD E2 F8      [18] 3118 	CALL	COPY_RAM	;Copy the SD_RAM_BUFFER to CP/M DMAADD
   EFF1 AF            [ 4] 3119 	XRA  A		;SET FLAGS.
   EFF2 C3 F8 EF      [10] 3120 	JMP	DREADX
                           3121 
   EFF5 3E 01         [ 7] 3122 DREADE:	MVI	A,1	;ERROR
   EFF7 B7            [ 4] 3123 	ORA	A
                           3124 
   EFF8 D1            [10] 3125 DREADX:	POP	D
   EFF9 C1            [10] 3126 	POP	B
   EFFA E1            [10] 3127 	POP	H	;Restore Stack Pointer
   EFFB F9            [ 6] 3128 	SPHL
   EFFC E1            [10] 3129 	POP	H	;Restore HL
   EFFD C9            [10] 3130 	RET
                           3131 
                           3132 
                           3133 
                           3134 ;
                           3135 ; WRITE THE SECTOR AT SECT, ON THE PRESENT TRACK.
                           3136 ; USE STARTING ADDRESS AT DMAADD.
                           3137 ;
   EFFE E5            [12] 3138 DWRITE:	PUSH	H	;Save HL
   EFFF 21 00 00      [10] 3139 	LXI	H,0
   F002 39            [10] 3140 	DAD	SP	;HL = SP
   F003 31 00 FA      [10] 3141 	LXI	SP,TEMP_STACK
   F006 E5            [12] 3142 	PUSH	H	;Save SP on new stack
                           3143 
   F007 F5            [12] 3144 	PUSH	PSW
   F008 C5            [12] 3145 	PUSH	B
   F009 D5            [12] 3146 	PUSH	D
   F00A CD 26 F0      [18] 3147 	CALL 	GETLOG	;Fetch Logical FSector of requested write
                           3148 			;DISK_READ will find the right Cluster/File sector *AND* Flush any previous writes.
                           3149 
                           3150 
                     0000  3151 .if (DEBUG & 0x80)
                           3152    CALL SELECT_UART1
                           3153 .endif
                     0000  3154 .if (DEBUG & 1)
                           3155 	CALL PRINTI		;DEBUG
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 62
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           3156 	.ascii " :DW\000"
                           3157 	CALL	PUT_HL
                           3158 .endif
                     0000  3159 .if (DEBUG & 0x80)
                           3160    CALL SELECT_UART0
                           3161 .endif
                           3162 
                           3163 
   F00D CD C7 F1      [18] 3164 	CALL	DISK_READ	;HL = Quarter Buffer
   F010 EB            [ 4] 3165 	XCHG
   F011 2A E7 FD      [16] 3166 	LHLD	DMAADD		;Source, CP/M Data Buffer
   F014 06 80         [ 7] 3167 	MVI	B,128
   F016 CD E2 F8      [18] 3168 	CALL	COPY_RAM	;Copy the SD_RAM_BUFFER to CP/M DMAADD
   F019 3E FF         [ 7] 3169 	MVI	A,0xFF
   F01B 32 D7 FD      [13] 3170 	STA	DIRTY_DATA
   F01E D1            [10] 3171 	POP	D
   F01F C1            [10] 3172 	POP	B
   F020 F1            [10] 3173 	POP	PSW
   F021 AF            [ 4] 3174 	XRA  A		;SET FLAGS.
   F022 E1            [10] 3175 	POP	H	;Restore Stack Pointer
   F023 F9            [ 6] 3176 	SPHL
   F024 E1            [10] 3177 	POP	H	;Restore HL
   F025 C9            [10] 3178 	RET
                           3179 
                           3180 ; Return Logical Disk Sector based on TRACK and SECTOR
                           3181 ; Track starts at 0 for first track
                           3182 ; Sector starts at 0 for first sector
                           3183 ;
   F026 2A E4 FD      [16] 3184 GETLOG:	LHLD  TRK	;HL = TRK
                           3185 
                           3186 
                           3187 ;-------------------------------------	Multiply Routine.  16bit by 8 bit -> 24bit
                           3188 					;HL = 16bit input
   F029 11 00 00      [10] 3189 		LXI	D,0		;DE = 16bit output
   F02C 06 08         [ 7] 3190 		MVI	B,8		;Go through 8 bits
   F02E 3A 85 FD      [13] 3191 		LDA	SEC_PER_TRACK	;Fetch Multiplier
   F031 1F            [ 4] 3192 GL_LP:		RAR
   F032 D2 38 F0      [10] 3193 		JNC	GL_SHIFT
   F035 EB            [ 4] 3194 		XCHG
   F036 19            [10] 3195 		DAD	D		;DE=DE+HL
   F037 EB            [ 4] 3196 		XCHG
                           3197 
   F038 29            [10] 3198 GL_SHIFT:	DAD	H		;BHL=BHL*2
   F039 05            [ 4] 3199 		DCR	B		;Count down 8 bits
   F03A C2 31 F0      [10] 3200 		JNZ	GL_LP
                           3201 
                           3202 
                           3203 
   F03D 26 00         [ 7] 3204 	MVI  H,0
   F03F 3A E6 FD      [13] 3205 	LDA  SECT
                           3206 	;DCR  A		;Option for Sector to start at 1
   F042 6F            [ 4] 3207 	MOV  L,A
   F043 19            [10] 3208 	DAD  D		;HL= TRK * SPT + SECT = 0000 to 07D1 (0 TO 2001)
   F044 22 99 FD      [16] 3209 	SHLD	LOGICAL_SEC
   F047 C9            [10] 3210 	RET
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 63
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           3211 
                           3212 
                           3213 
                           3214 ;----------------------------------------------------------------------------------------------------; CONSOLE BIOS
                           3215 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3216 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3217 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3218 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3219 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3220 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3221 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3222 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3223 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3224 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3225 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3226 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3227 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3228 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3229 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3230 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3231 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3232 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3233 ;----------------------------------------------------------------------------------------------------; CONSOLE BIOS
                           3234 
                           3235 ;===============================================
                           3236 ;PUT_NEW_LINE -- Start a new line on the console
                           3237 ;
                           3238 ;pre: none
                           3239 ;post: 0x0A printed to console
                           3240 ;-----------------------------------------------
   F048 CD 98 F0      [18] 3241 PUT_NEW_LINE:	CALL	PRINTI
   F04B 0D 0A 00           3242 		.ascii "\r\n\000"
   F04E C9            [10] 3243 		RET
                           3244 
                           3245 ;===============================================
                           3246 ;PUT_BC Prints BC Word
                           3247 ;-----------------------------------------------
   F04F F5            [12] 3248 PUT_BC:		PUSH	PSW
   F050 78            [ 4] 3249 		MOV	A, B
   F051 CD 70 F0      [18] 3250 		CALL	PUT_BYTE
   F054 79            [ 4] 3251 		MOV	A, C
   F055 CD 70 F0      [18] 3252 		CALL	PUT_BYTE
   F058 F1            [10] 3253 		POP	PSW
   F059 C9            [10] 3254 		RET
                           3255 
                           3256 ;===============================================
                           3257 ;PUT_DE Prints DE Word
                           3258 ;-----------------------------------------------
   F05A F5            [12] 3259 PUT_DE:		PUSH	PSW
   F05B 7A            [ 4] 3260 		MOV	A, D
   F05C CD 70 F0      [18] 3261 		CALL	PUT_BYTE
   F05F 7B            [ 4] 3262 		MOV	A, E
   F060 CD 70 F0      [18] 3263 		CALL	PUT_BYTE
   F063 F1            [10] 3264 		POP	PSW
   F064 C9            [10] 3265 		RET
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 64
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           3266 
                           3267 ;===============================================
                           3268 ;PUT_HL Prints HL Word
                           3269 ;-----------------------------------------------
   F065 F5            [12] 3270 PUT_HL:		PUSH	PSW
   F066 7C            [ 4] 3271 		MOV	A, H
   F067 CD 70 F0      [18] 3272 		CALL	PUT_BYTE
   F06A 7D            [ 4] 3273 		MOV	A, L
   F06B CD 70 F0      [18] 3274 		CALL	PUT_BYTE
   F06E F1            [10] 3275 		POP	PSW
   F06F C9            [10] 3276 		RET
                           3277 
                           3278 ;===============================================
                           3279 ;PUT_BYTE -- Output byte to console as hex
                           3280 ;
                           3281 ;pre:	A register contains byte to be output
                           3282 ;post:
                           3283 ;-----------------------------------------------
   F070 F5            [12] 3284 PUT_BYTE:	PUSH	PSW
   F071 0F            [ 4] 3285 		RRC
   F072 0F            [ 4] 3286 		RRC
   F073 0F            [ 4] 3287 		RRC
   F074 0F            [ 4] 3288 		RRC
   F075 CD 7F F0      [18] 3289 		CALL	PUT_HEX
   F078 F1            [10] 3290 		POP	PSW
   F079 F5            [12] 3291 		PUSH	PSW
   F07A CD 7F F0      [18] 3292 		CALL	PUT_HEX
   F07D F1            [10] 3293 		POP	PSW
   F07E C9            [10] 3294 		RET
                           3295 
                           3296 ;===============================================
                           3297 ;PUT_HEX -- Convert nibble to ASCII char
                           3298 ;
                           3299 ;pre: A register contains nibble
                           3300 ;post: A register contains ASCII char
                           3301 ;-----------------------------------------------
   F07F CD 85 F0      [18] 3302 PUT_HEX:	CALL	BIN2HEX
   F082 C3 EB F0      [10] 3303 		JMP	PUT_CHAR
                           3304 
   F085 E6 0F         [ 7] 3305 BIN2HEX:		ANI	0x0F
   F087 C6 90         [ 7] 3306 		ADI	0x90
   F089 27            [ 4] 3307 		DAA
   F08A CE 40         [ 7] 3308 		ACI	0x40
   F08C 27            [ 4] 3309 		DAA
   F08D C9            [10] 3310 		RET
                           3311 
                           3312 ;===============================================
                           3313 ;PRINT -- Print a null-terminated string
                           3314 ;
                           3315 ;pre: HL contains pointer to start of a null-
                           3316 ;     terminated string
                           3317 ;-----------------------------------------------
   F08E 7E            [ 7] 3318 PRINT:		MOV	A, M
   F08F 23            [ 6] 3319 		INX	H
   F090 B7            [ 4] 3320 		ORA	A
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 65
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F091 C8            [12] 3321 		RZ
   F092 CD EB F0      [18] 3322 		CALL	PUT_CHAR
   F095 C3 8E F0      [10] 3323 		JMP	PRINT
                           3324 
                           3325 ;===============================================
                           3326 ;PRINT IMMEDIATE
                           3327 ;-----------------------------------------------
   F098 E3            [16] 3328 PRINTI:		XTHL	;HL = Top of Stack
   F099 F5            [12] 3329 		PUSH	PSW
   F09A CD 8E F0      [18] 3330 		CALL	PRINT
   F09D F1            [10] 3331 		POP	PSW
   F09E E3            [16] 3332 		XTHL	;Move updated return address back to stack
   F09F C9            [10] 3333 		RET
                           3334 
                           3335 ;===============================================
                           3336 ;PRINT B-LENGTH
                           3337 ;-----------------------------------------------
   F0A0 7E            [ 7] 3338 PRINTB:		MOV	A, M
   F0A1 CD EB F0      [18] 3339 		CALL	PUT_CHAR
   F0A4 23            [ 6] 3340 		INX	H
   F0A5 05            [ 4] 3341 		DCR	B
   F0A6 C2 A0 F0      [10] 3342 		JNZ	PRINTB
   F0A9 C9            [10] 3343 		RET
                           3344 
                           3345 
                           3346 
                           3347 ;===============================================
                           3348 ;GET_CHAR_UART -- Get Char from UART
                           3349 ;-----------------------------------------------
   F0AA DB 25         [10] 3350 GET_CHAR_UART:	IN	UART0+5	;10	;TEST FOR RX DATA
   F0AC E6 01         [ 7] 3351 		ANI	1	;7
   F0AE C2 D5 F0      [10] 3352 		JNZ	GCU_UART ;10
                           3353 
   F0B1 3A 82 FD      [13] 3354 		LDA	PROP_CHECK
   F0B4 B7            [ 4] 3355 		ORA	A
   F0B5 CA AA F0      [10] 3356 		JZ	GET_CHAR_UART
                           3357 
   F0B8 DB 00         [10] 3358 		IN	PROPELLERS
   F0BA E6 02         [ 7] 3359 		ANI	2
   F0BC CA AA F0      [10] 3360 		JZ	GET_CHAR_UART
                           3361 
   F0BF DB 01         [10] 3362 		IN	PROPELLERD ;Char from Propeller ready
   F0C1 B7            [ 4] 3363 		ORA	A
   F0C2 CA CB F0      [10] 3364 		JZ	GCU_PROPSTRIKE
   F0C5 FE FF         [ 7] 3365 		CPI	0xFF
   F0C7 CA CB F0      [10] 3366 		JZ	GCU_PROPSTRIKE
   F0CA C9            [10] 3367 		RET
                           3368 
   F0CB 3A 82 FD      [13] 3369 GCU_PROPSTRIKE:	LDA	PROP_CHECK
   F0CE 3D            [ 4] 3370 		DCR	A
   F0CF 32 82 FD      [13] 3371 		STA	PROP_CHECK
   F0D2 C3 AA F0      [10] 3372 		JMP	GET_CHAR_UART
                           3373 
   F0D5 DB 20         [10] 3374 GCU_UART:	IN	UART0	;Char from UART ready
   F0D7 C9            [10] 3375 		RET
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 66
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           3376 
                           3377 ;===============================================
                           3378 ;GET_CHAR -- Get a char from the console
                           3379 ;-----------------------------------------------
   F0D8 3A 81 FD      [13] 3380 GET_CHAR:	LDA	ECHO_ON
   F0DB B7            [ 4] 3381 		ORA	A
   F0DC CA 2E F1      [10] 3382 		JZ	GET_CHAR_NE
   F0DF CD 06 EE      [18] 3383 GET_CHAR_LP:	CALL	CONSTV	;TEST FOR RX DATA
   F0E2 CA DF F0      [10] 3384 		JZ	GET_CHAR_LP
   F0E5 CD AA F0      [18] 3385 		CALL	GET_CHAR_UART
   F0E8 FE 20         [ 7] 3386 		CPI	" "	;Do not echo control chars
   F0EA F8            [12] 3387 		RM
                           3388 		;RET		;ECHO THE CHAR
                           3389 
                           3390 ;===============================================
                           3391 ;PUT_CHAR -- Output a character to the console
                           3392 ;-----------------------------------------------
   F0EB F5            [12] 3393 PUT_CHAR:	PUSH	PSW
                           3394 
                           3395 		;XRA	A		;256 ~= 2mSec Delay
                           3396 		;CALL	SD_DELAY
                           3397 
   F0EC DB 25         [10] 3398 PC_LP:		IN	UART0+5
                     F0ED  3399 PCU5		.EQU	.-1
   F0EE E6 20         [ 7] 3400 		ANI	0x20	;TEST FOR TX HOLD REG EMPTY
   F0F0 CA EC F0      [10] 3401 		JZ	PC_LP
   F0F3 F1            [10] 3402 		POP	PSW
   F0F4 D3 20         [10] 3403 		OUT	UART0
                     F0F5  3404 PCU0		.EQU	.-1
   F0F6 F5            [12] 3405 		PUSH	PSW
   F0F7 3A 82 FD      [13] 3406 		LDA	PROP_CHECK
   F0FA B7            [ 4] 3407 		ORA	A
   F0FB CA 10 F1      [10] 3408 		JZ	PC_EXIT
   F0FE E5            [12] 3409 		PUSH	H
   F0FF 21 00 20      [10] 3410 		LXI	H,0x2000
   F102 2B            [ 6] 3411 PC_LP2:		DCX	H	;PUT A TIME LIMIT ON PROP STATUS
   F103 7C            [ 4] 3412 		MOV	A,H
   F104 B5            [ 4] 3413 		ORA	L
   F105 CA 0F F1      [10] 3414 		JZ	PC_TO
   F108 DB 00         [10] 3415 		IN	PROPELLERS
   F10A E6 04         [ 7] 3416 		ANI	4
   F10C CA 02 F1      [10] 3417 		JZ	PC_LP2
   F10F E1            [10] 3418 PC_TO:		POP	H
   F110 F1            [10] 3419 PC_EXIT:		POP	PSW
   F111 D3 01         [10] 3420 		OUT	PROPELLERD
   F113 C9            [10] 3421 		RET
                           3422 
   F114                    3423 SELECT_UART0:
   F114 F5            [12] 3424 	PUSH	PSW
   F115 3E 25         [ 7] 3425 	MVI	A,UART0+5
   F117 32 ED F0      [13] 3426 	STA	PCU5
   F11A 3E 20         [ 7] 3427 	MVI	A,UART0
   F11C 32 F5 F0      [13] 3428 	STA	PCU0
   F11F F1            [10] 3429 	POP	PSW
   F120 C9            [10] 3430 	RET
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 67
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           3431 
   F121                    3432 SELECT_UART1:
   F121 F5            [12] 3433 	PUSH	PSW
   F122 3E 2D         [ 7] 3434 	MVI	A,UART1+5
   F124 32 ED F0      [13] 3435 	STA	PCU5
   F127 3E 28         [ 7] 3436 	MVI	A,UART1
   F129 32 F5 F0      [13] 3437 	STA	PCU0
   F12C F1            [10] 3438 	POP	PSW
   F12D C9            [10] 3439 	RET
                           3440 
                           3441 ;===============================================
                           3442 ;GET_CHAR -- Get a char from the console NO ECHO
                           3443 ;-----------------------------------------------
   F12E CD 06 EE      [18] 3444 GET_CHAR_NE:	CALL	CONSTV	;TEST FOR RX DATA
   F131 CA 2E F1      [10] 3445 		JZ	GET_CHAR_NE
   F134 CD AA F0      [18] 3446 		CALL	GET_CHAR_UART
   F137 C9            [10] 3447 		RET
                           3448 
                           3449 
                           3450 
                           3451 ;----------------------------------------------------------------------------------------------------; FLOPPY DISK BIOS
                           3452 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3453 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3454 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3455 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3456 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3457 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3458 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3459 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3460 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3461 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3462 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3463 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3464 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3465 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3466 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3467 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3468 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           3469 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           3470 ;----------------------------------------------------------------------------------------------------; FLOPPY DISK BIOS
                           3471 
                           3472 
                           3473 
                           3474 
                           3475 ;SDFCB:
                     0000  3476 FSTAT		.EQU	0	;BLOCK	1	;+0  Status of FCB, 00=File Not Open
                     0001  3477 FNAME		.EQU	1	;BLOCK	11	;+1  File name
                     000C  3478 AFClus0		.EQU	12	;BLOCK	2	;+12 First Cluster of File as given by the Directory Entry.
                     000E  3479 CRFClus		.EQU	14	;BLOCK	2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
                     0010  3480 CAFClus		.EQU	16	;BLOCK	2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
                     0012  3481 RFSec		.EQU	18	;BLOCK	2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
                     0014  3482 SSOC		.EQU	20	;BLOCK	4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
                     0018  3483 ABS_SEC		.EQU	24	;BLOCK	4	;+24 Absolute Sector of Current Relative Sector
                           3484 
                           3485 
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 68
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           3486 
                           3487 ;=====================================================================================================
                           3488 ;Set FCB Pointer to one of 4 FCB blocks
                           3489 ;=====================================================================================================
   F138 C5            [12] 3490 SET_FCB_PTR:	PUSH	B
   F139 E6 03         [ 7] 3491 		ANI	0x03		;Limit & Clear Carry
   F13B 0F            [ 4] 3492 		RRC			;Set A x 32 to offset into correct FCB
   F13C 0F            [ 4] 3493 		RRC
   F13D 0F            [ 4] 3494 		RRC
   F13E 4F            [ 4] 3495 		MOV	C,A
   F13F 06 00         [ 7] 3496 		MVI	B,0
   F141 21 00 FD      [10] 3497 		LXI	H,SDISKA
   F144 09            [10] 3498 		DAD	B		;HL = FCB[A]
   F145 22 83 FD      [16] 3499 		SHLD	FCB_PTR
   F148 0F            [ 4] 3500 		RRC			;Set A x 16
   F149 4F            [ 4] 3501 		MOV	C,A		;BC = A x 16
   F14A 7E            [ 7] 3502 		MOV	A,M		;Fetch FCB FSTAT (Is File OPEN / Exist)
   F14B 21 00 00      [10] 3503 		LXI	H,0		;HL = 0000 File (disk) not ready
   F14E B7            [ 4] 3504 		ORA	A
   F14F CA 56 F1      [10] 3505 		JZ	SFPE
   F152 21 3F EE      [10] 3506 		LXI	H,DPBASE
   F155 09            [10] 3507 		DAD	B		;HL = DPBASE[A]
   F156 C1            [10] 3508 SFPE:		POP	B
   F157 C9            [10] 3509 		RET
                           3510 
                           3511 
                           3512 ;=====================================================================================================
                           3513 ;Directory Routines.  1st Routine to start/init the search, 2nd routine to continue the search
                           3514 ;=====================================================================================================
                           3515 
                           3516 ;-----------------------------------------------------------------------------------------------------
                           3517 ;Call this routine to initialize and start the HL Pointer to the first Directory Entry
   F158 21 C0 FD      [10] 3518 SD_LDIR1:	LXI	H,DIR_SECTOR	;SEC_PTR = DIR_SECTOR
   F15B CD 87 F8      [18] 3519 		CALL	MOV_32_HL
   F15E 2A B0 FD      [16] 3520 		LHLD	ROOTDIR_SIZE	;ENT_COUNT = ROOTDIR_SIZE (to count down directory entries searched)
   F161 22 D8 FD      [16] 3521 		SHLD	ENT_COUNT
   F164 B7            [ 4] 3522 		ORA	A		;Clear Carry, Read only if Necessary
                           3523 
   F165 CD 71 F5      [18] 3524 SD_FETCH:	CALL	SD_READ_SEC	;Fetch a ROOT DIRECTORY sector
   F168 21 00 FE      [10] 3525 		LXI	H,SD_RAM_BUFFER	;(Re)start H at start of Sector
   F16B AF            [ 4] 3526 SD_TEST:		XRA	A		;EXIT Z=0 if there is a File at this entry
   F16C BE            [ 7] 3527 		CMP	M
   F16D C9            [10] 3528 		RET
                           3529 
                           3530 ;-----------------------------------------------------------------------------------------------------
                           3531 ;Call this routine to advance to the next Directory Entry (loads next sector and restarts HL as needed)
                           3532 ;-----------------------------------------------------------------------------------------------------
   F16E 01 20 00      [10] 3533 SD_LDIRN:	LXI	B,0x20		;Advance to next file entry
   F171 09            [10] 3534 		DAD	B
   F172 D2 6B F1      [10] 3535 		JNC	SD_TEST		;Check if extended beyond this sector
                           3536 
   F175 AF            [ 4] 3537 		XRA	A		;Return Z=1 if no more files
   F176 2A D8 FD      [16] 3538 		LHLD	ENT_COUNT
   F179 01 F0 FF      [10] 3539 		LXI	B,-16
   F17C 09            [10] 3540 		DAD	B
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 69
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F17D 22 D8 FD      [16] 3541 		SHLD	ENT_COUNT
   F180 D0            [12] 3542 		RNC			;Out of Directory entries
   F181 7C            [ 4] 3543 		MOV	A,H
   F182 B5            [ 4] 3544 		ORA	L
   F183 C8            [12] 3545 		RZ			;Out of Directory entries
                           3546 
   F184 21 D3 FD      [10] 3547 		LXI	H,SEC_PTR	;Advance to next SECTOR
   F187 CD 87 F8      [18] 3548 		CALL	MOV_32_HL
   F18A CD A7 F8      [18] 3549 		CALL	INC_32
   F18D C3 65 F1      [10] 3550 		JMP	SD_FETCH
                           3551 
                           3552 ;-----------------------------------------------------------------------------------------------------
                           3553 ;-----------------------------------------------------------------------------------------------------
                           3554 		;Find File w/ Verbose Output
                           3555 		;Call with File Name set in FILENAME.EXT
                           3556 		;Return Z=1 File Not Found
                           3557 		;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
   F190 21 C8 FD      [10] 3558 SDV_FIND_FILE:	LXI	H,FILENAME
   F193 CD 2B F8      [18] 3559 		CALL	PRINT_FILENAME
   F196 CD B9 F1      [18] 3560 SDV_FIND_FILE1:	CALL	SD_FIND_FILE	;Call the Find File routine
   F199 C2 AC F1      [10] 3561 		JNZ	SDV_FOUND	;Print Yah or Nah
   F19C CD 98 F0      [18] 3562 		CALL 	PRINTI
   F19F 20 2D 4E 4F 54 20  3563 		.ascii " -NOT FOUND\000"
        46 4F 55 4E 44 00
   F1AB C9            [10] 3564 		RET
   F1AC CD 98 F0      [18] 3565 SDV_FOUND:	CALL 	PRINTI
   F1AF 20 2D 45 58 49 53  3566 		.ascii " -EXISTS\000"
        54 53 00
   F1B8 C9            [10] 3567 		RET
                           3568 
                           3569 ;-----------------------------------------------------------------------------------------------------
                           3570 		;Find File
                           3571 		;Call with File Name set in RAM variable: FILENAME.EXT
                           3572 		;Return Z=1 File Not Found
                           3573 		;	Z=0 File Found, HL = Ptr to Directory Entry in SD_RAM_BUFFER
   F1B9 CD 58 F1      [18] 3574 SD_FIND_FILE:	CALL	SD_LDIR1
   F1BC C8            [12] 3575 SDFF_LP: 	RZ			;End of list
   F1BD CD 8C F3      [18] 3576 		CALL	CMP_FILENAME
   F1C0 C0            [12] 3577 		RNZ			;FILE FOUND
   F1C1 CD 6E F1      [18] 3578 		CALL	SD_LDIRN
   F1C4 C3 BC F1      [10] 3579 		JMP	SDFF_LP
                           3580 
                           3581 
                           3582 
                           3583 ;=====================================================================================================
                           3584 ;Read of Logical Disk Sector.
                           3585 ;=====================================================================================================
                           3586 	;Start-of-Directory = Size-of-Fat * Number-of-fats + 1 (boot sector)
                           3587 	;Start-of-Data-Area = Start-of-Directory + #Entries/32/bytes_per_sector
                           3588 
                           3589 	;Input:	Disk Sector required (0 to 2001) based on 26 sectors per track by 77 tracks, counting from 0
                           3590 	;Disk FCB in HL
                           3591 
                           3592 	;if AFClus0 = 0x0000 then attempt to open the file report Disk not loaded if fail
                           3593 	;Relative file sector:
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 70
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           3594 	;DISK_SEC is the input to this routine, it holds Virtual Disk Sector 0 to 2001
                           3595 	;because every SD sector has 512 bytes, each SD sector holds 4 CP/M Virtual Disk sectors (that's 128 bytes)
                           3596 	;RFSec is the Relative File Sector, it spans from 0 to 500 (this accomodates 501 SD Sectors or 256,512 bytes)
                           3597 	;If RFSec = DISK_SEC / 4 Then...
                           3598 	;If RFSec has not changed, then read that sector into RAM and be done.
                           3599 	;That Relative File sector is located on the SD card at address set in the absolute sector (ABS_SEC)
                           3600 	;
                           3601 	;If RFSec has changed... then determine is the new RFSec is within the same cluster or not.
                           3602 	;On a 1Gig SD card, the system uses 32 sectors per cluster.  This means, 32 sequential SD Memory Card sectors form 1 cluster.
                           3603 	;If a sector within the same cluster is being accessed, then the cluster does not have to be found again.
                           3604 	;If it's NOT in the same cluster, then find new cluster by looking through the FAT
                           3605 	;If it is in the same cluster, then skip to the part were we can just offset the RFSec into the current cluster
                           3606 	;
                           3607 	;...else
                           3608 	;RFSec = DISK_SEC / 4  'Set the new sector as the current one.
                           3609 	;
                           3610 	;Find the Relative File Cluster (RFClus).  This number will be from 0 to 15 on a 1Gig SD Card = 262,144 bytes (to hold a 256,256 file)
                           3611 	;
                           3612 	;Relative file cluster:
                           3613 	;RFClus = RFSec / SEC_PER_CLUS
                           3614 	;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
                           3615 	;  if RFClus < CRFClus then CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
                           3616 	;  RFClus = RFClus - CRFClus
                           3617 	;  do while RFClus>0
                           3618 	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
                           3619 	;      CAFClus = FAT(CAFClus)
                           3620 	;      CRFClus = CRFClus + 1
                           3621 	;      RFClus = RFClus - 1
                           3622 	;  loop
                           3623 	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
                           3624 	;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
                           3625 
                           3626 ;=====================================================================================================
                           3627 ;Read of Logical Disk Sector.
                           3628 ;Input:	LOGICAL_SEC = 0=First Sector, 2001=Last Sector based on 26 Sectors/Track and 77 Tracks
                           3629 ;	FCB_PTR	= Points to Drive (File) selected to read from
   F1C7                    3630 DISK_READ:
                           3631 ;		CALL	PRINTI
                           3632 ;		.ascii " R-\000"
                           3633 ;		LHLD	LOGICAL_SEC
                           3634 ;		CALL	PUT_HL
                           3635 
   F1C7 2A 83 FD      [16] 3636 		LHLD	FCB_PTR	;Get Current Disk FCB
   F1CA 7E            [ 7] 3637 		MOV	A,M		;Is file open?
   F1CB B7            [ 4] 3638 		ORA	A		;Test FSTAT
   F1CC C2 F0 F1      [10] 3639 		JNZ	DR_1		;Jump YES
                           3640 
                           3641 ;		CALL	PRINTI
                           3642 ;		.ascii " HL:\000"
                           3643 ;		CALL	PUT_HL
                           3644 
   F1CF CD 51 F3      [18] 3645 		CALL	SD_OPEN		;ELSE, Attempt to open file
   F1D2 2A 83 FD      [16] 3646 		LHLD	FCB_PTR
   F1D5 7E            [ 7] 3647 		MOV	A,M		;Is file open?
   F1D6 B7            [ 4] 3648 		ORA	A		;Test FSTAT
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 71
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F1D7 C2 F0 F1      [10] 3649 		JNZ	DR_1		;Jump YES
   F1DA CD 98 F0      [18] 3650 		CALL	PRINTI
   F1DD 20 2D 44 69 73 6B  3651 		.ascii " -Disk Not Loaded\000"
        20 4E 6F 74 20 4C
        6F 61 64 65 64 00
   F1EF C9            [10] 3652 		RET			;Exit if file could not open
                           3653 
   F1F0                    3654 DR_1:		;LHLD	FCB_PTR		;If file open, Check if Read is from same Data Sector (4 LSectors fit in 1 DSector)
   F1F0 01 12 00      [10] 3655 		LXI	B,RFSec
   F1F3 09            [10] 3656 		DAD	B		;H=FCB(RFSec)
   F1F4 5E            [ 7] 3657 		MOV	E,M
   F1F5 23            [ 6] 3658 		INX	H
   F1F6 56            [ 4] 3659 		MOV	D,M		;D=RFSec
   F1F7 2A 99 FD      [16] 3660 		LHLD	LOGICAL_SEC	;Fetch sector to be read
   F1FA 06 02         [ 7] 3661 		MVI	B,2
   F1FC CD CF F8      [18] 3662 		CALL	RHLR		;Rotate HL right 2 times
   F1FF CD C9 F8      [18] 3663 		CALL	CMP_DE_HL
   F202 C2 12 F2      [10] 3664 		JNZ	DR_NEW_SEC	;Jump if Read is from a different Data Sector
                           3665 
                           3666 					;LOGICAL SECTOR = LAST READ SECTOR, Fetch Absolute Sector and read it to RAM (if wasn't last read)
   F205 2A 83 FD      [16] 3667 		LHLD	FCB_PTR		;H=FCB
   F208 01 18 00      [10] 3668 		LXI	B,ABS_SEC
   F20B 09            [10] 3669 		DAD	B		;H=FCB(ABS_SEC)
                           3670 
   F20C CD 87 F8      [18] 3671 		CALL	MOV_32_HL
   F20F C3 1A F3      [10] 3672 		JMP	DR_READ_IT
                           3673 
                           3674 
                           3675 	;RFClus = RFSec / SEC_PER_CLUS
                           3676 	;if RFClus has changed, then recalculate the File Cluster and then update the SSOC.
                           3677 	;  if RFClus < CRFClus then
                           3678 	;     CRFClus=0, CAFClus = AFClus0  'start FAT search from 0 if going backward
                           3679 	;  eles
                           3680 	;     RFClus = RFClus - CRFClus	   'else, continue FAT search from point of
                           3681 	;  endif
                           3682 	;  do while RFClus>0
                           3683 	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
                           3684 	;      CAFClus = FAT(CAFClus)
                           3685 	;      CRFClus = CRFClus + 1
                           3686 	;      RFClus = RFClus - 1
                           3687 	;  loop
                           3688 	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
                           3689 	;if RFClus has NOT changed, then ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
   F212                    3690 DR_NEW_SEC:
   F212 EB            [ 4] 3691 		XCHG			;D=LOGICAL_SEC/4 = Relative File Sector (Update FCB with this new Rel-File-Sec
   F213 2A 83 FD      [16] 3692 		LHLD	FCB_PTR		;Set FCB(RFSec)
   F216 01 12 00      [10] 3693 		LXI	B,RFSec
   F219 09            [10] 3694 		DAD	B		;H=FCB(RFSec)
   F21A 73            [ 7] 3695 		MOV	M,E		;MOV (HL),DE
   F21B 23            [ 6] 3696 		INX	H
   F21C 72            [ 7] 3697 		MOV	M,D
                           3698 
   F21D 2A 91 FD      [16] 3699 		LHLD	DIVIDE_FUNC	;DE = DE / Sectors-Per-Cluster
   F220 CD FB F8      [18] 3700 		CALL	VCALL
   F223 2A 83 FD      [16] 3701 		LHLD	FCB_PTR		;Set FCB(CRFClus)
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 72
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F226 01 0E 00      [10] 3702 		LXI	B,CRFClus
   F229 09            [10] 3703 		DAD	B		;H=FCB(CRFClus)
   F22A E5            [12] 3704 		PUSH	H
   F22B CD EB F8      [18] 3705 		CALL	LD_HL_HL
   F22E 44            [ 4] 3706 		MOV	B,H		;BC = CRFClus
   F22F 4D            [ 4] 3707 		MOV	C,L
                           3708 
   F230 E1            [10] 3709 		POP	H		;H->FCB(CRFClus)
                           3710 					;TEST DE - BC  aka NewRFClus vs FCB-RFClus
                           3711 					;Speed Optimize the above code
   F231 7A            [ 4] 3712 		MOV	A,D
   F232 B8            [ 4] 3713 		CMP	B
   F233 C2 3B F2      [10] 3714 		JNZ	DR_DIFF_CLUS
   F236 7B            [ 4] 3715 		MOV	A,E
   F237 B9            [ 4] 3716 		CMP	C
   F238 CA F6 F2      [10] 3717 		JZ	DR_SAME_CLUS	;IF they are the same, then the new sector is in the same cluster
   F23B D2 46 F2      [10] 3718 DR_DIFF_CLUS:	JNC	DR_BIGGER_CLUS
                           3719 
                           3720 					;If going to a smaller cluster, restart the FAT search from the begining
   F23E 01 00 00      [10] 3721 		LXI	B,0		;CRFClus = 0
   F241 2B            [ 6] 3722 		DCX	H
   F242 2B            [ 6] 3723 		DCX	H
   F243 C3 4E F2      [10] 3724 		JMP	DR_SEEK_FAT	;HL will load with AFClus0
                           3725 
   F246                    3726 DR_BIGGER_CLUS:
   F246 7B            [ 4] 3727 		MOV	A,E		;NewRFClus = NewRFClus - FCB-RFClus,  ie Set counter for number of new FAT hops.
   F247 91            [ 4] 3728 		SUB	C
   F248 5F            [ 4] 3729 		MOV	E,A
   F249 7A            [ 4] 3730 		MOV	A,D
   F24A 98            [ 4] 3731 		SBB	B
   F24B 57            [ 7] 3732 		MOV	D,A
                           3733 
   F24C 23            [ 6] 3734 		INX	H
   F24D 23            [ 6] 3735 		INX	H		;HL will load with CAFClus
                           3736 
                           3737 	;  do while RFClus>0
                           3738 	;      if CAFClus = 0xFFFF Then EOF reached, file too small to be a disk. (Report as disk error)
                           3739 	;      CAFClus = FAT(CAFClus)
                           3740 	;      CRFClus = CRFClus + 1
                           3741 	;      RFClus = RFClus - 1
                           3742 	;  loop
                           3743 
   F24E                    3744 DR_SEEK_FAT:
   F24E CD EB F8      [18] 3745 		CALL	LD_HL_HL	;HL = CAFClus or AFClus0
                           3746 
                           3747 ;		CALL	PRINTI
                           3748 ;		.ascii "\r\nCAFClus=\000"
                           3749 ;		CALL	PUT_HL
                           3750 ;		CALL	PRINTI
                           3751 ;		.ascii "\r\nCRFClus=\000"
                           3752 ;		CALL	PUT_BC
                           3753 ;		CALL	PRINTI
                           3754 ;		.ascii "\r\nRFClus=\000"
                           3755 ;		CALL	PUT_DE
                           3756 
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 73
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           3757 					;BC = CRFClus
   F251 7A            [ 4] 3758 DR_SEEK_LP:	MOV	A,D		;DE = RFClus
   F252 B3            [ 4] 3759 		ORA	E
   F253 CA 99 F2      [10] 3760 		JZ	DR_SEEK_DONE
                           3761 
                           3762 ;		CALL	PRINTI
                           3763 ;		.ascii "\r\nseek=\000"
                           3764 ;		CALL	PUT_HL
                           3765 
   F256 23            [ 6] 3766 		INX	H		;IF CAFClus = 0xFFFF...
   F257 7C            [ 4] 3767 		MOV	A,H
   F258 B5            [ 4] 3768 		ORA	L
   F259 CA 8D F2      [10] 3769 		JZ	SDO_FSERR2	;Error, File too small
   F25C 2B            [ 6] 3770 		DCX	H
                           3771 
                           3772 	;Here comes the FAT Hopping FUN...
                           3773 	;      CAFClus = FAT(CAFClus)
                           3774 	;it's convenient that 1 Sector is 512 bytes, that's 256 words = 256 FAT Entries, therefore...
                           3775 	;H = Sector of FAT
                           3776 	;L = Word within that Sector of FAT
                           3777 
   F25D C5            [12] 3778 		PUSH	B
   F25E D5            [12] 3779 		PUSH	D
   F25F E5            [12] 3780 		PUSH	H
   F260 5C            [ 4] 3781 		MOV	E,H		;E=Sector of FAT
   F261 2A BC FD      [16] 3782 		LHLD	FAT1START	;DE = E + FAT1START
   F264 7D            [ 4] 3783 		MOV	A,L
   F265 83            [ 4] 3784 		ADD	E
   F266 5F            [ 4] 3785 		MOV	E,A
   F267 7C            [ 4] 3786 		MOV	A,H
   F268 CE 00         [ 7] 3787 		ACI	0		;Carry it forward
   F26A 57            [ 7] 3788 		MOV	D,A
   F26B 2A BE FD      [16] 3789 		LHLD	FAT1START+2
   F26E D2 72 F2      [10] 3790 		JNC	DRS_0		;Test for Carry
   F271 23            [ 6] 3791 		INX	H		;Carry it forward
   F272 44            [ 4] 3792 DRS_0:		MOV	B,H
   F273 4D            [ 4] 3793 		MOV	C,L		;BCDE now have Sector of FAT desired
   F274 CD 71 F5      [18] 3794 		CALL	SD_READ_SEC
   F277 D1            [10] 3795 		POP	D		;Fetch DE, E=Word within that FAT sector
   F278 21 00 FE      [10] 3796 		LXI	H,SD_RAM_BUFFER
   F27B B7            [ 4] 3797 		ORA	A		;Clear Carry
   F27C 7B            [ 4] 3798 		MOV	A,E		;Fetch offset into FAT sector read
   F27D 17            [ 4] 3799 		RAL
   F27E 6F            [ 4] 3800 		MOV	L,A		;
   F27F 7C            [ 4] 3801 		MOV	A,H
   F280 CE 00         [ 7] 3802 		ACI	0
   F282 67            [ 7] 3803 		MOV	H,A		;HL -> FAT Entry
   F283 CD EB F8      [18] 3804 		CALL	LD_HL_HL	;HL = FAT Entry
   F286 D1            [10] 3805 		POP	D
   F287 C1            [10] 3806 		POP	B
                           3807 
   F288 03            [ 6] 3808 		INX	B
   F289 1B            [ 6] 3809 		DCX	D
   F28A C3 51 F2      [10] 3810 		JMP	DR_SEEK_LP
                           3811 
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 74
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F28D CD 98 F0      [18] 3812 SDO_FSERR2:	CALL	PRINTI
   F290 20 2D 21 45 4F 46  3813 		.ascii " -!EOF!\000"
        21 00
   F298 C9            [10] 3814 		RET
                           3815 
                           3816 
   F299                    3817 DR_SEEK_DONE:	;Write Registers to FCB
                           3818 		;BC = CRFClus
                           3819 		;DE = RFClus - Not required (it's a counter down to zero to find the correct cluster)
                           3820 		;HL = CAFClus
                           3821 
   F299 EB            [ 4] 3822 		XCHG			;DE = CAFClus
   F29A 2A 83 FD      [16] 3823 		LHLD	FCB_PTR		;Set FCB(CRFClus)
   F29D D5            [12] 3824 		PUSH	D
   F29E 11 0E 00      [10] 3825 		LXI	D,CRFClus
   F2A1 19            [10] 3826 		DAD	D		;H=FCB(CRFClus)
   F2A2 D1            [10] 3827 		POP	D
   F2A3 71            [ 7] 3828 		MOV	M,C		;Save CRFClust to FCB
   F2A4 23            [ 6] 3829 		INX	H
   F2A5 70            [ 7] 3830 		MOV	M,B
   F2A6 23            [ 6] 3831 		INX	H
   F2A7 73            [ 7] 3832 		MOV	M,E		;Save CAFClus to FCB
   F2A8 23            [ 6] 3833 		INX	H
   F2A9 72            [ 7] 3834 		MOV	M,D
                           3835 
                           3836 	;Now, let's find the Data Sector to be loaded....
                           3837 	;First, calculate the Starting Sector of Cluster (SSOC)
                           3838 	;  SSOC = (CAFClus - 2) * SEC_PER_CLUS + Start-of-Data-Area
                           3839 
   F2AA EB            [ 4] 3840 		XCHG			;HL = CAFClus
   F2AB 2B            [ 6] 3841 		DCX	H		;CAFClus - 2
   F2AC 2B            [ 6] 3842 		DCX	H
                           3843 
                           3844 ;-------------------------------------	Multiply Routine.  16bit by 8 bit -> 24bit
   F2AD 01 00 00      [10] 3845 		LXI	B,0		;BHL = 16bit input (need 24 bits to shift)
   F2B0 11 00 00      [10] 3846 		LXI	D,0		;CDE = 24bit output
   F2B3 3E 08         [ 7] 3847 		MVI	A,8		;Go through 8 bits
   F2B5 32 95 FD      [13] 3848 		STA	M_COUNTER
   F2B8 3A AC FD      [13] 3849 		LDA	SEC_PER_CLUS	;Fetch Multiplier
   F2BB 1F            [ 4] 3850 DRSS_LP:		RAR
   F2BC 32 94 FD      [13] 3851 		STA	MUL8
   F2BF D2 C8 F2      [10] 3852 		JNC	DRSS_SHIFT
   F2C2 EB            [ 4] 3853 		XCHG
   F2C3 19            [10] 3854 		DAD	D		;DE=DE+HL
   F2C4 EB            [ 4] 3855 		XCHG
   F2C5 79            [ 4] 3856 		MOV	A,C
   F2C6 88            [ 4] 3857 		ADC	B
   F2C7 4F            [ 4] 3858 		MOV	C,A
                           3859 
   F2C8 29            [10] 3860 DRSS_SHIFT:	DAD	H		;BHL=BHL*2
   F2C9 78            [ 4] 3861 		MOV	A,B		;
   F2CA 17            [ 4] 3862 		RAL
   F2CB 47            [ 7] 3863 		MOV	B,A
   F2CC 3A 95 FD      [13] 3864 		LDA	M_COUNTER	;Count down 8 bits
   F2CF 3D            [ 4] 3865 		DCR	A
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 75
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F2D0 32 95 FD      [13] 3866 		STA	M_COUNTER
   F2D3 3A 94 FD      [13] 3867 		LDA	MUL8		;Fetch next Multiplier bit
   F2D6 C2 BB F2      [10] 3868 		JNZ	DRSS_LP
                           3869 ;-------
                           3870 					;Add to BCDE, the DATASTART sector
   F2D9 06 00         [ 7] 3871 		MVI	B,0		;BCDE = 32bit Absolute sector
   F2DB 2A C4 FD      [16] 3872 		LHLD	DATASTART	;32 Bit ADD DATASTART
   F2DE 19            [10] 3873 		DAD	D
   F2DF EB            [ 4] 3874 		XCHG			;DE=DE+START (LSB)
   F2E0 2A C6 FD      [16] 3875 		LHLD	DATASTART+2
   F2E3 D2 E7 F2      [10] 3876 		JNC	DRSS_ABC
   F2E6 03            [ 6] 3877 		INX	B		;Add Carry out of 16 Bit ADD
   F2E7 09            [10] 3878 DRSS_ABC:	DAD	B
   F2E8 E5            [12] 3879 		PUSH	H
   F2E9 C1            [10] 3880 		POP	B		;BC=BC+START (MSB)
                           3881 ;-------
                           3882 					;Save the result to RAM variable SSOC
   F2EA 2A 83 FD      [16] 3883 		LHLD	FCB_PTR		;Set FCB(SSOC)
   F2ED C5            [12] 3884 		PUSH	B
   F2EE 01 14 00      [10] 3885 		LXI	B,SSOC
   F2F1 09            [10] 3886 		DAD	B		;H=FCB(SSOC)
   F2F2 C1            [10] 3887 		POP	B
   F2F3 CD 8F F8      [18] 3888 		CALL	MOV_HL_32	;Save the 32 bit register BCDE to (HL)
                           3889 ;-------
                           3890 
                           3891 	;ABS_SEC = SSOC + (RFSec MOD SEC_PER_CLUS), then read ABS_SEC into the buffer.
   F2F6                    3892 DR_SAME_CLUS:				;Fetch the RFSec
   F2F6 2A 83 FD      [16] 3893 		LHLD	FCB_PTR		;Set FCB(RFSec)
   F2F9 01 12 00      [10] 3894 		LXI	B,RFSec
   F2FC 09            [10] 3895 		DAD	B		;H=FCB(RFSec)
                           3896 
   F2FD 5E            [ 7] 3897 		MOV	E,M		;DE=RFSec
   F2FE 23            [ 6] 3898 		INX	H
   F2FF 56            [ 4] 3899 		MOV	D,M
                           3900 
   F300 2A 96 FD      [16] 3901 		LHLD	MOD_FUNC	;DE = DE % Sectors-Per-Cluster
   F303 CD FB F8      [18] 3902 		CALL	VCALL		;A = RFSec MOD SEC_PER_CLUS
                           3903 
   F306 2A 83 FD      [16] 3904 		LHLD	FCB_PTR		;Set FCB(SSOC)
   F309 01 14 00      [10] 3905 		LXI	B,SSOC
   F30C 09            [10] 3906 		DAD	B		;H=FCB(SSOC)
   F30D 01 00 00      [10] 3907 		LXI	B,0		;BCDE = (RFSec MOD SEC_PER_CLUS)
   F310 16 00         [ 7] 3908 		MVI	D,0
   F312 5F            [ 4] 3909 		MOV	E,A
   F313 CD 97 F8      [18] 3910 		CALL	ADD_32_HL	;BCDE = SSOC + (RFSec MOD SEC_PER_CLUS)
                           3911 
   F316 23            [ 6] 3912 		INX	H		;Advance HL to ABS_SEC
   F317 CD 8F F8      [18] 3913 		CALL	MOV_HL_32	;Save the ABS_SEC
                           3914 
   F31A CD 71 F5      [18] 3915 DR_READ_IT:	CALL	SD_READ_SEC	;Fetch the Sector
                           3916 
                           3917 ;--------- Set HL to the 128 byte Quarter Buffer of SD_RAM_BUFFER
   F31D 21 00 FE      [10] 3918 SET_QUARTER:	LXI	H,SD_RAM_BUFFER
   F320 3A 99 FD      [13] 3919 		LDA	LOGICAL_SEC	;Fetch sector to be read (lsb)
   F323 1F            [ 4] 3920 		RAR			;Adjust H to correct LSector of 128 Bytes
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 76
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F324 1F            [ 4] 3921 		RAR
   F325 D2 29 F3      [10] 3922 		JNC	SQ_0
   F328 24            [ 4] 3923 		INR	H
   F329 17            [ 4] 3924 SQ_0:		RAL
   F32A 06 80         [ 7] 3925 		MVI	B,128		;Preset Length of copy = 128 Bytes
   F32C D0            [12] 3926 		RNC
   F32D 2E 80         [ 7] 3927 		MVI	L,0x80
   F32F C9            [10] 3928 		RET
                           3929 
                           3930 
                           3931 ;=====================================================================================================
                           3932 		;Open File (Mount Disk)	;Input:	FCB_PTR = FCB
                           3933 		;Tests if file exists, right size, then copies the Starting Cluster to the FCB
   F330 2A 83 FD      [16] 3934 SD_OPENT:	LHLD	FCB_PTR
   F333 7E            [ 7] 3935 		MOV	A,M		;Is file open?
   F334 E6 CF         [ 7] 3936 		ANI	0xCF		;Test FSTAT
   F336 CA 51 F3      [10] 3937 		JZ	SD_OPEN
   F339 CD 98 F0      [18] 3938 		CALL	PRINTI
   F33C 20 2D 46 49 4C 45  3939 		.ascii " -FILE ALREADY OPEN\000"
        20 41 4C 52 45 41
        44 59 20 4F 50 45
        4E 00
   F350 C9            [10] 3940 		RET
                           3941 
                           3942 ;SD_OPEN   -Open FAT-16 file on SD card
                           3943 ;Searches Directory for file - Returns Zero flag if File not found.
                           3944 
   F351 2A 83 FD      [16] 3945 SD_OPEN:		LHLD	FCB_PTR
   F354 36 00         [10] 3946 		MVI	M,0		;FSTAT=0, Clear Open Status
   F356 23            [ 6] 3947 		INX	H		;+1 = FNAME
   F357 11 C8 FD      [10] 3948 		LXI	D,FILENAME	;Write FCB File name to FILENAME for finding
   F35A 06 0B         [ 7] 3949 		MVI	B,11
   F35C CD E2 F8      [18] 3950 		CALL	COPY_RAM
   F35F CD 90 F1      [18] 3951 		CALL	SDV_FIND_FILE	;Return with H=Directory Entry
   F362 C8            [12] 3952 		RZ			;Exit if file not found
                           3953 
   F363 01 1A 00      [10] 3954 		LXI	B,0x001A		;START CLUSTER & File Size Offset (into Directory Entry)
   F366 09            [10] 3955 		DAD	B		;H=(FILE SIZE)
   F367 11 DA FD      [10] 3956 		LXI	D,CLUSTER1
   F36A 06 06         [ 7] 3957 		MVI	B,6
   F36C CD E2 F8      [18] 3958 		CALL	COPY_RAM
                           3959 
   F36F 2A DA FD      [16] 3960 		LHLD	CLUSTER1
   F372 EB            [ 4] 3961 		XCHG			;DE=CLUSTER1
   F373 2A 83 FD      [16] 3962 		LHLD	FCB_PTR		;H=FCB
   F376 36 01         [10] 3963 		MVI	M,1		;FSTAT=1
   F378 01 0C 00      [10] 3964 		LXI	B,AFClus0	;offset to AFClus0
   F37B 09            [10] 3965 		DAD	B
   F37C 73            [ 7] 3966 		MOV	M,E		;Save Starting Cluster
   F37D 23            [ 6] 3967 		INX	H
   F37E 72            [ 7] 3968 		MOV	M,D
   F37F 23            [ 6] 3969 		INX	H
   F380 06 0E         [ 7] 3970 		MVI	B,14
   F382 3E FF         [ 7] 3971 		MVI	A,0xFF
   F384 CD F0 F8      [18] 3972 		CALL	FILL_BLOCK	;Fill 14 bytes of FF (Nuke pointers to force new calculations)
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 77
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F387 2A 83 FD      [16] 3973 		LHLD	FCB_PTR		;H=FCB
   F38A 3D            [ 4] 3974 		DCR	A		;Z=0
   F38B C9            [10] 3975 		RET
                           3976 
                           3977 
                           3978 
                           3979 
                           3980 ;-----------------------------------------------------------------------------------------------------
   F38C E5            [12] 3981 CMP_FILENAME:	PUSH	H		;Save H pointer into Directory
   F38D 06 0B         [ 7] 3982 		MVI	B,11		;Compare 11 characters
   F38F 11 C8 FD      [10] 3983 		LXI	D,FILENAME
   F392 1A            [ 7] 3984 CMPF_LP1:	LDAX	D
   F393 BE            [ 7] 3985 		CMP	M
   F394 C2 A0 F3      [10] 3986 		JNZ	CMPF_RETFAIL	;Exit if not equal
   F397 23            [ 6] 3987 		INX	H
   F398 13            [ 6] 3988 		INX	D
   F399 05            [ 4] 3989 		DCR	B
   F39A C2 92 F3      [10] 3990 		JNZ	CMPF_LP1
                           3991 
   F39D 04            [ 4] 3992 		INR	B		;Z=0
   F39E E1            [10] 3993 		POP	H
   F39F C9            [10] 3994 		RET
   F3A0 AF            [ 4] 3995 CMPF_RETFAIL:	XRA	A		;Z=1
   F3A1 E1            [10] 3996 		POP	H
   F3A2 C9            [10] 3997 		RET
                           3998 
                           3999 
                           4000 
                           4001 
                           4002 ;		MVI	B,8		;Compare 8 characters
                           4003 ;		LXI	D,FILENAME
                           4004 ;CMPF_LP1:	LDAX	D
                           4005 ;		CMP	M
                           4006 ;		JNZ	CMPF_RETFAIL	;Exit if not equal
                           4007 ;		INX	H
                           4008 ;		INX	D
                           4009 ;		DCR	B
                           4010 ;		JNZ	CMPF_LP1
                           4011 ;
                           4012 ;		POP	H
                           4013 ;		PUSH	H
                           4014 ;		LXI	D,8		;Point to Ext in Dir
                           4015 ;		DAD	D
                           4016 ;
                           4017 ;		MVI	B,3
                           4018 ;		LXI	D,FILEEXT
                           4019 ;CMPF_LP2:	LDAX	D
                           4020 ;		CMP	M
                           4021 ;		JNZ	CMPF_RETFAIL
                           4022 ;		INX	H
                           4023 ;		INX	D
                           4024 ;		DCR	B
                           4025 ;		JNZ	CMPF_LP2
                           4026 ;		INR	B		;Z=0
                           4027 ;		POP	H
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 78
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           4028 ;		RET
                           4029 ;CMPF_RETFAIL:	XRA	A		;Z=1
                           4030 ;		POP	H
                           4031 ;		RET
                           4032 
                           4033 
                           4034 
                           4035 ;=====================================================================================================
                           4036 ;=====================================================================================================
   F3A3 21 87 FD      [10] 4037 INIT_FAT:	LXI	H,CLEAR_RAM	;Clear RAM
   F3A6 06 00         [ 7] 4038 		MVI	B,0
   F3A8 AF            [ 4] 4039 		XRA	A
   F3A9 CD F0 F8      [18] 4040 		CALL	FILL_BLOCK
                           4041 
                           4042 		;XRA	A		;Flag no more Dirty Data
                           4043 		;STA	DIRTY_DATA	;which would require flushing changed data to SD Memory Card
   F3AC CD 6F F6      [18] 4044 		CALL	INIT_SDCARD
   F3AF C0            [12] 4045 		RNZ
                           4046 
   F3B0 CD 98 F0      [18] 4047 		CALL 	PRINTI		;
   F3B3 4D 42 52 00        4048 		.ascii "MBR\000"
                           4049 
                           4050 
   F3B7 01 00 00      [10] 4051 		LXI	B,0		;BCDE = 0x00000000
   F3BA 11 00 00      [10] 4052 		LXI	D,0
   F3BD 37            [ 4] 4053 		STC			;Force Read
   F3BE CD 71 F5      [18] 4054 		CALL	SD_READ_SEC	;READ MBR
   F3C1 CD 5C F5      [18] 4055 		CALL	TEST_SIGNATURE
   F3C4 C0            [12] 4056 		RNZ
                           4057 
   F3C5 CD 98 F0      [18] 4058 		CALL 	PRINTI		;
   F3C8 20 54 79 70 65 00  4059 		.ascii " Type\000"
   F3CE 3A C2 FF      [13] 4060 		LDA	SD_RAM_BUFFER+0x01C2
   F3D1 CD 70 F0      [18] 4061 		CALL	PUT_BYTE
   F3D4 32 A1 FD      [13] 4062 		STA	SD_PART_TYPE
   F3D7 FE 04         [ 7] 4063 		CPI	4
   F3D9 CA EB F3      [10] 4064 		JZ	INITFAT_PGOOD
   F3DC FE 06         [ 7] 4065 		CPI	6
   F3DE CA EB F3      [10] 4066 		JZ	INITFAT_PGOOD
   F3E1 FE 86         [ 7] 4067 		CPI	0x86
   F3E3 CA EB F3      [10] 4068 		JZ	INITFAT_PGOOD
   F3E6 FE 0E         [ 7] 4069 		CPI	0x0E
   F3E8 C2 46 F5      [10] 4070 		JNZ	INITFAT_FAIL
                           4071 
   F3EB 21 C6 FF      [10] 4072 INITFAT_PGOOD:	LXI	H,SD_RAM_BUFFER+0x01C6
   F3EE 11 A2 FD      [10] 4073 		LXI	D,SD_PART_BASE
   F3F1 06 08         [ 7] 4074 		MVI	B,8
   F3F3 CD E2 F8      [18] 4075 		CALL	COPY_RAM	;Copy BASE & SIZE from BUFFER to RAM Variables
   F3F6 CD 98 F0      [18] 4076 		CALL 	PRINTI		;
   F3F9 20 50 42 52 00     4077 		.ascii " PBR\000"
                           4078 
   F3FE 21 A2 FD      [10] 4079 		LXI	H,SD_PART_BASE
   F401 CD 87 F8      [18] 4080 		CALL	MOV_32_HL	;Copy BASE to SEC_PTR
   F404 CD 71 F5      [18] 4081 		CALL	SD_READ_SEC	;READ BOOT RECORD OF PARTITION
   F407 CD 5C F5      [18] 4082 		CALL	TEST_SIGNATURE
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 79
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F40A C0            [12] 4083 		RNZ
                           4084 
   F40B 21 0B FE      [10] 4085 		LXI	H,SD_RAM_BUFFER+0x0B
   F40E 11 AA FD      [10] 4086 		LXI	D,BYTE_P_SEC
   F411 06 0A         [ 7] 4087 		MVI	B,10
   F413 CD E2 F8      [18] 4088 		CALL	COPY_RAM	;Copy Description Table to RAM Variables (Up to Total Filesys Sectors)
   F416 EB            [ 4] 4089 		XCHG			;Test TOTAL_FILESYS_SECTORS = 0
   F417 2B            [ 6] 4090 		DCX	H
   F418 2B            [ 6] 4091 		DCX	H
   F419 7E            [ 7] 4092 		MOV	A,M
   F41A 23            [ 6] 4093 		INX	H
   F41B B6            [ 7] 4094 		ORA	M
   F41C C2 2A F4      [10] 4095 		JNZ	INITFAT_TFS_OK
   F41F 2B            [ 6] 4096 		DCX	H
   F420 EB            [ 4] 4097 		XCHG
   F421 21 20 FE      [10] 4098 		LXI	H,SD_RAM_BUFFER+0x20
                           4099 
   F424 CD E0 F8      [18] 4100 		CALL	COPY_RAM4
   F427 C3 31 F4      [10] 4101 		JMP	INITFAT_TFS_DONE
                           4102 
   F42A AF            [ 4] 4103 INITFAT_TFS_OK:	XRA	A
   F42B 23            [ 6] 4104 		INX	H
   F42C 77            [ 7] 4105 		MOV	M,A
   F42D 23            [ 6] 4106 		INX	H
   F42E 77            [ 7] 4107 		MOV	M,A
   F42F 23            [ 6] 4108 		INX	H
   F430 EB            [ 4] 4109 		XCHG
   F431                    4110 INITFAT_TFS_DONE:
                           4111 
   F431 21 1C FE      [10] 4112 		LXI	H,SD_RAM_BUFFER+0x001C
   F434 CD E0 F8      [18] 4113 		CALL	COPY_RAM4	;Copy HIDDEN_SECTORS to RAM Variables
   F437 21 16 FE      [10] 4114 		LXI	H,SD_RAM_BUFFER+0x0016
   F43A CD DB F8      [18] 4115 		CALL	COPY_RAM2	;Copy SECTORS_PER_FAT to RAM Variables
                           4116 
                           4117 ;BS.fat1Start = MBR.part1Start + BS.reservedSectors;
   F43D 2A AD FD      [16] 4118 		LHLD	RESERVED_SEC	;H=Reserved Sectors
   F440 EB            [ 4] 4119 		XCHG
   F441 2A A2 FD      [16] 4120 		LHLD	SD_PART_BASE	;FAT1START = SD_PART_BASE + RESERVED_SEC
   F444 19            [10] 4121 		DAD	D
   F445 22 BC FD      [16] 4122 		SHLD	FAT1START
   F448 2A A4 FD      [16] 4123 		LHLD	SD_PART_BASE+2
   F44B D2 4F F4      [10] 4124 		JNC	INITFAT_C1_DONE
   F44E 23            [ 6] 4125 		INX	H
   F44F 22 BE FD      [16] 4126 INITFAT_C1_DONE:	SHLD	FAT1START+2
                           4127 
                           4128 ;firstDirSector = BS.fat1Start + (BS.fatCopies * BS.sectorsPerFAT);
   F452 3A AF FD      [13] 4129 		LDA	FAT_COPIES
   F455 47            [ 7] 4130 		MOV	B,A
   F456 2A BA FD      [16] 4131 		LHLD	SEC_PER_FAT
   F459 EB            [ 4] 4132 		XCHG
   F45A 21 00 00      [10] 4133 		LXI	H,0
   F45D 19            [10] 4134 INITFAT_C2_LP:	DAD	D
   F45E 05            [ 4] 4135 		DCR	B
   F45F C2 5D F4      [10] 4136 		JNZ	INITFAT_C2_LP	;H = FAT_COPIES * SEC_PER_FAT
   F462 EB            [ 4] 4137 		XCHG			;D = H
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 80
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F463 2A BC FD      [16] 4138 		LHLD	FAT1START
   F466 19            [10] 4139 		DAD	D		;DIR_SECTOR = FAT1START + FAT_COPIES * SEC_PER_FAT
   F467 22 C0 FD      [16] 4140 		SHLD	DIR_SECTOR
   F46A 2A BE FD      [16] 4141 		LHLD	FAT1START+2
   F46D D2 71 F4      [10] 4142 		JNC	INITFAT_C2_DONE
   F470 23            [ 6] 4143 		INX	H
   F471 22 C2 FD      [16] 4144 INITFAT_C2_DONE:	SHLD	DIR_SECTOR+2
                           4145 
                           4146 ;DATASTART = DIR_SECTOR + LEN(Directory)
                           4147 ;          = DIR_SECTOR + ROOTDIR_SIZE * 32 / BYTE_P_SEC
   F474 06 10         [ 7] 4148 		MVI	B,16		;Maximum # of Reductions
   F476 2A AA FD      [16] 4149 		LHLD	BYTE_P_SEC	;To fit math into 16 bits, let's reduce "ROOTDIR_SIZE / BYTE_P_SEC"
   F479 EB            [ 4] 4150 		XCHG			;Divide each by 2 while dividable
   F47A 2A B0 FD      [16] 4151 		LHLD	ROOTDIR_SIZE	;H=ROOTDIR_SIZE, D=BYTE_P_SEC
   F47D 7B            [ 4] 4152 INITFAT_C3_LP:	MOV	A,E
   F47E 1F            [ 4] 4153 		RAR
   F47F DA AC F4      [10] 4154 		JC	INITFAT_C3_0	;If lsb of D is 1, no more Reduction possible
   F482 7D            [ 4] 4155 		MOV	A,L
   F483 1F            [ 4] 4156 		RAR
   F484 DA AC F4      [10] 4157 		JC	INITFAT_C3_0	;If lsb of H is 1, no more Reduction possible
   F487 7A            [ 4] 4158 		MOV	A,D
   F488 1F            [ 4] 4159 		RAR
   F489 57            [ 7] 4160 		MOV	D,A
   F48A 7B            [ 4] 4161 		MOV	A,E
   F48B 1F            [ 4] 4162 		RAR
   F48C 5F            [ 4] 4163 		MOV	E,A
   F48D 7C            [ 4] 4164 		MOV	A,H
   F48E 1F            [ 4] 4165 		RAR
   F48F 67            [ 7] 4166 		MOV	H,A
   F490 7D            [ 4] 4167 		MOV	A,L
   F491 1F            [ 4] 4168 		RAR
   F492 6F            [ 4] 4169 		MOV	L,A
   F493 05            [ 4] 4170 		DCR	B
   F494 C2 7D F4      [10] 4171 		JNZ	INITFAT_C3_LP
   F497 CD 98 F0      [18] 4172 INITFAT_C3_ERR:	CALL 	PRINTI		;
   F49A 20 45 72 72 6F 72  4173 		.ascii " Error DATASTART\000"
        20 44 41 54 41 53
        54 41 52 54 00
   F4AB C9            [10] 4174 		RET
   F4AC 06 05         [ 7] 4175 INITFAT_C3_0:	MVI	B,5		;5 shifts = Multiply 32
   F4AE 29            [10] 4176 INITFAT_C3_LP2:	DAD	H		;Double H
   F4AF DA 97 F4      [10] 4177 		JC	INITFAT_C3_ERR
   F4B2 05            [ 4] 4178 		DCR	B
   F4B3 C2 AE F4      [10] 4179 		JNZ	INITFAT_C3_LP2
                           4180 
   F4B6 7B            [ 4] 4181 		MOV	A,E		;2'S Complement BYTE_P_SEC
   F4B7 2F            [ 4] 4182 		CMA
   F4B8 4F            [ 4] 4183 		MOV	C,A
   F4B9 7A            [ 4] 4184 		MOV	A,D
   F4BA 2F            [ 4] 4185 		CMA
   F4BB 47            [ 7] 4186 		MOV	B,A
   F4BC 03            [ 6] 4187 		INX	B
   F4BD 11 FF FF      [10] 4188 		LXI	D,0xFFFF	;Start with -1
   F4C0 09            [10] 4189 INITFAT_C3_LP3:	DAD	B		;Divide by counting Subtractions
   F4C1 13            [ 6] 4190 		INX	D
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 81
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F4C2 DA C0 F4      [10] 4191 		JC	INITFAT_C3_LP3
   F4C5 2A C0 FD      [16] 4192 		LHLD	DIR_SECTOR	;Add the Dword at DIR_SECTOR
   F4C8 19            [10] 4193 		DAD	D
   F4C9 22 C4 FD      [16] 4194 		SHLD	DATASTART
   F4CC 2A C2 FD      [16] 4195 		LHLD	DIR_SECTOR+2
   F4CF D2 D3 F4      [10] 4196 		JNC	INITFAT_C3_1
   F4D2 23            [ 6] 4197 		INX	H
   F4D3 22 C6 FD      [16] 4198 INITFAT_C3_1:	SHLD	DATASTART+2
                           4199 
   F4D6 3A AC FD      [13] 4200 		LDA	SEC_PER_CLUS	;Determine the best way to divide Sectors into cluster#
   F4D9 3D            [ 4] 4201 		DCR	A
   F4DA 32 98 FD      [13] 4202 		STA	MODMASK
   F4DD 3C            [ 4] 4203 		INR	A
   F4DE CA 30 F5      [10] 4204 		JZ	INITFAT_FAIL1
   F4E1 01 00 08      [10] 4205 		LXI	B,0x0800
   F4E4 1F            [ 4] 4206 INITFAT_C4_LP:	RAR
   F4E5 D2 EA F4      [10] 4207 		JNC	INITFAT_C4_1
   F4E8 50            [ 4] 4208 		MOV	D,B		;Save location of "1" bit
   F4E9 0C            [ 4] 4209 		INR	C		;Count of 1 bits.
   F4EA 05            [ 4] 4210 INITFAT_C4_1:	DCR	B
   F4EB C2 E4 F4      [10] 4211 		JNZ	INITFAT_C4_LP
   F4EE 3E 01         [ 7] 4212 		MVI	A,1
   F4F0 B9            [ 4] 4213 		CMP	C
   F4F1 C2 04 F5      [10] 4214 		JNZ	INITFAT_C4_2	;More than 1 "1" bit, cannot do divide by simple shift.
   F4F4 7A            [ 4] 4215 		MOV	A,D		;Fetch position of the 1 bit.  8=lsb, 1=msb
   F4F5 2F            [ 4] 4216 		CMA
   F4F6 C6 0A         [ 7] 4217 		ADI	10		;Re-adjust to make 1=lsb AND 8=msb  A=9-A
   F4F8 32 93 FD      [13] 4218 		STA	DF_SHIFTCNT
   F4FB 21 18 F9      [10] 4219 		LXI	H,DIVBYSHIFT	;Use fast shift divider
   F4FE 11 28 F9      [10] 4220 		LXI	D,MODBYMASK
   F501 C3 09 F5      [10] 4221 		JMP	INITFAT_C4_3
                           4222 
   F504 21 FC F8      [10] 4223 INITFAT_C4_2:	LXI	H,DIV16BY8SPC	;Use Full Divide function for Sectors Per Cluster
   F507 E5            [12] 4224 		PUSH	H
   F508 D1            [10] 4225 		POP	D
   F509 22 91 FD      [16] 4226 INITFAT_C4_3:	SHLD	DIVIDE_FUNC
   F50C EB            [ 4] 4227 		XCHG
   F50D 22 96 FD      [16] 4228 		SHLD	MOD_FUNC
                           4229 
   F510 CD 98 F0      [18] 4230 		CALL 	PRINTI		;
   F513 20 56 4F 4C 3D 00  4231 		.ascii " VOL=\000"
   F519 21 2B FE      [10] 4232 		LXI	H,0xFE2B
   F51C 06 0B         [ 7] 4233 		MVI	B,11
   F51E CD A0 F0      [18] 4234 		CALL	PRINTB
   F521 CD 98 F0      [18] 4235 		CALL 	PRINTI		;
   F524 20 53 59 53 3D 00  4236 		.ascii " SYS=\000"
   F52A 06 08         [ 7] 4237 		MVI	B,8
   F52C CD A0 F0      [18] 4238 		CALL	PRINTB
   F52F C9            [10] 4239 		RET
                           4240 
                           4241 
   F530 CD 98 F0      [18] 4242 INITFAT_FAIL1:	CALL 	PRINTI		;
   F533 0D 0A 45 72 72 6F  4243 		.ascii "\r\nError=0 Sec/Clus\000"
        72 3D 30 20 53 65
        63 2F 43 6C 75 73
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 82
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



        00
   F546 CD 98 F0      [18] 4244 INITFAT_FAIL:	CALL 	PRINTI		;
   F549 0D 0A 46 41 54 20  4245 		.ascii "\r\nFAT Init FAILED\000"
        49 6E 69 74 20 46
        41 49 4C 45 44 00
   F55B C9            [10] 4246 		RET
                           4247 
                           4248 ;SD_CARD_TYPE	.blkb	1	;SD CARD TYPE
                           4249 ;SDC_STATUS	.blkb	1	;SD Status Code returned
                           4250 ;SD_PARAM	.blkb	4	;32 bit address parameter for SD Commands
                           4251 ;SD_PART_TYPE	.blkb	1	;SD PARTITION TYPE
                           4252 ;SD_PART_BASE	.blkb	4	;SD PARTITION STARTING RECORD
                           4253 ;SD_PART_SIZE	.blkb	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
                           4254 ;SEC_PER_CLUS	.blkb	1	;0x0D
                           4255 ;RESERVED_SEC	.blkb	2	;0x0E - 0x0F
                           4256 ;FAT_COPIES	.blkb	1	;0x10
                           4257 ;RT_DIR_ENTRIES	.blkb	2	;0x11 - 0x12
                           4258 ;TOT_FILESYS_SEC.blkb	4	;0x13 - 0x14 or 0x20 - 0x23
                           4259 ;HIDDEN_SECTORS	.blkb	4	;0x1C - 0x1F
                           4260 ;SEC_PER_FAT	.blkb	2	;0x16 - 0x17
                           4261 ;FAT1START	.blkb	4	;Calculated
                           4262 ;DIR_SECTOR	.blkb	4	;Calculated
                           4263 ;DATASTART	.blkb	4	;Calculated
                           4264 
                           4265 ;-------------------------------------------------
   F55C CD 98 F0      [18] 4266 TEST_SIGNATURE:	CALL 	PRINTI		;
   F55F 20 53 00           4267 		.ascii " S\000"
   F562 2B            [ 6] 4268 		DCX	H
   F563 3E AA         [ 7] 4269 		MVI	A,0xAA
   F565 BE            [ 7] 4270 		CMP	M
   F566 C2 46 F5      [10] 4271 		JNZ	INITFAT_FAIL
   F569 2B            [ 6] 4272 		DCX	H
   F56A 3E 55         [ 7] 4273 		MVI	A,0x55
   F56C BE            [ 7] 4274 		CMP	M
   F56D C2 46 F5      [10] 4275 		JNZ	INITFAT_FAIL
   F570 C9            [10] 4276 		RET
                           4277 
                           4278 
                           4279 ;=====================================================================================================
                           4280 ;SD Memory Car Routines, Mid Level, Send/Recieve Data Sectors (Writes out Dirty Data)
                           4281 ;=====================================================================================================
                           4282 
                           4283 ;-----------------------------------------------------------------------------------------------------
                           4284 ;Read to the SD_RAM_BUFFER from the SD Card at Sector BCDE
                           4285 ;-----------------------------------------------------------------------------------------------------
                           4286 		;Sector in SEC_PTR
   F571 21 D3 FD      [10] 4287 SD_READ_SEC:	LXI	H,SEC_PTR	;READ SECTOR
   F574 DA 7B F5      [10] 4288 		JC	SD_RS_FORCED
   F577 CD AD F8      [18] 4289 		CALL	CMP_HL_32
   F57A C8            [12] 4290 		RZ			;Return if no change to sector being read/written
                           4291 
   F57B 3A D7 FD      [13] 4292 SD_RS_FORCED:	LDA	DIRTY_DATA	;Test if flush required
   F57E B7            [ 4] 4293 		ORA	A
   F57F CA 92 F5      [10] 4294 		JZ	SD_RS_NC	;Jump if no change in SD RAM BUFFER
   F582 AF            [ 4] 4295 		XRA	A
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 83
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F583 32 D7 FD      [13] 4296 		STA	DIRTY_DATA	;Clear Write Flag
                           4297 
   F586 C5            [12] 4298 		PUSH	B
   F587 D5            [12] 4299 		PUSH	D
   F588 E5            [12] 4300 		PUSH	H
   F589 CD 87 F8      [18] 4301 		CALL	MOV_32_HL	;Fetch the last SEC_PTR
                           4302 
                           4303 
                     0000  4304 .if (DEBUG & 0x80)
                           4305    CALL SELECT_UART1
                           4306 .endif
                     0000  4307 .if (DEBUG & 2)
                           4308 	CALL PRINTI		;DEBUG
                           4309 	.ascii " Write:\000"
                           4310 	CALL	PUT_BC
                           4311 	CALL	PUT_DE
                           4312 .endif
                     0000  4313 .if (DEBUG & 0x80)
                           4314    CALL SELECT_UART0
                           4315 .endif
                           4316 
   F58C CD DB F5      [18] 4317 		CALL	SD_WRITE_SEC
                           4318 
   F58F E1            [10] 4319 		POP	H
   F590 D1            [10] 4320 		POP	D
   F591 C1            [10] 4321 		POP	B
                           4322 
   F592                    4323 SD_RS_NC:
                           4324 
                     0000  4325 .if (DEBUG & 0x80)
                           4326    CALL SELECT_UART1
                           4327 .endif
                     0000  4328 .if (DEBUG & 2)
                           4329 	CALL PRINTI		;DEBUG
                           4330 	.ascii " Read:\000"
                           4331 	CALL	PUT_BC
                           4332 	CALL	PUT_DE
                           4333 .endif
                     0000  4334 .if (DEBUG & 0x80)
                           4335    CALL SELECT_UART0
                           4336 .endif
                           4337 
                           4338 
   F592 21 D3 FD      [10] 4339 		LXI	H,SEC_PTR
   F595 CD 8F F8      [18] 4340 		CALL	MOV_HL_32	;Save Sector in SEC_PTR
   F598 CD 54 F6      [18] 4341 		CALL	SET_PARAM	;READ SECTOR
   F59B 06 05         [ 7] 4342 		MVI	B,5	;5 Retries to read
   F59D 3E 11         [ 7] 4343 SD_RS_LP0:	MVI	A,17 	;Read Sector Command
   F59F CD 74 F7      [18] 4344 		CALL	SD_CMD
   F5A2 CA AE F5      [10] 4345 		JZ	SD_RS_0
   F5A5 05            [ 4] 4346 		DCR	B
   F5A6 C2 9D F5      [10] 4347 		JNZ	SD_RS_LP0
                           4348 				;Read failed
   F5A9 05            [ 4] 4349 		DCR	B	;Clear Zero flag
   F5AA CD 5C F7      [18] 4350 		CALL	SD_DESELECT	;Deselect card
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 84
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F5AD C9            [10] 4351 		RET
   F5AE 06 00         [ 7] 4352 SD_RS_0:		MVI	B,0		;256 Attempts to recieve the DATASTART
   F5B0 CD BA F7      [18] 4353 SD_RS_LP1:	CALL	SPI_RX
   F5B3 FE FE         [ 7] 4354 		CPI	0xFE		;IS DATASTART?
   F5B5 CA C0 F5      [10] 4355 		JZ	SD_RS_1
   F5B8 05            [ 4] 4356 		DCR	B
   F5B9 C2 B0 F5      [10] 4357 		JNZ	SD_RS_LP1
   F5BC CD 5C F7      [18] 4358 		CALL	SD_DESELECT	;Deselect card
   F5BF C9            [10] 4359 		RET
                           4360 
   F5C0 01 00 02      [10] 4361 SD_RS_1:		LXI	B,0x0200
   F5C3 CD BA F7      [18] 4362 SD_RS_LP2:	CALL	SPI_RX	;Fetch 512 Bytes to M(HL)
   F5C6 77            [ 7] 4363 		MOV	M,A
   F5C7 23            [ 6] 4364 		INX	H
   F5C8 0D            [ 4] 4365 		DCR	C
   F5C9 C2 C3 F5      [10] 4366 		JNZ	SD_RS_LP2
   F5CC 05            [ 4] 4367 		DCR	B
   F5CD C2 C3 F5      [10] 4368 		JNZ	SD_RS_LP2
                           4369 
   F5D0 CD BA F7      [18] 4370 		CALL	SPI_RX	;BURN 2 BYTES (CRC)
   F5D3 CD BA F7      [18] 4371 		CALL	SPI_RX	;
   F5D6 CD 5C F7      [18] 4372 		CALL	SD_DESELECT	;Deselect card
   F5D9 AF            [ 4] 4373 		XRA	A
   F5DA C9            [10] 4374 		RET
                           4375 
                           4376 
                           4377 
                           4378 ;-----------------------------------------------------------------------------------------------------
                           4379 ;Write the SD_RAM_BUFFER to the SD Card at Sector 'SEC_PTR'
                           4380 ;-----------------------------------------------------------------------------------------------------
                           4381 		;Sector in SEC_PTR, H=SD_RAM_BUFFER
   F5DB CD 54 F6      [18] 4382 SD_WRITE_SEC:	CALL	SET_PARAM
   F5DE 3E 18         [ 7] 4383 		MVI	A,24 	;Write Sector Command
   F5E0 CD 74 F7      [18] 4384 		CALL	SD_CMD
   F5E3 3E 01         [ 7] 4385 		MVI	A,1 	;Error Code
   F5E5 C2 39 F6      [10] 4386 		JNZ	SD_WR_FAIL
                           4387 
   F5E8 3E FE         [ 7] 4388 		MVI	A,0xFE	;DATA START BLOCK
   F5EA D3 30         [10] 4389 		OUT	SPI
   F5EC 01 00 02      [10] 4390 		LXI	B,0x0200
   F5EF 7E            [ 7] 4391 SD_WR_LP:	MOV	A,M
   F5F0 23            [ 6] 4392 		INX	H
   F5F1 D3 30         [10] 4393 		OUT	SPI
   F5F3 0D            [ 4] 4394 		DCR	C
   F5F4 C2 EF F5      [10] 4395 		JNZ	SD_WR_LP
   F5F7 05            [ 4] 4396 		DCR	B
   F5F8 C2 EF F5      [10] 4397 		JNZ	SD_WR_LP
                           4398 
   F5FB 3E FF         [ 7] 4399 		MVI	A,0xFF
   F5FD D3 30         [10] 4400 		OUT	SPI
   F5FF 00            [ 4] 4401 		NOP
   F600 3E FF         [ 7] 4402 		MVI	A,0xFF
   F602 D3 30         [10] 4403 		OUT	SPI
                           4404 
   F604 CD BA F7      [18] 4405 		CALL	SPI_RX
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 85
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F607 E6 1F         [ 7] 4406 		ANI	0x1f
   F609 FE 05         [ 7] 4407 		CPI	5
   F60B 3E 02         [ 7] 4408 		MVI	A,2 	;Error Code
   F60D C2 39 F6      [10] 4409 		JNZ	SD_WR_FAIL
   F610 CD C2 F7      [18] 4410 		CALL	WAIT_NOT_BUSY
   F613 3E 03         [ 7] 4411 		MVI	A,3 	;Error Code
   F615 DA 39 F6      [10] 4412 		JC	SD_WR_FAIL
   F618 CD E4 F7      [18] 4413 		CALL	SD_CLEAR_ARG
   F61B 3E 0D         [ 7] 4414 		MVI	A,13		;SEND_STATUS
   F61D CD 74 F7      [18] 4415 		CALL	SD_CMD
   F620 3E 04         [ 7] 4416 		MVI	A,4 	;Error Code
   F622 C2 39 F6      [10] 4417 		JNZ	SD_WR_FAIL
   F625 CD BA F7      [18] 4418 		CALL	SPI_RX
   F628 B7            [ 4] 4419 		ORA	A
   F629 3E 05         [ 7] 4420 		MVI	A,5 	;Error Code
   F62B C2 39 F6      [10] 4421 		JNZ	SD_WR_FAIL
                           4422 
   F62E AF            [ 4] 4423 		XRA	A		;A should be zero
   F62F 32 D7 FD      [13] 4424 		STA	DIRTY_DATA
                           4425 
   F632 CD 6F F7      [18] 4426 		CALL	SD_DELAY
                           4427 
   F635 CD 5C F7      [18] 4428 		CALL	SD_DESELECT	;Deselect card
   F638 C9            [10] 4429 		RET
                           4430 
   F639 CD 5C F7      [18] 4431 SD_WR_FAIL:	CALL	SD_DESELECT	;Deselect card
   F63C CD 98 F0      [18] 4432 		CALL	PRINTI
   F63F 0D 0A 2D 57 72 69  4433 		.ascii "\r\n-Write Failed:\000"
        74 65 20 46 61 69
        6C 65 64 3A 00
   F650 CD 70 F0      [18] 4434 		CALL	PUT_BYTE
   F653 C9            [10] 4435 		RET
                           4436 
                           4437 ;-----------------------------------------------------------------------------------------------------
                           4438 ;Input:	Sector in 32 bit register BCDE
   F654 3A 9B FD      [13] 4439 SET_PARAM:	LDA	SD_CARD_TYPE	;IF CARD_TYPE <> 3 THEN SHIFT SECTOR << 9 Bits
   F657 FE 03         [ 7] 4440 		CPI	3
   F659 CA 65 F6      [10] 4441 		JZ	SP_RET
                           4442 
   F65C 79            [ 4] 4443 		MOV	A,C
   F65D EB            [ 4] 4444 		XCHG
   F65E 29            [10] 4445 		DAD	H
   F65F 17            [ 4] 4446 		RAL
   F660 47            [ 7] 4447 		MOV	B,A
   F661 4C            [ 4] 4448 		MOV	C,H
   F662 55            [ 4] 4449 		MOV	D,L
   F663 1E 00         [ 7] 4450 		MVI	E,0
                           4451 
   F665 21 9D FD      [10] 4452 SP_RET:		LXI	H,SD_PARAM
   F668 CD 8F F8      [18] 4453 		CALL	MOV_HL_32	;Save Parameter
   F66B 21 00 FE      [10] 4454 		LXI	H,SD_RAM_BUFFER	;Set buffer space
   F66E C9            [10] 4455 		RET
                           4456 
                           4457 
                           4458 ;=====================================================================================================
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 86
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           4459 ;SD Memory Car Routines, Low Level, INIT CARD, Send/Recieve Data, Send Commands
                           4460 ;=====================================================================================================
                           4461 ;-------------------------------- INIT SDCARD --------------------------------
   F66F CD 5C F7      [18] 4462 INIT_SDCARD:	CALL	SD_DESELECT	;Deselect and clock the card many cycles
   F672 0E 80         [ 7] 4463 		MVI	C,0x80
   F674 3E FF         [ 7] 4464 		MVI	A,0xFF
   F676 32 9B FD      [13] 4465 		STA	SD_CARD_TYPE
   F679 D3 30         [10] 4466 ISD_0:		OUT	SPI		;CLOCK many cycles
   F67B 0D            [ 4] 4467 		DCR	C
   F67C C2 79 F6      [10] 4468 		JNZ	ISD_0
   F67F CD 63 F7      [18] 4469 		CALL	SD_SELECT
                           4470 
   F682 CD 98 F0      [18] 4471 		CALL 	PRINTI		;
   F685 0D 0A 49 6E 69 74  4472 		.ascii "\r\nInit SD\000"
        20 53 44 00
                           4473 
   F68F CD E4 F7      [18] 4474 		CALL	SD_CLEAR_ARG	;Fetch the 01 response
   F692 06 00         [ 7] 4475 		MVI	B,0		;256 retries
   F694 3E 00         [ 7] 4476 ISD_LP1:		MVI	A,0		;CMD 0
   F696 CD 74 F7      [18] 4477 		CALL	SD_CMD
   F699 FE 01         [ 7] 4478 		CPI	1		;Test 01 response
   F69B CA B3 F6      [10] 4479 		JZ	ISD_1
   F69E 05            [ 4] 4480 		DCR	B
   F69F C2 94 F6      [10] 4481 		JNZ	ISD_LP1
                           4482 		;JMP	INIT_FAIL
   F6A2 CD 98 F0      [18] 4483 INIT_FAIL:	CALL 	PRINTI		;
   F6A5 2D 46 41 49 4C 45  4484 		.ascii "-FAILED\000"
        44 00
   F6AD CD 5C F7      [18] 4485 		CALL	SD_DESELECT
   F6B0 AF            [ 4] 4486 		XRA	A		;Return Zero Flag cleared = Failure
   F6B1 3D            [ 4] 4487 		DCR	A
   F6B2 C9            [10] 4488 		RET
                           4489 
   F6B3 CD 98 F0      [18] 4490 ISD_1:		CALL 	PRINTI		;
   F6B6 20 54 79 70 65 23  4491 		.ascii " Type#\000"
        00
   F6BD 21 AA 01      [10] 4492 		LXI	H,0x01AA		;Deterimine Card Type
   F6C0 22 9D FD      [16] 4493 		SHLD	SD_PARAM
   F6C3 3E 08         [ 7] 4494 		MVI	A,8		;CMD 8
   F6C5 CD 74 F7      [18] 4495 		CALL	SD_CMD
   F6C8 E6 04         [ 7] 4496 		ANI	4
   F6CA CA D5 F6      [10] 4497 		JZ	ISD_2
   F6CD 3E 01         [ 7] 4498 		MVI	A,1		;If CMD8 is Illegal Cmd, CARD_TYPE=1
   F6CF 32 9B FD      [13] 4499 		STA	SD_CARD_TYPE
   F6D2 C3 F0 F6      [10] 4500 		JMP	ISD_3
                           4501 
   F6D5 CD BA F7      [18] 4502 ISD_2:		CALL	SPI_RX
   F6D8 CD BA F7      [18] 4503 		CALL	SPI_RX
   F6DB CD BA F7      [18] 4504 		CALL	SPI_RX
   F6DE CD BA F7      [18] 4505 		CALL	SPI_RX
   F6E1 32 9C FD      [13] 4506 		STA	SDC_STATUS
   F6E4 FE AA         [ 7] 4507 		CPI	0xAA
   F6E6 3E AA         [ 7] 4508 		MVI	A,0xAA		;Error code
   F6E8 C2 A2 F6      [10] 4509 		JNZ	INIT_FAIL
   F6EB 3E 02         [ 7] 4510 		MVI	A,2
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 87
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F6ED 32 9B FD      [13] 4511 		STA	SD_CARD_TYPE
                           4512 
   F6F0 CD 7F F0      [18] 4513 ISD_3:		CALL	PUT_HEX
   F6F3 CD 98 F0      [18] 4514 		CALL 	PRINTI		;
   F6F6 20 41 43 4D 44 34  4515 		.ascii " ACMD41\000"
        31 00
   F6FE CD E4 F7      [18] 4516 		CALL	SD_CLEAR_ARG
                           4517 
   F701 06 00         [ 7] 4518 		MVI	B,0
   F703 3E 37         [ 7] 4519 ISD_LP2:		MVI	A,55		;CMD 55 (ACMD)
   F705 CD 74 F7      [18] 4520 		CALL	SD_CMD
   F708 3E 29         [ 7] 4521 		MVI	A,41		;CMD 41
   F70A CD 74 F7      [18] 4522 		CALL	SD_CMD
   F70D FE 00         [ 7] 4523 		CPI	0
   F70F CA 1D F7      [10] 4524 		JZ	ISD_4
   F712 AF            [ 4] 4525 		XRA	A		;256 ~= 2mSec Delay
   F713 CD 6F F7      [18] 4526 		CALL	SD_DELAY
   F716 05            [ 4] 4527 		DCR	B
   F717 C2 03 F7      [10] 4528 		JNZ	ISD_LP2
   F71A C3 A2 F6      [10] 4529 		JMP	INIT_FAIL
                           4530 
   F71D CD 98 F0      [18] 4531 ISD_4:		CALL 	PRINTI		;
   F720 2B 00              4532 		.ascii "+\000"
   F722 3A 9B FD      [13] 4533 		LDA	SD_CARD_TYPE
   F725 FE 02         [ 7] 4534 		CPI	2
   F727 C2 57 F7      [10] 4535 		JNZ	ISD_6
   F72A 3E 3A         [ 7] 4536 		MVI	A,58		;CMD 58
   F72C CD 74 F7      [18] 4537 		CALL	SD_CMD
   F72F FE 00         [ 7] 4538 		CPI	0
   F731 C2 A2 F6      [10] 4539 		JNZ	INIT_FAIL
   F734 CD BA F7      [18] 4540 		CALL	SPI_RX
   F737 E6 C0         [ 7] 4541 		ANI	0xC0
   F739 FE C0         [ 7] 4542 		CPI	0xC0
   F73B C2 4E F7      [10] 4543 		JNZ	ISD_5
   F73E 3E 03         [ 7] 4544 		MVI	A,3
   F740 32 9B FD      [13] 4545 		STA	SD_CARD_TYPE
   F743 CD 98 F0      [18] 4546 		CALL 	PRINTI		;
   F746 20 54 79 70 65 23  4547 		.ascii " Type#3\000"
        33 00
   F74E CD BA F7      [18] 4548 ISD_5:		CALL	SPI_RX
   F751 CD BA F7      [18] 4549 		CALL	SPI_RX
   F754 CD BA F7      [18] 4550 		CALL	SPI_RX
                           4551 
   F757 CD 5C F7      [18] 4552 ISD_6:		CALL	SD_DESELECT
   F75A AF            [ 4] 4553 		XRA	A		;Set Zero Flag = Success
   F75B C9            [10] 4554 		RET
                           4555 
                           4556 ;-----------------------------------------------------------------------------------------------------
   F75C F5            [12] 4557 SD_DESELECT:	PUSH	PSW
   F75D 3E 01         [ 7] 4558 		MVI	A,1	;Deselect SDCARD
   F75F D3 31         [10] 4559 		OUT	SPI_SS
   F761 F1            [10] 4560 		POP	PSW
   F762 C9            [10] 4561 		RET
                           4562 
                           4563 ;-----------------------------------------------------------------------------------------------------
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 88
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F763 F5            [12] 4564 SD_SELECT:	PUSH	PSW
   F764 3E 00         [ 7] 4565 		MVI	A,0	;Select SDCARD
   F766 D3 31         [10] 4566 		OUT	SPI_SS
   F768 CD 6D F7      [18] 4567 		CALL	SD_DELAY100
   F76B F1            [10] 4568 		POP	PSW
   F76C C9            [10] 4569 		RET
                           4570 
                           4571 ;-----------------------------------------------------------------------------------------------------
   F76D 3E 0D         [ 7] 4572 SD_DELAY100:	MVI	A,13	 ;Small delay after selecting card
   F76F 3D            [ 4] 4573 SD_DELAY:	DCR	A	 ;5
   F770 C2 6F F7      [10] 4574 		JNZ	SD_DELAY ;10    15*13 ~= 200 ~= 100uSec
   F773 C9            [10] 4575 		RET
                           4576 
                           4577 ;-----------------------------------------------------------------------------------------------------
                           4578 ;Send command to SD card
   F774 C5            [12] 4579 SD_CMD:		PUSH	B
   F775 CD 63 F7      [18] 4580 		CALL	SD_SELECT
   F778 CD C2 F7      [18] 4581 		CALL	WAIT_NOT_BUSY
                           4582 
   F77B 06 FF         [ 7] 4583 		MVI	B,0xFF	;Default CRC
   F77D FE 00         [ 7] 4584 		CPI	0
   F77F C2 84 F7      [10] 4585 		JNZ	SDC_1
   F782 06 95         [ 7] 4586 		MVI	B,0x95
   F784 FE 08         [ 7] 4587 SDC_1:		CPI	8
   F786 C2 8B F7      [10] 4588 		JNZ	SDC_2
   F789 06 87         [ 7] 4589 		MVI	B,0x87
   F78B                    4590 SDC_2:
   F78B F6 40         [ 7] 4591 		ORI	0x40	;All Commands start with 0x40
   F78D D3 30         [10] 4592 		OUT	SPI
   F78F 3A A0 FD      [13] 4593 		LDA	SD_PARAM+3
   F792 D3 30         [10] 4594 		OUT	SPI
   F794 3A 9F FD      [13] 4595 		LDA	SD_PARAM+2
   F797 D3 30         [10] 4596 		OUT	SPI
   F799 3A 9E FD      [13] 4597 		LDA	SD_PARAM+1
   F79C D3 30         [10] 4598 		OUT	SPI
   F79E 3A 9D FD      [13] 4599 		LDA	SD_PARAM
   F7A1 D3 30         [10] 4600 		OUT	SPI
   F7A3 00            [ 4] 4601 		NOP
   F7A4 78            [ 4] 4602 		MOV	A,B
   F7A5 D3 30         [10] 4603 		OUT	SPI
                           4604 
   F7A7 06 00         [ 7] 4605 		MVI	B,0
   F7A9 CD BA F7      [18] 4606 SDC_LP:		CALL	SPI_RX	;Read Respsonse?
   F7AC 32 9C FD      [13] 4607 		STA	SDC_STATUS
   F7AF B7            [ 4] 4608 		ORA	A
   F7B0 F2 B8 F7      [10] 4609 		JP	SDC_RET
   F7B3 05            [ 4] 4610 		DCR	B
   F7B4 C2 A9 F7      [10] 4611 		JNZ	SDC_LP
   F7B7 B7            [ 4] 4612 		ORA	A
   F7B8 C1            [10] 4613 SDC_RET:		POP	B
   F7B9 C9            [10] 4614 		RET
                           4615 
                           4616 ;-----------------------------------------------------------------------------------------------------
                           4617 ;------------------------------- Receive a byte from SPI
   F7BA 3E FF         [ 7] 4618 SPI_RX:		MVI	A,0xFF	;Read Respsonse
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 89
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F7BC D3 30         [10] 4619 		OUT	SPI
   F7BE 00            [ 4] 4620 		NOP		;4
   F7BF DB 30         [10] 4621 		IN	SPI	;10
   F7C1 C9            [10] 4622 		RET
                           4623 
                           4624 ;-----------------------------------------------------------------------------------------------------
                           4625 ;------------------------------- Wait until FF's come back from Card (ie NOT BUSY)
   F7C2 F5            [12] 4626 WAIT_NOT_BUSY:	PUSH	PSW	;Do not destroy Acc
   F7C3 C5            [12] 4627 		PUSH	B	;Fetch 1 consecutive FF's to be sure SD card NOT BUSY
   F7C4 06 00         [ 7] 4628 		MVI	B,0
   F7C6 0E 01         [ 7] 4629 WNB_LP:		MVI	C,1	;Set count for 1 trys
   F7C8 CD BA F7      [18] 4630 WNB_LP2:		CALL	SPI_RX
   F7CB 3C            [ 4] 4631 		INR	A
   F7CC C2 D8 F7      [10] 4632 		JNZ	WNB_0	;NOT FF RETURNED, JUMP TO COUNT DOWN TRYS
   F7CF 0D            [ 4] 4633 		DCR	C	;Count Down Consecutive FF's
   F7D0 C2 C8 F7      [10] 4634 		JNZ	WNB_LP2
   F7D3 C1            [10] 4635 		POP	B
   F7D4 F1            [10] 4636 		POP	PSW
   F7D5 37            [ 4] 4637 		STC		;Return NOT BUSY (Clear Carry)
   F7D6 3F            [ 4] 4638 		CMC
   F7D7 C9            [10] 4639 		RET
                           4640 
   F7D8 AF            [ 4] 4641 WNB_0:		XRA	A
   F7D9 CD 6F F7      [18] 4642 		CALL	SD_DELAY
   F7DC 05            [ 4] 4643 		DCR	B	;Count Down Trys
   F7DD C2 C6 F7      [10] 4644 		JNZ	WNB_LP
   F7E0 C1            [10] 4645 		POP	B
   F7E1 F1            [10] 4646 		POP	PSW
   F7E2 37            [ 4] 4647 		STC		;Return STILL BUSY (Set Carry)
   F7E3 C9            [10] 4648 		RET
                           4649 
                           4650 ;-----------------------------------------------------------------------------------------------------
   F7E4 AF            [ 4] 4651 SD_CLEAR_ARG:	XRA	A
   F7E5 32 9D FD      [13] 4652 		STA	SD_PARAM
   F7E8 32 9E FD      [13] 4653 		STA	SD_PARAM+1
   F7EB 32 9F FD      [13] 4654 		STA	SD_PARAM+2
   F7EE 32 A0 FD      [13] 4655 		STA	SD_PARAM+3
   F7F1 C9            [10] 4656 		RET
                           4657 
                           4658 
                           4659 ;=====================================================================================================
                           4660 ;General Support Routines, Strings
                           4661 ;=====================================================================================================
                           4662 
                           4663 ;-----------------------------------------------------------------------------------------------------
   F7F2 CD 98 F0      [18] 4664 INPUT_FNAME:	CALL 	PRINTI		;Display Menu Prompt
   F7F5 0D 0A 45 4E 54 45  4665 		.ascii "\r\nENTER 8.3 FILE NAME> \000"
        52 20 38 2E 33 20
        46 49 4C 45 20 4E
        41 4D 45 3E 20 00
   F80D 21 C8 FD      [10] 4666 		LXI	H,FILENAME
   F810 06 0B         [ 7] 4667 		MVI	B,11
   F812 3E 20         [ 7] 4668 		MVI	A," "
   F814 CD F0 F8      [18] 4669 		CALL	FILL_BLOCK
   F817 0E 2E         [ 7] 4670 		MVI	C,"."
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 90
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F819 06 08         [ 7] 4671 		MVI	B,8
   F81B CD 61 F8      [18] 4672 		CALL	GET_STRING
   F81E D8            [12] 4673 		RC
   F81F FE 0D         [ 7] 4674 		CPI	13
   F821 C8            [12] 4675 		RZ
   F822 21 D0 FD      [10] 4676 		LXI	H,FILEEXT
   F825 06 03         [ 7] 4677 		MVI	B,3
   F827 CD 61 F8      [18] 4678 		CALL	GET_STRING
   F82A C9            [10] 4679 		RET
                           4680 
                           4681 ;-----------------------------------------------------------------------------------------------------
                           4682 ;	Prints Filename at HL
                           4683 ;-----------------------------------------------------------------------------------------------------
   F82B E5            [12] 4684 PRINT_FILENAME:	PUSH	H
   F82C 06 08         [ 7] 4685 		MVI	B,8
   F82E 7E            [ 7] 4686 PF_LP1:		MOV	A,M
   F82F B7            [ 4] 4687 		ORA	A
   F830 CA 40 F8      [10] 4688 		JZ	PFE
   F833 FE 20         [ 7] 4689 		CPI	" "
   F835 CA 40 F8      [10] 4690 		JZ	PFE
   F838 CD EB F0      [18] 4691 		CALL	PUT_CHAR
   F83B 23            [ 6] 4692 		INX	H
   F83C 05            [ 4] 4693 		DCR	B
   F83D C2 2E F8      [10] 4694 		JNZ	PF_LP1
   F840 3E 2E         [ 7] 4695 PFE:		MVI	A,"."
   F842 CD EB F0      [18] 4696 		CALL	PUT_CHAR
   F845 E1            [10] 4697 		POP	H
   F846 E5            [12] 4698 		PUSH	H
   F847 01 08 00      [10] 4699 		LXI	B,8
   F84A 09            [10] 4700 		DAD	B
   F84B 06 03         [ 7] 4701 		MVI	B,3
   F84D 7E            [ 7] 4702 PF_LP2:		MOV	A,M
   F84E B7            [ 4] 4703 		ORA	A
   F84F CA 5F F8      [10] 4704 		JZ	PF_RET
   F852 FE 20         [ 7] 4705 		CPI	" "
   F854 CA 5F F8      [10] 4706 		JZ	PF_RET
   F857 CD EB F0      [18] 4707 		CALL	PUT_CHAR
   F85A 23            [ 6] 4708 		INX	H
   F85B 05            [ 4] 4709 		DCR	B
   F85C C2 4D F8      [10] 4710 		JNZ	PF_LP2
   F85F E1            [10] 4711 PF_RET:		POP	H
   F860 C9            [10] 4712 		RET
                           4713 
                           4714 ;-----------------------------------------------------------------------------------------------------
   F861 CD D8 F0      [18] 4715 GET_STRING:	CALL	GET_CHAR
   F864 FE 1B         [ 7] 4716 		CPI	27
   F866 37            [ 4] 4717 		STC			;Set Carry to indicate Abort
   F867 C8            [12] 4718 		RZ
   F868 FE 0D         [ 7] 4719 		CPI	13		;Exit on <CR>
   F86A C8            [12] 4720 		RZ
   F86B B9            [ 4] 4721 		CMP	C		;Exit on Selectable Char (dot for file input)
   F86C C8            [12] 4722 		RZ
   F86D CD 7E F8      [18] 4723 		CALL	TO_UPPER
   F870 FE 21         [ 7] 4724 		CPI	" "+1		;Test if ACC is Control or Space
   F872 DA 61 F8      [10] 4725 		JC	GET_STRING	;Skip such characters
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 91
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F875 05            [ 4] 4726 		DCR	B
   F876 04            [ 4] 4727 		INR	B		;Exit if B charcters are already inputed
   F877 C8            [12] 4728 		RZ			;Exit if no more characters allowed
   F878 77            [ 7] 4729 		MOV	M,A
   F879 23            [ 6] 4730 		INX	H
   F87A 05            [ 4] 4731 		DCR	B
   F87B C3 61 F8      [10] 4732 		JMP	GET_STRING
                           4733 
                           4734 ;-----------------------------------------------------------------------------------------------------
   F87E FE 61         [ 7] 4735 TO_UPPER:	CPI	"a"
   F880 D8            [12] 4736 		RC		;Return if ACC < 'a'
   F881 FE 7B         [ 7] 4737 		CPI	"z"+1
   F883 D0            [12] 4738 		RNC		;Return if ACC > 'z'
   F884 E6 5F         [ 7] 4739 		ANI	0x5F	;Flag upper case
   F886 C9            [10] 4740 		RET
                           4741 
                           4742 
                           4743 
                           4744 ;=====================================================================================================
                           4745 ;General Support Routines, 32 Bit stuff and other math
                           4746 ;=====================================================================================================
                           4747 
                           4748 ;------------------------- Move (HL) to 32 bit register BCDE
   F887 5E            [ 7] 4749 MOV_32_HL:	MOV	E,M
   F888 23            [ 6] 4750 		INX	H
   F889 56            [ 4] 4751 		MOV	D,M
   F88A 23            [ 6] 4752 		INX	H
   F88B 4E            [ 7] 4753 		MOV	C,M
   F88C 23            [ 6] 4754 		INX	H
   F88D 46            [ 4] 4755 		MOV	B,M
   F88E C9            [10] 4756 		RET
                           4757 
                           4758 ;------------------------- Move 32 bit register BCDE to (HL)
   F88F 73            [ 7] 4759 MOV_HL_32:	MOV	M,E
   F890 23            [ 6] 4760 		INX	H
   F891 72            [ 7] 4761 		MOV	M,D
   F892 23            [ 6] 4762 		INX	H
   F893 71            [ 7] 4763 		MOV	M,C
   F894 23            [ 6] 4764 		INX	H
   F895 70            [ 7] 4765 		MOV	M,B
   F896 C9            [10] 4766 		RET
                           4767 
                           4768 ;------------------------- ADD (HL) to 32 bit register BCDE
   F897 7B            [ 4] 4769 ADD_32_HL:	MOV	A,E
   F898 86            [ 7] 4770 		ADD	M
   F899 5F            [ 4] 4771 		MOV	E,A
   F89A 23            [ 6] 4772 		INX	H
   F89B 7A            [ 4] 4773 		MOV	A,D
   F89C 8E            [ 7] 4774 		ADC	M
   F89D 57            [ 7] 4775 		MOV	D,A
   F89E 23            [ 6] 4776 		INX	H
   F89F 79            [ 4] 4777 		MOV	A,C
   F8A0 8E            [ 7] 4778 		ADC	M
   F8A1 4F            [ 4] 4779 		MOV	C,A
   F8A2 23            [ 6] 4780 		INX	H
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 92
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F8A3 78            [ 4] 4781 		MOV	A,B
   F8A4 8E            [ 7] 4782 		ADC	M
   F8A5 47            [ 7] 4783 		MOV	B,A
   F8A6 C9            [10] 4784 		RET
                           4785 
                           4786 ;-----------------------------------------------------------------------------------------------------
   F8A7 13            [ 6] 4787 INC_32:		INX	D
   F8A8 7A            [ 4] 4788 		MOV	A,D
   F8A9 B3            [ 4] 4789 		ORA	E
   F8AA C0            [12] 4790 		RNZ
   F8AB 03            [ 6] 4791 		INX	B
   F8AC C9            [10] 4792 		RET
                           4793 
                           4794 ;-----------------------------------------------------------------------------------------------------
                           4795 ;Compare BCDE with 32bit word at HL
   F8AD 23            [ 6] 4796 CMP_HL_32:	INX	H		;Point to MSB
   F8AE 23            [ 6] 4797 		INX	H
   F8AF 23            [ 6] 4798 		INX	H
   F8B0 78            [ 4] 4799 		MOV	A,B		;Compare with B
   F8B1 BE            [ 7] 4800 		CMP	M
   F8B2 C2 C5 F8      [10] 4801 		JNZ	CH3_R1
   F8B5 2B            [ 6] 4802 		DCX	H
   F8B6 79            [ 4] 4803 		MOV	A,C
   F8B7 BE            [ 7] 4804 		CMP	M
   F8B8 C2 C6 F8      [10] 4805 		JNZ	CH3_R2
   F8BB 2B            [ 6] 4806 		DCX	H
   F8BC 7A            [ 4] 4807 		MOV	A,D
   F8BD BE            [ 7] 4808 		CMP	M
   F8BE C2 C7 F8      [10] 4809 		JNZ	CH3_R3
   F8C1 2B            [ 6] 4810 		DCX	H
   F8C2 7B            [ 4] 4811 		MOV	A,E
   F8C3 BE            [ 7] 4812 		CMP	M
   F8C4 C9            [10] 4813 		RET
   F8C5 2B            [ 6] 4814 CH3_R1:		DCX	H
   F8C6 2B            [ 6] 4815 CH3_R2:		DCX	H
   F8C7 2B            [ 6] 4816 CH3_R3:		DCX	H
   F8C8 C9            [10] 4817 		RET
                           4818 
                           4819 ;------------------------- COMPARE DE WITH HL
   F8C9 7A            [ 4] 4820 CMP_DE_HL:	MOV	A,D		;Compare the MSB first
   F8CA BC            [ 4] 4821 		CMP	H
   F8CB C0            [12] 4822 		RNZ
   F8CC 7B            [ 4] 4823 		MOV	A,E
   F8CD BD            [ 4] 4824 		CMP	L
   F8CE C9            [10] 4825 		RET
                           4826 
                           4827 
                           4828 ;------------------------- SHIFT HL RIGHT ( 0 -> HL -> C )
   F8CF B7            [ 4] 4829 RHLR:		ORA	A		;Clear Carry
   F8D0 7C            [ 4] 4830 		MOV	A,H
   F8D1 1F            [ 4] 4831 		RAR
   F8D2 67            [ 7] 4832 		MOV	H,A
   F8D3 7D            [ 4] 4833 		MOV	A,L
   F8D4 1F            [ 4] 4834 		RAR
   F8D5 6F            [ 4] 4835 		MOV	L,A
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 93
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F8D6 05            [ 4] 4836 		DCR	B
   F8D7 C2 CF F8      [10] 4837 		JNZ	RHLR
   F8DA C9            [10] 4838 		RET
                           4839 
                           4840 ;-----------------------------------------------------------------------------------------------------
   F8DB 06 02         [ 7] 4841 COPY_RAM2:	MVI	B,2	;2 BYTES
   F8DD C3 E2 F8      [10] 4842 		JMP	COPY_RAM
   F8E0 06 04         [ 7] 4843 COPY_RAM4:	MVI	B,4	;4 BYTES PER WORD
   F8E2 7E            [ 7] 4844 COPY_RAM:	MOV	A,M
   F8E3 12            [ 7] 4845 		STAX	D
   F8E4 23            [ 6] 4846 		INX	H
   F8E5 13            [ 6] 4847 		INX	D
   F8E6 05            [ 4] 4848 		DCR	B
   F8E7 C2 E2 F8      [10] 4849 		JNZ	COPY_RAM
   F8EA C9            [10] 4850 		RET
                           4851 
                           4852 ;-----------------------------------------------------------------------------------------------------
                           4853 		;HL = (HL) word at memory location HL
   F8EB 7E            [ 7] 4854 LD_HL_HL:	MOV	A,M		;Fetch L from (HL)
   F8EC 23            [ 6] 4855 		INX	H
   F8ED 66            [ 4] 4856 		MOV	H,M		;Fetch H from (HL+1)
   F8EE 6F            [ 4] 4857 		MOV	L,A
   F8EF C9            [10] 4858 		RET
                           4859 
                           4860 ;-----------------------------------------------------------------------------------------------------
                           4861 ;	FILL_BLOCK, Fills a block of RAM with value in A
                           4862 ;	Input:	A = value
                           4863 ;		HL = Start Address
                           4864 ;		B = Length of Fill (MAX = 0 = 256 bytes)
                           4865 ;-----------------------------------------------------------------------------------------------------
   F8F0 C5            [12] 4866 FILL_BLOCK:	PUSH	B
   F8F1 E5            [12] 4867 		PUSH	H
   F8F2 77            [ 7] 4868 FB_LP:		MOV	M,A
   F8F3 23            [ 6] 4869 		INX	H
   F8F4 05            [ 4] 4870 		DCR	B
   F8F5 C2 F2 F8      [10] 4871 		JNZ	FB_LP
   F8F8 E1            [10] 4872 		POP	H
   F8F9 C1            [10] 4873 		POP	B
   F8FA C9            [10] 4874 		RET
                           4875 
                           4876 ;-----------------------------------------------------------------------------------------------------
   F8FB E9            [ 6] 4877 VCALL:		PCHL		;Jump to HL
                           4878 
                           4879 ;-----------------------------------------------------------------------------------------------------
                           4880 ;Maximum number to divide is Logical Sector 2001/4 = 500
                           4881 ;If dividing by powers of 2, then we can shift the number for fast divide
   F8FC 3A AC FD      [13] 4882 DIV16BY8SPC:	LDA	SEC_PER_CLUS
                           4883 ;Input:	DE=Dividend, A=Divisor
                           4884 ;Out:	DE=Result, A=Remainder
   F8FF EB            [ 4] 4885 DIV16BY8:	XCHG		; HL = Dividend
   F900 1E 00         [ 7] 4886 		MVI	E,00	; Quotient = 0
                           4887 		;LHLD	2200H	; Get Dividend
                           4888 		;LDA	2300	; Get Divisor
   F902 47            [ 7] 4889 		MOV	B, A	; Store        Divisor
   F903 0E 08         [ 7] 4890 		MVI	C, 08	; Count = 8
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 94
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   F905 29            [10] 4891 DIV16BY8_LP:	DAD H		; Dividend = Dividend x 2
   F906 7B            [ 4] 4892 		MOV	A, E
   F907 07            [ 4] 4893 		RLC
   F908 5F            [ 4] 4894 		MOV	E, A	; Quotient = Quotient x 2
   F909 7C            [ 4] 4895 		MOV	A, H
   F90A 90            [ 4] 4896 		SUB	B	; Is most significant byte of Dividend > divisor
   F90B DA 10 F9      [10] 4897 		JC	DIV16BY8_SK	; No, go to Next step
   F90E 67            [ 7] 4898 		MOV	H, A	; Yes, subtract divisor
   F90F 1C            [ 4] 4899 		INR	E	; and Quotient = Quotient + 1
   F910 0D            [ 4] 4900 DIV16BY8_SK:	DCR	C	; Count = Count - 1
   F911 C2 05 F9      [10] 4901 		JNZ	DIV16BY8_LP ; Is count =0 repeat
                           4902 		;MOV	A, E
                           4903 		;STA	2401H	; Store Quotient
   F914 7C            [ 4] 4904 		MOV	A, H
                           4905 		;STA	2410H	; Store remainder
   F915 16 00         [ 7] 4906 		MVI	D,0	; Quotient in DE
   F917 C9            [10] 4907 		RET
                           4908 
                           4909 ;-----------------------------------------------------------------------------------------------------
   F918 3A 93 FD      [13] 4910 DIVBYSHIFT:	LDA	DF_SHIFTCNT	; DE = Dividend
   F91B 47            [ 7] 4911 		MOV	B,A
   F91C 05            [ 4] 4912 DBS_LP:		DCR	B
   F91D C8            [12] 4913 		RZ
   F91E B7            [ 4] 4914 		ORA	A	;Clear Carry
   F91F 7A            [ 4] 4915 		MOV	A,D
   F920 1F            [ 4] 4916 		RAR
   F921 57            [ 7] 4917 		MOV	D,A
   F922 7B            [ 4] 4918 		MOV	A,E
   F923 1F            [ 4] 4919 		RAR
   F924 5F            [ 4] 4920 		MOV	E,A
   F925 C3 1C F9      [10] 4921 		JMP	DBS_LP
                           4922 
                           4923 ;-----------------------------------------------------------------------------------------------------
   F928 3A 98 FD      [13] 4924 MODBYMASK:	LDA	MODMASK
   F92B A3            [ 4] 4925 		ANA	E
   F92C C9            [10] 4926 		RET
                           4927 
                           4928 
                           4929 ;-----------------------------------------------------------------------------------------------------
                           4930 
                           4931 
                           4932 
                           4933 ;----------------------------------------------------------------------------------------------------; RAM SPACE
                           4934 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           4935 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           4936 ;----------------------------------------------------------------------------------------------------; RAM SPACE
   FA00                    4937 		.ORG	0xFA00
                     FA00  4938 TEMP_STACK	.EQU	.	;Temp stack at 0xFA00 (grows downward)
                           4939 		;.DSEG
                           4940 		;DEFINE RAM AREAS FOR BDOS OPERATION
   FA00                    4941 DIRBUF:	.blkb	128
   FA80                    4942 ALV0:	.blkb	31
   FA9F                    4943 CSV0:	.blkb	16
   FAAF                    4944 ALV1:	.blkb	31
   FACE                    4945 CSV1:	.blkb	16
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 95
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   FADE                    4946 ALV2:	.blkb	31
   FAFD                    4947 CSV2:	.blkb	16
   FB0D                    4948 ALV3:	.blkb	31
   FB2C                    4949 CSV3:	.blkb	16
                           4950 ;
                           4951 
                     FB3C  4952 LOWSTACK	.EQU	.
                           4953 
                           4954 
   FD00                    4955 		.ORG	0xFD00
   FD00                    4956 HIGHSTACK:			;Stack starts saveing at FCFFh and grows downward
                           4957 
                     01C4  4958 STACK_SIZE	.EQU	HIGHSTACK-LOWSTACK
                           4959 
                           4960 ;SDFCB:
                           4961 ;FSTAT		.blkb	1	;+0  Status of FCB, 00=File Not Open
                           4962 ;FNAME		.blkb	11	;+1
                           4963 ;AFClus0	.blkb	2	;+12 First Cluster of File as given by the Directory Entry.
                           4964 ;CRFClus	.blkb	2	;+14 Current Relative Cluster location in file, (0 to F for a system with 32 Sectors per Cluster)
                           4965 ;CAFClus	.blkb	2	;+16 Current Absolute Cluster location in file, set to AFClus0, then updated with FAT
                           4966 ;RFSec		.blkb	2	;+18 Relative Sector being addressed (0 to 500, based 26 sectors per track and 77 tracks Divide by 4)
                           4967 ;SSOC		.blkb	4	;+20 Starting Sector of Cluster, this is the first Sector for that Cluster
                           4968 ;ABS_SEC	.blkb	4	;+24 Absolute Sector of Current Relative Sector
                           4969 ;RESV		.blkb	4	;Filler for 32 bytes
   FD00                    4970 SDISKA:		.blkb	32	;File Control Blocks for Disks A to D
   FD20                    4971 SDISKB:		.blkb	32
   FD40                    4972 SDISKC:		.blkb	32
   FD60                    4973 SDISKD:		.blkb	32
                           4974 
                           4975 
                           4976 
                           4977 ; SPECIAL FLAGS.
   FD80                    4978 CONOTF:		.blkb  1	;NO-PRINT FLAG (WHEN FF).
   FD81                    4979 ECHO_ON:		.blkb	1	;Echo characters
   FD82                    4980 PROP_CHECK:	.blkb	1	;Enable Propeller board when not zero
   FD83                    4981 FCB_PTR:		.blkb	2	;Points to current FCB in use
   FD85                    4982 SEC_PER_TRACK:	.blkb	2	;Sectors Per Track
                           4983 
                     FD87  4984 CLEAR_RAM	.EQU	.	;Clear all RAM after this point on INIT
                           4985 
   FD87                    4986 XMSEQ:		.blkb	1	;XMODEM SEQUENCE NUMBER
   FD88                    4987 XMTYPE:		.blkb	1	;XMODEM BLOCK TYPE (CRC/CS)
   FD89                    4988 XSECTOR:		.blkb	1	;Sector of xmodem transfer
   FD8A                    4989 XTRACK:		.blkb	1	;Track of xmodem transfer
   FD8B                    4990 XCOUNT:		.blkb	2	;Count of sectors to read
   FD8D                    4991 XSUM:		.blkb	2	;Sum of Staring Sector & Count
   FD8F                    4992 XPOS:		.blkb	2	;Position of next read/write logical sector
                           4993 
   FD91                    4994 DIVIDE_FUNC:	.blkb	2	;Pointer to the Divide Function
   FD93                    4995 DF_SHIFTCNT:	.blkb	1	;Count of shifts required for Fast Divide
   FD94                    4996 MUL8:		.blkb	1	;8 bit multiplier
   FD95                    4997 M_COUNTER:	.blkb	1	;8 bit counter for multiply routine
   FD96                    4998 MOD_FUNC:	.blkb	2	;Pointer to the Mod Function
   FD98                    4999 MODMASK:		.blkb	1	;8 bit mask to get Relative Sector within a cluster from a Relative File sector
                           5000 
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 96
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



   FD99                    5001 LOGICAL_SEC:	.blkb	2	;Logical Sector for next Read/Write Operation
                           5002 
   FD9B                    5003 SD_CARD_TYPE:	.blkb	1	;SD CARD TYPE
   FD9C                    5004 SDC_STATUS:	.blkb	1	;SD Status Code returned
   FD9D                    5005 SD_PARAM:	.blkb	4	;32 bit address parameter for SD Commands
   FDA1                    5006 SD_PART_TYPE:	.blkb	1	;SD PARTITION TYPE
   FDA2                    5007 SD_PART_BASE:	.blkb	4	;SD PARTITION STARTING RECORD
   FDA6                    5008 SD_PART_SIZE:	.blkb	4	;SD PARTITION SIZE (Must follow SD_PART_BASE)
   FDAA                    5009 BYTE_P_SEC:	.blkb	2	;0x0B Bytes per Sector (Almost always 512)
   FDAC                    5010 SEC_PER_CLUS:	.blkb	1	;0x0D
   FDAD                    5011 RESERVED_SEC:	.blkb	2	;0x0E - 0x0F
   FDAF                    5012 FAT_COPIES:	.blkb	1	;0x10
   FDB0                    5013 ROOTDIR_SIZE:	.blkb	2	;0x11 - 0x12
   FDB2                    5014 FILESYS_SEC:	.blkb	4	;0x13 - 0x14 or 0x20 - 0x23
   FDB6                    5015 HIDDEN_SEC:	.blkb	4	;0x1C - 0x1F
   FDBA                    5016 SEC_PER_FAT:	.blkb	2	;0x16 - 0x17
   FDBC                    5017 FAT1START:	.blkb	4	;Calculated Sector to FAT1
   FDC0                    5018 DIR_SECTOR:	.blkb	4	;Calculated Sector to Root Directory
   FDC4                    5019 DATASTART:	.blkb	4	;Calculated Sector to Data Area
   FDC8                    5020 FILENAME:	.blkb	8	;File Name
   FDD0                    5021 FILEEXT:		.blkb	3	;File Extension
   FDD3                    5022 SEC_PTR:		.blkb	4	;Sector Pointer, general use variable that holds the last sector read
   FDD7                    5023 DIRTY_DATA:	.blkb	1	;Indicates when data Read has been altered, ie. Requires flushing back to SD Card
   FDD8                    5024 ENT_COUNT:	.blkb	2	;Directory Entry Counter, Counts down maximum directory entries in Find File
   FDDA                    5025 CLUSTER1:	.blkb  2	;Cluster 1 of last opened file
   FDDC                    5026 FILESIZE:	.blkb  4	;File Size of last opened file (must follow CLUSTER1)
   FDE0                    5027 FILESIZEHEX:	.blkb  4
                           5028 
                           5029 
                           5030 ; BIOS SCRATCH AREA.
                           5031 ;
   FDE4                    5032 TRK:		.blkb   2		;CURRENT TRACK NUMBER.
   FDE6                    5033 SECT:		.blkb   1		;CURRENT SECTOR NUMBER.
   FDE7                    5034 DMAADD:		.blkb   2		;DISK TRANSFER ADDRESS.
   FDE9                    5035 DISKNO:		.blkb   1		;DISK NUMBER (TO CP/M).
   FDEA                    5036 TEMP:		.blkb   1		;TEMPORARY STORAGE.
                           5037 
                           5038 
   FE00                    5039 		.ORG	0xFE00
   FE00                    5040 SD_RAM_BUFFER:	.blkb	512		;512 BYTE SD CARD BUFFER
                           5041 
                           5042 
                           5043 		.end
                           5044 
                           5045 
                           5046 
                           5047 ;----------------------------------------------------------------------------------------------------; INSTRUCTION LIST REFERENCE
                           5048 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           5049 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           5050 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           5051 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           5052 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           5053 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           5054 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           5055 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 97
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           5056 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           5057 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           5058 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           5059 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           5060 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           5061 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           5062 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           5063 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           5064 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>;
                           5065 ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<;
                           5066 ;----------------------------------------------------------------------------------------------------;
                           5067 
                           5068 ;DATA TRANSFER GROUP
                           5069 ;'Mnem.     'Description                 'Notes                '
                           5070 ;'----------+----------------------------+---------------------'
                           5071 ; MOV r1,r2 | r1 <- r2                   |r = A,B,C,D,E,H,L
                           5072 ; MOV r,M   | r <- (HL)
                           5073 ; MOV M,r   | (HL) <- r
                           5074 ; HLT       | HALT
                           5075 ; MVI r,d   | r <- d, Move Immediate data
                           5076 ; MVI M     | (HL) <- d, Immediate data
                           5077 ; INR r     | r <- r+1
                           5078 ; DCR r     | r <- r-1
                           5079 ; INR M     | (HL) <- (HL)+1
                           5080 ; DCR M     | (HL) <- (HL)-1
                           5081 ; ADD r     | A <- A+r
                           5082 ; ADC r     | A <- A+r+CY                |Add with Carry
                           5083 ; SUB r     | A <- A-r
                           5084 ; SBB r     | A <- A-r-CY                |Subtract with Borrow
                           5085 ; ANA r     | A <- A AND r
                           5086 ; XRA r     | A <- A XOR r
                           5087 ; ORA r     | A <- A OR r
                           5088 ; CMP r     | A-r                        |Compare
                           5089 ; ADD M     | A <- A+(HL)
                           5090 ; ADC M     |
                           5091 ; SUB M     |
                           5092 ; SBB M     |
                           5093 ; ANA M     |
                           5094 ; XRA M     |
                           5095 ; ORA M     |
                           5096 ; CMP M     |
                           5097 ; ADI d     | A <- A+d, ADD Immediate data
                           5098 ; ACI d     |
                           5099 ; SUI d     |
                           5100 ; SBI d     |
                           5101 ; ANI d     |
                           5102 ; XRI d     |
                           5103 ; ORI d     |
                           5104 ; CPI d     |
                           5105 ; RLC       | Rotate A Left, CY<-MSB   Only Carry Affected
                           5106 ; RRC       | Rotate A Right, CY<-LSB  Only Carry Affected
                           5107 ; RAL       | Rotate A Left through Carry  Only Carry Affected
                           5108 ; RAR       | Rotate A Right through Carry Only Carry Affected
                           5109 ; JMP addr  | Jump Address
                           5110 ; JC  addr  | Jump on Carry
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 98
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           5111 ; JNC addr  | Jump on NOT Cary
                           5112 ; JZ  addr  | Jump on ZERO
                           5113 ; JNZ addr  | Jump on NOT ZERO
                           5114 ; JP  addr  | Jump on Positive (MSB=0)
                           5115 ; JM  addr  | Jump on Minus (MSB=1)
                           5116 ; JPE addr  | Jump on Parity Even (Parity bit =1)
                           5117 ; JPO addr  | Jump on Parity Odd (Parity bit =0)
                           5118 ; CALL addr | Call subroutine
                           5119 ; CC  addr
                           5120 ; CNC addr
                           5121 ; CZ  addr
                           5122 ; CNZ addr
                           5123 ; CP  addr
                           5124 ; CM  addr
                           5125 ; CPE addr
                           5126 ; CPO addr
                           5127 ; RET       | Return from subroutine
                           5128 ; RC
                           5129 ; RNC
                           5130 ; RZ
                           5131 ; RNZ
                           5132 ; RP
                           5133 ; RM
                           5134 ; RPE
                           5135 ; RPO
                           5136 ; RST n     | Restart to Vector n        | n=0,1,2,3,4,5,6,7
                           5137 ; IN  p     | A <- Port p, Input
                           5138 ; OUT p     | Port p <- A, Output
                           5139 ; LXI B,dd  | BC <- dd, Load Immediate data, 16 bit to Register Pair
                           5140 ; LXI D,dd  | DE <- dd
                           5141 ; LXI H,dd  | HL <- dd
                           5142 ; LXI SP,dd | SP <- dd
                           5143 ; PUSH B    | PUSH BC register pair to STACK
                           5144 ; PUSH D    | PUSH DE register pair to STACK
                           5145 ; PUSH H    | PUSH HL register pair to STACK
                           5146 ; PUSH PSW  | PUSH A,Flags register pair to STACK
                           5147 ; POP B     | POP BC register pair from STACK
                           5148 ; POP D     | POP DE register pair from STACK
                           5149 ; POP H     | POP HL register pair from STACK
                           5150 ; POP PSW   | POP A,Flags register pair from STACK
                           5151 ; STA addr  | (addr) <- A, Store A Direct
                           5152 ; LDA addr  | A <- (addr), Load A Direct
                           5153 ; XCHG      | Exchange HL <> DE
                           5154 ; XTHL      | Exchange HL <> (SP), Exchange HL with Top of Stack
                           5155 ; SPHL      | SP <- HL, Move HL to SP
                           5156 ; PCHL      | PC <- HL, Move HL to PC
                           5157 ; DAD B     | HL <- HL+BC, Add 16 bit register pairs
                           5158 ; DAD D     | HL <- HL+DE, Add 16 bit register pairs
                           5159 ; DAD H     | HL <- HL+HL, Add 16 bit register pairs
                           5160 ; DAD SP    | HL <- HL+SP, Add 16 bit register pairs
                           5161 ; STAX B    | (BC) <- A, Store A Indirect
                           5162 ; STAX D    | (DE) <- A, Store A Indirect
                           5163 ; LDAX B    | A <- (BC), Load A Indirect
                           5164 ; LDAX D    | A <- (DE), Load A Indirect
                           5165 ; INX B     | BC <- BC+1, Increment 16 bit register pair
ASxxxx Assembler V05.31  (Intel 8085)                                  Page 99
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020



                           5166 ; INX D     | DE <- DE+1, Increment 16 bit register pair
                           5167 ; INX H     | HL <- HL+1, Increment 16 bit register pair
                           5168 ; INX SP    | SP <- SP+1, Increment 16 bit register
                           5169 ; DCX B     | BC <- BC-1, Decrement 16 bit register pair
                           5170 ; DCX D     | DE <- DE-1, Decrement 16 bit register pair
                           5171 ; DCX H     | HL <- HL-1, Decrement 16 bit register pair
                           5172 ; DCX SP    | SP <- SP-1, Decrement 16 bit register
                           5173 ; CMA       | A <- /A, Complement Accumulator
                           5174 ; STC       | Set Carry
                           5175 ; CMC       | Complement Carry
                           5176 ; DAA       | Decimal Adjust Accumulator
                           5177 ; SHLD addr | (addr) <- HL, Store HL Direct
                           5178 ; LHLD addr | HL <- (addr), Load HL Direct
                           5179 ; EI        | Enable Interrupts
                           5180 ; DI        | Disable Interrupts
                           5181 ; NOP       | No Op
                           5182 
                           5183 ;            .ifDEF  label1
                           5184 ;            lda     byte1
                           5185 ;            sta     byte2
                           5186 ;            .endif
                           5187 ;
                           5188 ;
                           5189 ;            #ifdef  label1
                           5190 ;            lda     byte1
                           5191 ;            #else
                           5192 ;            lda     byte2
                           5193 ;            #endif
                           5194 ;
                           5195 ;            #ifndef label1
                           5196 ;            lda     byte2
                           5197 ;            #else
                           5198 ;            lda     byte1
                           5199 ;            #endif
                           5200 ;
                           5201 ;            #if ($ >= 1000h)
                           5202 ;            ; generate an invalid statement to cause an error
                           5203 ;            ;  when we go over the 4K boundary.
                           5204 ;             !!! PROM bounds exceeded.
                           5205 ;            #endif
ASxxxx Assembler V05.31  (Intel 8085)                                 Page 100
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020

Symbol Table

    .__.$$$.       =   2710 L   |     .__.ABS.       =   0000 G
    .__.CPU.       =   0000 L   |     .__.H$L.       =   0000 L
  2 ABORT_CHECK        E8C2 R   |     ABS_SEC        =   0018 
    ACK            =   0006     |   2 ADD_32_HL          F897 R
    AFClus0        =   000C     |   2 ALV0               FA80 R
  2 ALV1               FAAF R   |   2 ALV2               FADE R
  2 ALV3               FB0D R   |   2 ASC2HEX            E324 R
  2 ASCHEX             E349 R   |     BDOS           =   E006 
  2 BIN2HEX            F085 R   |     BIORAM         =   0040 
    BIOS           =   EE00     |   2 BIT_MARCH          E77E R
  2 BMD_LP             DBD9 R   |   2 BMD_NEXT           DCDE R
  2 BOOT_MENU          DBB6 R   |   2 BYTEMARCH2         E704 R
  2 BYTE_P_SEC         FDAA R   |     CAFClus        =   0010 
    CAN            =   0018     |   2 CBOOT              EEBB R
  2 CBOOTV             EE00 R   |     CCP            =   D800 
    CDISK          =   0004     |   2 CH3_R1             F8C5 R
  2 CH3_R2             F8C6 R   |   2 CH3_R3             F8C7 R
  2 CLEAR_RAM      =   FD87 R   |   2 CLUSTER1           FDDA R
  2 CMPF_LP1           F392 R   |   2 CMPF_RETFAIL       F3A0 R
  2 CMP_DE_HL          F8C9 R   |   2 CMP_FILENAME       F38C R
  2 CMP_HL_32          F8AD R   |   2 CMP_HL_DE          DFAA R
  2 CODE_START         DB00 R   |   2 CONFIGPTR          DD60 R
  2 CONFIGSIZE         DD5C R   |   2 CONFIGSIZECNT      DD5E R
  2 CONIN              EF65 R   |   2 CONOT              EF71 R
  2 CONOTA             EF8A R   |   2 CONOTF             FD80 R
  2 CONST              EF4E R   |   2 CONSTV             EE06 R
  2 CONST_0            EF58 R   |   2 COPY_RAM           F8E2 R
  2 COPY_RAM2          F8DB R   |   2 COPY_RAM4          F8E0 R
    CPMLEN         =   1600     |     CPM_DSK_BUFF   =   0080 
    CPU_IO         =   0020     |   2 CRC_UPC            E5F5 R
  2 CRC_UPDATE         E5D0 R   |     CRFClus        =   000E 
  2 CSV0               FA9F R   |   2 CSV1               FACE R
  2 CSV2               FAFD R   |   2 CSV3               FB2C R
  2 DAF_3B_RET         EBC9 R   |   2 DAF_LP             EC30 R
  2 DAPR_OK            EC7E R   |   2 DAPR_OK2           EC80 R
  2 DATASTART          FDC4 R   |   2 DA_DB              EB8A R
  2 DA_FOUND           EC2E R   |   2 DA_FOUND_1B        EC0F R
  2 DA_FOUND_1C        EC23 R   |   2 DA_FOUND_1D        EC06 R
  2 DA_FOUND_1R        EBDF R   |   2 DA_FOUND_2A        EBA2 R
  2 DA_FOUND_2B        EBF2 R   |   2 DA_FOUND_3B        EBAB R
  2 DA_FOUND_3C        EC18 R   |   2 DA_FOUND_3D        EB99 R
  2 DA_LOOKUP          EB2C R   |   2 DA_MOV             EC3D R
  2 DA_N1OP            EB18 R   |   2 DA_NOOP            EB27 R
  2 DA_PUT_DDD         EC5C R   |   2 DA_PUT_REGPAIR     EC6B R
  2 DA_PUT_SSS         EC4E R   |   2 DA_PUT_SSSDDD      EC4F R
  2 DBS_LP             F91C R   |     DBUF           =   0080 
    DC1            =   0011     |     DC3            =   0013 
    DEBUG          =   0000     |   2 DF_SHIFTCNT        FD93 R
  2 DIRBUF             FA00 R   |   2 DIRTY_DATA         FDD7 R
  2 DIR_SECTOR         FDC0 R   |   2 DISASM             EAF9 R
  2 DISKNO             FDE9 R   |   2 DISK_READ          F1C7 R
  2 DIV16BY8           F8FF R   |   2 DIV16BY8SPC        F8FC R
  2 DIV16BY8_LP        F905 R   |   2 DIV16BY8_SK        F910 R
  2 DIVBYSHIFT         F918 R   |   2 DIVIDE_FUNC        FD91 R
    DLE            =   0010     |   2 DL_P1E             DF70 R
ASxxxx Assembler V05.31  (Intel 8085)                                 Page 101
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020

Symbol Table

  2 DL_P1L             DF59 R   |   2 DL_P2              DF78 R
  2 DL_P2K1            DF95 R   |   2 DL_P2K2            DF9C R
  2 DL_P2L             DF8D R   |   2 DL_PSE2            DF8B R
  2 DL_PSL2            DF7F R   |   2 DMAADD             FDE7 R
  2 DO_DIR             E176 R   |   2 DO_DK_READSEC      E252 R
  2 DO_INIT_SDCARD     E2AA R   |   2 DO_OPEN            E15D R
  2 DO_SD_CLK          E2BC R   |   2 DO_SD_DESELECT     E2B6 R
  2 DO_SD_FINDFILE     E18B R   |   2 DO_SD_IFAT         E197 R
  2 DO_SD_PARAM        E1DB R   |   2 DO_SD_READSEC      E22D R
  2 DO_SD_SELECT       E2B0 R   |   2 DO_SD_TXM          E286 R
  2 DO_SD_WRITESEC     E21B R   |   2 DO_SEL_FCB         E19D R
  2 DPB0               EE7F R   |   2 DPB1               EE8E R
  2 DPB2               EE9D R   |   2 DPB3               EEAC R
  2 DPBASE             EE3F R   |   2 DPBPTR             DD62 R
  2 DREAD              EFD6 R   |   2 DREADE             EFF5 R
  2 DREADX             EFF8 R   |   2 DRSS_ABC           F2E7 R
  2 DRSS_LP            F2BB R   |   2 DRSS_SHIFT         F2C8 R
  2 DRS_0              F272 R   |   2 DR_1               F1F0 R
  2 DR_BIGGER_CLUS     F246 R   |   2 DR_DIFF_CLUS       F23B R
  2 DR_NEW_SEC         F212 R   |   2 DR_READ_IT         F31A R
  2 DR_SAME_CLUS       F2F6 R   |   2 DR_SEEK_DONE       F299 R
  2 DR_SEEK_FAT        F24E R   |   2 DR_SEEK_LP         F251 R
  2 DSC_0              E2BE R   |   2 DSDR_FAIL          E244 R
  2 DST_LP             E297 R   |   2 DUMP_LINE          DF40 R
  2 DWRITE             EFFE R   |   2 ECHO_ON            FD81 R
  2 ENT_COUNT          FDD8 R   |     EOT            =   0004 
  2 FAT1START          FDBC R   |   2 FAT_COPIES         FDAF R
  2 FB_LP              F8F2 R   |   2 FCB_CONFIG         DD40 R
  2 FCB_CONFIG_C1      DD4C R   |   2 FCB_PTR            FD83 R
  2 FILEEXT            FDD0 R   |   2 FILENAME           FDC8 R
  2 FILEOK             DB95 R   |   2 FILESIZE           FDDC R
  2 FILESIZEHEX        FDE0 R   |   2 FILESYS_SEC        FDB2 R
  2 FILL_BLOCK         F8F0 R   |     FNAME          =   0001 
    FPLED          =   00FF     |     FPSW           =   00FF 
  2 FS2ASC_LP          DC19 R   |     FSTAT          =   0000 
  2 FXMDN              EA41 R   |   2 FXMDN_DONE         EA9D R
  2 FXMDN_LP           EA73 R   |   2 FXMENU_LP          EA22 R
  2 FXMODEM            E912 R   |   2 FXMUP              EAA3 R
  2 FXSERR             E8DB R   |   2 GB_1               E2DE R
  2 GB_2               E2F4 R   |   2 GB_RET             E2FC R
  2 GB_UNDO            E2F7 R   |   2 GCU_PROPSTRIKE     F0CB R
  2 GCU_UART           F0D5 R   |   2 GDW_LP             E20C R
  2 GETHEXFILE         E358 R   |   2 GETLOG             F026 R
  2 GET_BYTE           E2D1 R   |   2 GET_CHAR           F0D8 R
  2 GET_CHAR_LP        F0DF R   |   2 GET_CHAR_NE        F12E R
  2 GET_CHAR_UART      F0AA R   |   2 GET_CONTINUE       DF18 R
  2 GET_HEX_CHAR       E321 R   |   2 GET_STRING         F861 R
  2 GET_WORD           E302 R   |   2 GHC_ARET           E344 R
  2 GHC_NOT_RET        E342 R   |   2 GHC_NRET           E346 R
  2 GHDOLINE           E369 R   |   2 GHEND              E39E R
  2 GHLOOP             E384 R   |   2 GHWAIT             E361 R
  2 GLT_LP             DC79 R   |   2 GLT_NOTEQ          DCBC R
  2 GL_BF              DC59 R   |   2 GL_CTRL            DC70 R
  2 GL_EOF             DCC3 R   |   2 GL_LP              F031 R
  2 GL_LP1             DC44 R   |   2 GL_LP2             DC4B R
ASxxxx Assembler V05.31  (Intel 8085)                                 Page 102
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020

Symbol Table

  2 GL_SHIFT           F038 R   |   2 GOBYTE             E005 R
  2 GO_HALT            DB7E R   |   2 GS_ESC             E5BE R
  2 GS_SEQ             E5C1 R   |   2 GTL_COPY_LP        DC8D R
  2 GTL_GETHEX         DCA7 R   |   2 GW_LP              E312 R
  2 HIDDEN_SEC         FDB6 R   |   2 HIGHSTACK          FD00 R
  2 HOME               EFBC R   |   2 IB_LP              DD33 R
  2 IB_RET             DD3E R   |   2 INC_32             F8A7 R
  2 INITFAT_C1_DON     F44F R   |   2 INITFAT_C2_DON     F471 R
  2 INITFAT_C2_LP      F45D R   |   2 INITFAT_C3_0       F4AC R
  2 INITFAT_C3_1       F4D3 R   |   2 INITFAT_C3_ERR     F497 R
  2 INITFAT_C3_LP      F47D R   |   2 INITFAT_C3_LP2     F4AE R
  2 INITFAT_C3_LP3     F4C0 R   |   2 INITFAT_C4_1       F4EA R
  2 INITFAT_C4_2       F504 R   |   2 INITFAT_C4_3       F509 R
  2 INITFAT_C4_LP      F4E4 R   |   2 INITFAT_FAIL       F546 R
  2 INITFAT_FAIL1      F530 R   |   2 INITFAT_PGOOD      F3EB R
  2 INITFAT_TFS_DO     F431 R   |   2 INITFAT_TFS_OK     F42A R
  2 INIT_BLOCK         DD2E R   |   2 INIT_FAIL          F6A2 R
  2 INIT_FAT           F3A3 R   |   2 INIT_SDCARD        F66F R
  2 INPUT_FNAME        F7F2 R   |   2 INPUT_NAME         DB8D R
    IOBYTE         =   0003     |   2 ISD_0              F679 R
  2 ISD_1              F6B3 R   |   2 ISD_2              F6D5 R
  2 ISD_3              F6F0 R   |   2 ISD_4              F71D R
  2 ISD_5              F74E R   |   2 ISD_6              F757 R
  2 ISD_LP1            F694 R   |   2 ISD_LP2            F703 R
  2 L2LP               EAE0 R   |   2 L2PNT              EAEC R
  2 L2PSS              EAF1 R   |   2 LD_HL_HL           F8EB R
  2 LINE_BUFF          DD64 R   |   2 LINE_BUFFEND       DDE4 R
  2 LIST               EF8F R   |   2 LISTST             EF9C R
  2 LOG2PHY            EAD9 R   |   2 LOGICAL_SEC        FD99 R
  2 LOWSTACK       =   FB3C R   |   2 LS_LP              EC97 R
  2 LS_SEARCH          EC94 R   |   2 LTBSY              EF8F R
  2 MAIN_MENU          DDE5 R   |   2 MEM_DUMP           DEFF R
  2 MEM_DUMP_LP        DF06 R   |   2 MEM_EDIT           DFBE R
  2 MEM_EXEC           DFE7 R   |   2 MEM_UNASM          DEE0 R
  2 ME_LP              DFC2 R   |   2 MODBYMASK          F928 R
  2 MODMASK            FD98 R   |   2 MOD_FUNC           FD96 R
  2 MOV_32_HL          F887 R   |   2 MOV_HL_32          F88F R
    MSIZE          =   003D     |   2 MUL8               FD94 R
  2 MU_LP1             DEEB R   |   2 MU_LP2             DEED R
  2 M_COUNTER          FD95 R   |     NAK            =   0015 
    NDSK           =   0004     |     NSECTS         =   002C 
    OPTS           =   0040     |   2 PCU0           =   F0F5 R
  2 PCU5           =   F0ED R   |   2 PC_EXIT            F110 R
  2 PC_LP              F0EC R   |   2 PC_LP2             F102 R
  2 PC_TO              F10F R   |   2 PFE                F840 R
  2 PF_LP1             F82E R   |   2 PF_LP2             F84D R
  2 PF_RET             F85F R   |     PORT2          =   0038 
  2 PORT_INP           DFEC R   |   2 PORT_OUT           DFFC R
  2 PRINT              F08E R   |   2 PRINTB             F0A0 R
  2 PRINTI             F098 R   |   2 PRINT_FILENAME     F82B R
    PROPELLERD     =   0001     |     PROPELLERS     =   0000 
  2 PROP_CHECK         FD82 R   |   2 PUNCH              EF9A R
  2 PURGE              E621 R   |   2 PUT_3C_SPACES      DFB0 R
  2 PUT_BC             F04F R   |   2 PUT_BYTE           F070 R
  2 PUT_CHAR           F0EB R   |   2 PUT_DE             F05A R
ASxxxx Assembler V05.31  (Intel 8085)                                 Page 103
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020

Symbol Table

  2 PUT_HEX            F07F R   |   2 PUT_HL             F065 R
  2 PUT_NEW_LINE       F048 R   |   2 PUT_SPACE          E353 R
  2 RAM_TEST           E62A R   |   2 READER             EF9B R
  2 RESERVED_SEC       FDAD R   |     RFSec          =   0012 
  2 RHLR               F8CF R   |   2 ROOTDIR_SIZE       FDB0 R
  2 RT1_LP0            E645 R   |   2 RT1_LP1            E648 R
  2 RT1_LP2            E64A R   |   2 RT1_LP3            E656 R
  2 RT1_LP4            E65E R   |   2 RT1_LP5            E664 R
  2 RT1_LP6            E66B R   |   2 RT1_LP7            E67C R
  2 RT2_LP0            E6A8 R   |   2 RT2_LP1            E6A9 R
  2 RT2_LP2            E6B4 R   |   2 RT2_LP3            E6BB R
  2 RT2_LP4            E6C1 R   |   2 RT2_NX1            E6D1 R
  2 RT3_LP1            E780 R   |   2 RT3_LP2            E78A R
  2 RT3_LP3            E78B R   |   2 RT3_LP4            E797 R
  2 RT3_LP5            E798 R   |   2 RT3_NX1            E7B5 R
  2 RT4_LP0            E706 R   |   2 RT4_LP1            E70B R
  2 RT4_LP2            E70D R   |   2 RT4_LP3            E718 R
  2 RT4_LP4            E721 R   |   2 RT4_LP5            E72A R
  2 RT4_LP6            E730 R   |   2 RT4_LP7            E73F R
  2 RT4_LP8            E750 R   |   2 RT4_NX             E74A R
  2 RT5_LP1            E7D6 R   |   2 RT5_LP2            E7E1 R
  2 RT5_LP3            E7F3 R   |   2 RT5_NX1            E7E6 R
  2 RT5_NX2            E7F8 R   |   2 RT_FAIL1           E82C R
  2 RT_FAIL2           E851 R   |   2 RT_FAIL3           E876 R
  2 RT_FAIL5           E89A R   |   2 SDC_1              F784 R
  2 SDC_2              F78B R   |   2 SDC_LP             F7A9 R
  2 SDC_RET            F7B8 R   |   2 SDC_STATUS         FD9C R
  2 SDFF_LP            F1BC R   |   2 SDISKA             FD00 R
  2 SDISKB             FD20 R   |   2 SDISKC             FD40 R
  2 SDISKD             FD60 R   |   2 SDLF_LP            E17C R
  2 SDO_FSERR2         F28D R   |   2 SDV_FIND_FILE      F190 R
  2 SDV_FIND_FILE1     F196 R   |   2 SDV_FOUND          F1AC R
  2 SD_CARD_TYPE       FD9B R   |   2 SD_CLEAR_ARG       F7E4 R
  2 SD_CMD             F774 R   |   2 SD_DELAY           F76F R
  2 SD_DELAY100        F76D R   |   2 SD_DESELECT        F75C R
  2 SD_FETCH           F165 R   |   2 SD_FIND_FILE       F1B9 R
  2 SD_LDIR1           F158 R   |   2 SD_LDIRN           F16E R
  2 SD_MENU            E011 R   |   2 SD_MENUCMD         E0E0 R
  2 SD_OPEN            F351 R   |   2 SD_OPENT           F330 R
  2 SD_PARAM           FD9D R   |   2 SD_PART_BASE       FDA2 R
  2 SD_PART_SIZE       FDA6 R   |   2 SD_PART_TYPE       FDA1 R
  2 SD_RAM_BUFFER      FE00 R   |   2 SD_READ_SEC        F571 R
  2 SD_RS_0            F5AE R   |   2 SD_RS_1            F5C0 R
  2 SD_RS_FORCED       F57B R   |   2 SD_RS_LP0          F59D R
  2 SD_RS_LP1          F5B0 R   |   2 SD_RS_LP2          F5C3 R
  2 SD_RS_NC           F592 R   |   2 SD_SELECT          F763 R
  2 SD_TEST            F16B R   |   2 SD_WRITE_SEC       F5DB R
  2 SD_WR_FAIL         F639 R   |   2 SD_WR_LP           F5EF R
  2 SECT               FDE6 R   |   2 SECTRN             EFD3 R
  2 SEC_PER_CLUS       FDAC R   |   2 SEC_PER_FAT        FDBA R
  2 SEC_PER_TRACK      FD85 R   |   2 SEC_PTR            FDD3 R
  2 SELDSK             EF9D R   |   2 SELDSKV            EE1B R
  2 SELECT_UART0       F114 R   |   2 SELECT_UART1       F121 R
  2 SETDMA             EFCB R   |   2 SETDMAV            EE24 R
  2 SETSEC             EFC5 R   |   2 SETTRK             EFBE R
ASxxxx Assembler V05.31  (Intel 8085)                                 Page 104
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020

Symbol Table

  2 SET_FCB_PTR        F138 R   |   2 SET_PARAM          F654 R
  2 SET_QUARTER        F31D R   |   2 SFPE               F156 R
    SKEW           =   0000     |     SOH            =   0001 
  2 SPACE_GET_BYTE     E2CE R   |   2 SPACE_GET_WORD     E2FF R
    SPI            =   0030     |   2 SPI_RX             F7BA R
    SPI_SS         =   0031     |   2 SP_RET             F665 R
  2 SQ_0               F329 R   |     SSOC           =   0014 
    STACK_SIZE     =   01C4     |     SYN            =   0016 
  2 TBL_1A             ECA0 R   |   2 TBL_1B             ED16 R
  2 TBL_1C             ECF6 R   |   2 TBL_1D             ED3F R
  2 TBL_1E             ED4A R   |   2 TBL_2A             ED55 R
  2 TBL_3B             EDA7 R   |   2 TBL_3C             ED10 R
  2 TBL_3D             ED88 R   |   2 TBL_CC             EBCF R
  2 TBL_DDDSSS         EC63 R   |   2 TBL_REGPAIR        EC87 R
  2 TEMP               FDEA R   |   2 TEMP_STACK     =   FA00 R
  2 TEST_SIGNATURE     F55C R   |   2 TGC_DO             E61B R
  2 TGC_LP1            E603 R   |   2 TGC_LP2            E605 R
  2 TGC_RET            E61E R   |     TICK           =   0042 
  2 TIMED1_GETCHAR     E5FE R   |   2 TIMED_GETCHAR      E600 R
  2 TO_UPPER           F87E R   |   2 TRK                FDE4 R
    UART0          =   0020     |     UART1          =   0028 
  2 VCALL              F8FB R   |   2 WAIT_NOT_BUSY      F7C2 R
  2 WBLP               EF13 R   |   2 WBOOT              EEF0 R
  2 WBOOTV             EE03 R   |   2 WNB_0              F7D8 R
  2 WNB_LP             F7C6 R   |   2 WNB_LP2            F7C8 R
  2 XCOUNT             FD8B R   |   2 XMDN               E3E0 R
  2 XMDN_LP            E3ED R   |   2 XMGET_HDR          E5A9 R
  2 XMODEM             E3C8 R   |   2 XMR_ACK            E593 R
  2 XMR_BLK_LP         E558 R   |   2 XMR_CCS            E589 R
  2 XMR_CRC            E4E8 R   |   2 XMR_CS             E502 R
  2 XMR_INIT           E4E1 R   |   2 XMR_LP             E522 R
  2 XMR_NAK            E59D R   |   2 XMR_RECV           E51D R
  2 XMR_SEQ_OK         E550 R   |   2 XMR_TSEQ           E53A R
  2 XMSEQ              FD87 R   |   2 XMS_BLP            E44B R
  2 XMS_CS             E467 R   |   2 XMS_DO             E42C R
  2 XMS_EOT            E48B R   |   2 XMS_INIT           E40C R
  2 XMS_INIT_LP        E413 R   |   2 XMS_RESEND         E430 R
  2 XMS_SEND           E434 R   |   2 XMTYPE             FD88 R
  2 XMUP               E3FC R   |   2 XMUP_LP            E403 R
  2 XMU_DISK_LP        EAB8 R   |   2 XM_CANCEL          E4BD R
  2 XM_DONE            E4A2 R   |   2 XPOS               FD8F R
  2 XSECTOR            FD89 R   |   2 XSUM               FD8D R
  2 XTRACK             FD8A R

ASxxxx Assembler V05.31  (Intel 8085)                                 Page 105
Hexadecimal [16-Bits]                                 Tue Nov 17 09:59:44 2020

Area Table

[_CSEG]
   0 _CODE            size    0   flags C080
   2 CODE1            size    0   flags  908
[_DSEG]
   1 _DATA            size    0   flags C0C0

